{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar _react = require('react');\nvar React = _interopRequireWildcard(_react);\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n    newObj.default = obj;\n    return newObj;\n  }\n}\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/* global global */\n\nvar KEYCODE_ENTER = 13;\nvar KEYCODE_TAB = 9;\nvar KEYCODE_BACKSPACE = 8;\nvar KEYCODE_Y = 89;\nvar KEYCODE_Z = 90;\nvar KEYCODE_M = 77;\nvar KEYCODE_PARENS = 57;\nvar KEYCODE_BRACKETS = 219;\nvar KEYCODE_QUOTE = 222;\nvar KEYCODE_BACK_QUOTE = 192;\nvar KEYCODE_ESCAPE = 27;\nvar HISTORY_LIMIT = 100;\nvar HISTORY_TIME_GAP = 3000;\nvar isWindows = 'navigator' in global && /Win/i.test(navigator.platform);\nvar isMacLike = 'navigator' in global && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\nvar className = 'npm__react-simple-code-editor__textarea';\nvar cssText = /* CSS */'\\n/**\\n * Reset the text fill color so that placeholder is visible\\n */\\n.' + className + ':empty {\\n  -webkit-text-fill-color: inherit !important;\\n}\\n\\n/**\\n * Hack to apply on some CSS on IE10 and IE11\\n */\\n@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) {\\n  /**\\n    * IE doesn\\'t support \\'-webkit-text-fill-color\\'\\n    * So we use \\'color: transparent\\' to make the text transparent on IE\\n    * Unlike other browsers, it doesn\\'t affect caret color in IE\\n    */\\n  .' + className + ' {\\n    color: transparent !important;\\n  }\\n\\n  .' + className + '::selection {\\n    background-color: #accef7 !important;\\n    color: transparent !important;\\n  }\\n}\\n';\nvar Editor = function (_React$Component) {\n  _inherits(Editor, _React$Component);\n  function Editor() {\n    var _ref;\n    var _temp, _this, _ret;\n    _classCallCheck(this, Editor);\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Editor.__proto__ || Object.getPrototypeOf(Editor)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      capture: true\n    }, _this._recordCurrentState = function () {\n      var input = _this._input;\n      if (!input) return;\n\n      // Save current state of the input\n      var value = input.value,\n        selectionStart = input.selectionStart,\n        selectionEnd = input.selectionEnd;\n      _this._recordChange({\n        value: value,\n        selectionStart: selectionStart,\n        selectionEnd: selectionEnd\n      });\n    }, _this._getLines = function (text, position) {\n      return text.substring(0, position).split('\\n');\n    }, _this._recordChange = function (record) {\n      var overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var _this$_history = _this._history,\n        stack = _this$_history.stack,\n        offset = _this$_history.offset;\n      if (stack.length && offset > -1) {\n        // When something updates, drop the redo operations\n        _this._history.stack = stack.slice(0, offset + 1);\n\n        // Limit the number of operations to 100\n        var count = _this._history.stack.length;\n        if (count > HISTORY_LIMIT) {\n          var extras = count - HISTORY_LIMIT;\n          _this._history.stack = stack.slice(extras, count);\n          _this._history.offset = Math.max(_this._history.offset - extras, 0);\n        }\n      }\n      var timestamp = Date.now();\n      if (overwrite) {\n        var last = _this._history.stack[_this._history.offset];\n        if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\n          // A previous entry exists and was in short interval\n\n          // Match the last word in the line\n          var re = /[^a-z0-9]([a-z0-9]+)$/i;\n\n          // Get the previous line\n          var previous = _this._getLines(last.value, last.selectionStart).pop().match(re);\n\n          // Get the current line\n          var current = _this._getLines(record.value, record.selectionStart).pop().match(re);\n          if (previous && current && current[1].startsWith(previous[1])) {\n            // The last word of the previous line and current line match\n            // Overwrite previous entry so that undo will remove whole word\n            _this._history.stack[_this._history.offset] = _extends({}, record, {\n              timestamp: timestamp\n            });\n            return;\n          }\n        }\n      }\n\n      // Add the new operation to the stack\n      _this._history.stack.push(_extends({}, record, {\n        timestamp: timestamp\n      }));\n      _this._history.offset++;\n    }, _this._updateInput = function (record) {\n      var input = _this._input;\n      if (!input) return;\n\n      // Update values and selection state\n      input.value = record.value;\n      input.selectionStart = record.selectionStart;\n      input.selectionEnd = record.selectionEnd;\n      _this.props.onValueChange(record.value);\n    }, _this._applyEdits = function (record) {\n      // Save last selection state\n      var input = _this._input;\n      var last = _this._history.stack[_this._history.offset];\n      if (last && input) {\n        _this._history.stack[_this._history.offset] = _extends({}, last, {\n          selectionStart: input.selectionStart,\n          selectionEnd: input.selectionEnd\n        });\n      }\n\n      // Save the changes\n      _this._recordChange(record);\n      _this._updateInput(record);\n    }, _this._undoEdit = function () {\n      var _this$_history2 = _this._history,\n        stack = _this$_history2.stack,\n        offset = _this$_history2.offset;\n\n      // Get the previous edit\n\n      var record = stack[offset - 1];\n      if (record) {\n        // Apply the changes and update the offset\n        _this._updateInput(record);\n        _this._history.offset = Math.max(offset - 1, 0);\n      }\n    }, _this._redoEdit = function () {\n      var _this$_history3 = _this._history,\n        stack = _this$_history3.stack,\n        offset = _this$_history3.offset;\n\n      // Get the next edit\n\n      var record = stack[offset + 1];\n      if (record) {\n        // Apply the changes and update the offset\n        _this._updateInput(record);\n        _this._history.offset = Math.min(offset + 1, stack.length - 1);\n      }\n    }, _this._handleKeyDown = function (e) {\n      var _this$props = _this.props,\n        tabSize = _this$props.tabSize,\n        insertSpaces = _this$props.insertSpaces,\n        ignoreTabKey = _this$props.ignoreTabKey,\n        onKeyDown = _this$props.onKeyDown;\n      if (onKeyDown) {\n        onKeyDown(e);\n        if (e.defaultPrevented) {\n          return;\n        }\n      }\n      if (e.keyCode === KEYCODE_ESCAPE) {\n        e.target.blur();\n      }\n      var _e$target = e.target,\n        value = _e$target.value,\n        selectionStart = _e$target.selectionStart,\n        selectionEnd = _e$target.selectionEnd;\n      var tabCharacter = (insertSpaces ? ' ' : '\\t').repeat(tabSize);\n      if (e.keyCode === KEYCODE_TAB && !ignoreTabKey && _this.state.capture) {\n        // Prevent focus change\n        e.preventDefault();\n        if (e.shiftKey) {\n          // Unindent selected lines\n          var linesBeforeCaret = _this._getLines(value, selectionStart);\n          var startLine = linesBeforeCaret.length - 1;\n          var endLine = _this._getLines(value, selectionEnd).length - 1;\n          var nextValue = value.split('\\n').map(function (line, i) {\n            if (i >= startLine && i <= endLine && line.startsWith(tabCharacter)) {\n              return line.substring(tabCharacter.length);\n            }\n            return line;\n          }).join('\\n');\n          if (value !== nextValue) {\n            var startLineText = linesBeforeCaret[startLine];\n            _this._applyEdits({\n              value: nextValue,\n              // Move the start cursor if first line in selection was modified\n              // It was modified only if it started with a tab\n              selectionStart: startLineText.startsWith(tabCharacter) ? selectionStart - tabCharacter.length : selectionStart,\n              // Move the end cursor by total number of characters removed\n              selectionEnd: selectionEnd - (value.length - nextValue.length)\n            });\n          }\n        } else if (selectionStart !== selectionEnd) {\n          // Indent selected lines\n          var _linesBeforeCaret = _this._getLines(value, selectionStart);\n          var _startLine = _linesBeforeCaret.length - 1;\n          var _endLine = _this._getLines(value, selectionEnd).length - 1;\n          var _startLineText = _linesBeforeCaret[_startLine];\n          _this._applyEdits({\n            value: value.split('\\n').map(function (line, i) {\n              if (i >= _startLine && i <= _endLine) {\n                return tabCharacter + line;\n              }\n              return line;\n            }).join('\\n'),\n            // Move the start cursor by number of characters added in first line of selection\n            // Don't move it if it there was no text before cursor\n            selectionStart: /\\S/.test(_startLineText) ? selectionStart + tabCharacter.length : selectionStart,\n            // Move the end cursor by total number of characters added\n            selectionEnd: selectionEnd + tabCharacter.length * (_endLine - _startLine + 1)\n          });\n        } else {\n          var updatedSelection = selectionStart + tabCharacter.length;\n          _this._applyEdits({\n            // Insert tab character at caret\n            value: value.substring(0, selectionStart) + tabCharacter + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection\n          });\n        }\n      } else if (e.keyCode === KEYCODE_BACKSPACE) {\n        var hasSelection = selectionStart !== selectionEnd;\n        var textBeforeCaret = value.substring(0, selectionStart);\n        if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\n          // Prevent default delete behaviour\n          e.preventDefault();\n          var _updatedSelection = selectionStart - tabCharacter.length;\n          _this._applyEdits({\n            // Remove tab character at caret\n            value: value.substring(0, selectionStart - tabCharacter.length) + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: _updatedSelection,\n            selectionEnd: _updatedSelection\n          });\n        }\n      } else if (e.keyCode === KEYCODE_ENTER) {\n        // Ignore selections\n        if (selectionStart === selectionEnd) {\n          // Get the current line\n          var line = _this._getLines(value, selectionStart).pop();\n          var matches = line.match(/^\\s+/);\n          if (matches && matches[0]) {\n            e.preventDefault();\n\n            // Preserve indentation on inserting a new line\n            var indent = '\\n' + matches[0];\n            var _updatedSelection2 = selectionStart + indent.length;\n            _this._applyEdits({\n              // Insert indentation character at caret\n              value: value.substring(0, selectionStart) + indent + value.substring(selectionEnd),\n              // Update caret position\n              selectionStart: _updatedSelection2,\n              selectionEnd: _updatedSelection2\n            });\n          }\n        }\n      } else if (e.keyCode === KEYCODE_PARENS || e.keyCode === KEYCODE_BRACKETS || e.keyCode === KEYCODE_QUOTE || e.keyCode === KEYCODE_BACK_QUOTE) {\n        var chars = void 0;\n        if (e.keyCode === KEYCODE_PARENS && e.shiftKey) {\n          chars = ['(', ')'];\n        } else if (e.keyCode === KEYCODE_BRACKETS) {\n          if (e.shiftKey) {\n            chars = ['{', '}'];\n          } else {\n            chars = ['[', ']'];\n          }\n        } else if (e.keyCode === KEYCODE_QUOTE) {\n          if (e.shiftKey) {\n            chars = ['\"', '\"'];\n          } else {\n            chars = [\"'\", \"'\"];\n          }\n        } else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) {\n          chars = ['`', '`'];\n        }\n\n        // If text is selected, wrap them in the characters\n        if (selectionStart !== selectionEnd && chars) {\n          e.preventDefault();\n          _this._applyEdits({\n            value: value.substring(0, selectionStart) + chars[0] + value.substring(selectionStart, selectionEnd) + chars[1] + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: selectionStart,\n            selectionEnd: selectionEnd + 2\n          });\n        }\n      } else if ((isMacLike ?\n      // Trigger undo with ⌘+Z on Mac\n      e.metaKey && e.keyCode === KEYCODE_Z :\n      // Trigger undo with Ctrl+Z on other platforms\n      e.ctrlKey && e.keyCode === KEYCODE_Z) && !e.shiftKey && !e.altKey) {\n        e.preventDefault();\n        _this._undoEdit();\n      } else if ((isMacLike ?\n      // Trigger redo with ⌘+Shift+Z on Mac\n      e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey : isWindows ?\n      // Trigger redo with Ctrl+Y on Windows\n      e.ctrlKey && e.keyCode === KEYCODE_Y :\n      // Trigger redo with Ctrl+Shift+Z on other platforms\n      e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) && !e.altKey) {\n        e.preventDefault();\n        _this._redoEdit();\n      } else if (e.keyCode === KEYCODE_M && e.ctrlKey && (isMacLike ? e.shiftKey : true)) {\n        e.preventDefault();\n\n        // Toggle capturing tab key so users can focus away\n        _this.setState(function (state) {\n          return {\n            capture: !state.capture\n          };\n        });\n      }\n    }, _this._handleChange = function (e) {\n      var _e$target2 = e.target,\n        value = _e$target2.value,\n        selectionStart = _e$target2.selectionStart,\n        selectionEnd = _e$target2.selectionEnd;\n      _this._recordChange({\n        value: value,\n        selectionStart: selectionStart,\n        selectionEnd: selectionEnd\n      }, true);\n      _this.props.onValueChange(value);\n    }, _this._history = {\n      stack: [],\n      offset: -1\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n  _createClass(Editor, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this._recordCurrentState();\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n      var _props = this.props,\n        value = _props.value,\n        style = _props.style,\n        padding = _props.padding,\n        highlight = _props.highlight,\n        textareaId = _props.textareaId,\n        autoFocus = _props.autoFocus,\n        disabled = _props.disabled,\n        form = _props.form,\n        maxLength = _props.maxLength,\n        minLength = _props.minLength,\n        name = _props.name,\n        placeholder = _props.placeholder,\n        readOnly = _props.readOnly,\n        required = _props.required,\n        onClick = _props.onClick,\n        onFocus = _props.onFocus,\n        onBlur = _props.onBlur,\n        onKeyUp = _props.onKeyUp,\n        onKeyDown = _props.onKeyDown,\n        onValueChange = _props.onValueChange,\n        tabSize = _props.tabSize,\n        insertSpaces = _props.insertSpaces,\n        ignoreTabKey = _props.ignoreTabKey,\n        rest = _objectWithoutProperties(_props, ['value', 'style', 'padding', 'highlight', 'textareaId', 'autoFocus', 'disabled', 'form', 'maxLength', 'minLength', 'name', 'placeholder', 'readOnly', 'required', 'onClick', 'onFocus', 'onBlur', 'onKeyUp', 'onKeyDown', 'onValueChange', 'tabSize', 'insertSpaces', 'ignoreTabKey']);\n      var contentStyle = {\n        paddingTop: padding,\n        paddingRight: padding,\n        paddingBottom: padding,\n        paddingLeft: padding\n      };\n      var highlighted = highlight(value);\n      return React.createElement('div', _extends({}, rest, {\n        style: _extends({}, styles.container, style)\n      }), React.createElement('textarea', {\n        ref: function ref(c) {\n          return _this2._input = c;\n        },\n        style: _extends({}, styles.editor, styles.textarea, contentStyle),\n        className: className,\n        id: textareaId,\n        value: value,\n        onChange: this._handleChange,\n        onKeyDown: this._handleKeyDown,\n        onClick: onClick,\n        onKeyUp: onKeyUp,\n        onFocus: onFocus,\n        onBlur: onBlur,\n        disabled: disabled,\n        form: form,\n        maxLength: maxLength,\n        minLength: minLength,\n        name: name,\n        placeholder: placeholder,\n        readOnly: readOnly,\n        required: required,\n        autoFocus: autoFocus,\n        autoCapitalize: 'off',\n        autoComplete: 'off',\n        autoCorrect: 'off',\n        spellCheck: false,\n        'data-gramm': false\n      }), React.createElement('pre', _extends({\n        'aria-hidden': 'true',\n        style: _extends({}, styles.editor, styles.highlight, contentStyle)\n      }, typeof highlighted === 'string' ? {\n        dangerouslySetInnerHTML: {\n          __html: highlighted + '<br />'\n        }\n      } : {\n        children: highlighted\n      })), React.createElement('style', {\n        type: 'text/css',\n        dangerouslySetInnerHTML: {\n          __html: cssText\n        }\n      }));\n    }\n  }, {\n    key: 'session',\n    get: function get() {\n      return {\n        history: this._history\n      };\n    },\n    set: function set(session) {\n      this._history = session.history;\n    }\n  }]);\n  return Editor;\n}(React.Component);\nEditor.defaultProps = {\n  tabSize: 2,\n  insertSpaces: true,\n  ignoreTabKey: false,\n  padding: 0\n};\nexports.default = Editor;\nvar styles = {\n  container: {\n    position: 'relative',\n    textAlign: 'left',\n    boxSizing: 'border-box',\n    padding: 0,\n    overflow: 'hidden'\n  },\n  textarea: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    height: '100%',\n    width: '100%',\n    resize: 'none',\n    color: 'inherit',\n    overflow: 'hidden',\n    MozOsxFontSmoothing: 'grayscale',\n    WebkitFontSmoothing: 'antialiased',\n    WebkitTextFillColor: 'transparent'\n  },\n  highlight: {\n    position: 'relative',\n    pointerEvents: 'none'\n  },\n  editor: {\n    margin: 0,\n    border: 0,\n    background: 'none',\n    boxSizing: 'inherit',\n    display: 'inherit',\n    fontFamily: 'inherit',\n    fontSize: 'inherit',\n    fontStyle: 'inherit',\n    fontVariantLigatures: 'inherit',\n    fontWeight: 'inherit',\n    letterSpacing: 'inherit',\n    lineHeight: 'inherit',\n    tabSize: 'inherit',\n    textIndent: 'inherit',\n    textRendering: 'inherit',\n    textTransform: 'inherit',\n    whiteSpace: 'pre-wrap',\n    wordBreak: 'keep-all',\n    overflowWrap: 'break-word'\n  }\n};","map":{"version":3,"sources":["../src/index.js"],"names":["React","KEYCODE_ENTER","KEYCODE_TAB","KEYCODE_BACKSPACE","KEYCODE_Y","KEYCODE_Z","KEYCODE_M","KEYCODE_PARENS","KEYCODE_BRACKETS","KEYCODE_QUOTE","KEYCODE_BACK_QUOTE","KEYCODE_ESCAPE","HISTORY_LIMIT","HISTORY_TIME_GAP","isWindows","global","test","navigator","platform","isMacLike","className","cssText","Editor","Component","defaultProps","tabSize","insertSpaces","ignoreTabKey","padding","state","capture","_recordCurrentState","input","_input","value","selectionStart","selectionEnd","_recordChange","_getLines","text","position","substring","split","record","overwrite","stack","offset","_history","length","slice","count","extras","Math","max","timestamp","Date","now","last","re","previous","pop","match","current","startsWith","push","_updateInput","props","onValueChange","_applyEdits","_undoEdit","_redoEdit","min","_handleKeyDown","e","onKeyDown","defaultPrevented","keyCode","target","blur","tabCharacter","repeat","preventDefault","shiftKey","linesBeforeCaret","startLine","endLine","nextValue","map","line","i","join","startLineText","updatedSelection","hasSelection","textBeforeCaret","endsWith","matches","indent","chars","metaKey","ctrlKey","altKey","setState","_handleChange","history","session","style","highlight","textareaId","autoFocus","disabled","form","maxLength","minLength","name","placeholder","readOnly","required","onClick","onFocus","onBlur","onKeyUp","rest","contentStyle","paddingTop","paddingRight","paddingBottom","paddingLeft","highlighted","styles","container","c","editor","textarea","dangerouslySetInnerHTML","__html","children","textAlign","boxSizing","overflow","top","left","height","width","resize","color","MozOsxFontSmoothing","WebkitFontSmoothing","WebkitTextFillColor","pointerEvents","margin","border","background","display","fontFamily","fontSize","fontStyle","fontVariantLigatures","fontWeight","letterSpacing","lineHeight","textIndent","textRendering","textTransform","whiteSpace","wordBreak","overflowWrap"],"mappings":"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","sourcesContent":["/* @flow */\n/* global global */\n\nimport * as React from 'react';\n\ntype Props = React.ElementConfig<'div'> & {\n  // Props for the component\n  value: string,\n  onValueChange: (value: string) => mixed,\n  highlight: (value: string) => string | React.Node,\n  tabSize: number,\n  insertSpaces: boolean,\n  ignoreTabKey: boolean,\n  padding: number | string,\n  style?: {},\n\n  // Props for the textarea\n  textareaId?: string,\n  autoFocus?: boolean,\n  disabled?: boolean,\n  form?: string,\n  maxLength?: number,\n  minLength?: number,\n  name?: string,\n  placeholder?: string,\n  readOnly?: boolean,\n  required?: boolean,\n  onClick?: (e: MouseEvent) => mixed,\n  onFocus?: (e: FocusEvent) => mixed,\n  onBlur?: (e: FocusEvent) => mixed,\n  onKeyUp?: (e: KeyboardEvent) => mixed,\n  onKeyDown?: (e: KeyboardEvent) => mixed,\n};\n\ntype State = {\n  capture: boolean,\n};\n\ntype Record = {\n  value: string,\n  selectionStart: number,\n  selectionEnd: number,\n};\n\ntype History = {\n  stack: Array<Record & { timestamp: number }>,\n  offset: number,\n};\n\nconst KEYCODE_ENTER = 13;\nconst KEYCODE_TAB = 9;\nconst KEYCODE_BACKSPACE = 8;\nconst KEYCODE_Y = 89;\nconst KEYCODE_Z = 90;\nconst KEYCODE_M = 77;\nconst KEYCODE_PARENS = 57;\nconst KEYCODE_BRACKETS = 219;\nconst KEYCODE_QUOTE = 222;\nconst KEYCODE_BACK_QUOTE = 192;\nconst KEYCODE_ESCAPE = 27;\n\nconst HISTORY_LIMIT = 100;\nconst HISTORY_TIME_GAP = 3000;\n\nconst isWindows = 'navigator' in global && /Win/i.test(navigator.platform);\nconst isMacLike =\n  'navigator' in global && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\n\nconst className = 'npm__react-simple-code-editor__textarea';\n\nconst cssText = /* CSS */ `\n/**\n * Reset the text fill color so that placeholder is visible\n */\n.${className}:empty {\n  -webkit-text-fill-color: inherit !important;\n}\n\n/**\n * Hack to apply on some CSS on IE10 and IE11\n */\n@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) {\n  /**\n    * IE doesn't support '-webkit-text-fill-color'\n    * So we use 'color: transparent' to make the text transparent on IE\n    * Unlike other browsers, it doesn't affect caret color in IE\n    */\n  .${className} {\n    color: transparent !important;\n  }\n\n  .${className}::selection {\n    background-color: #accef7 !important;\n    color: transparent !important;\n  }\n}\n`;\n\nexport default class Editor extends React.Component<Props, State> {\n  static defaultProps = {\n    tabSize: 2,\n    insertSpaces: true,\n    ignoreTabKey: false,\n    padding: 0,\n  };\n\n  state = {\n    capture: true,\n  };\n\n  componentDidMount() {\n    this._recordCurrentState();\n  }\n\n  _recordCurrentState = () => {\n    const input = this._input;\n\n    if (!input) return;\n\n    // Save current state of the input\n    const { value, selectionStart, selectionEnd } = input;\n\n    this._recordChange({\n      value,\n      selectionStart,\n      selectionEnd,\n    });\n  };\n\n  _getLines = (text: string, position: number) =>\n    text.substring(0, position).split('\\n');\n\n  _recordChange = (record: Record, overwrite?: boolean = false) => {\n    const { stack, offset } = this._history;\n\n    if (stack.length && offset > -1) {\n      // When something updates, drop the redo operations\n      this._history.stack = stack.slice(0, offset + 1);\n\n      // Limit the number of operations to 100\n      const count = this._history.stack.length;\n\n      if (count > HISTORY_LIMIT) {\n        const extras = count - HISTORY_LIMIT;\n\n        this._history.stack = stack.slice(extras, count);\n        this._history.offset = Math.max(this._history.offset - extras, 0);\n      }\n    }\n\n    const timestamp = Date.now();\n\n    if (overwrite) {\n      const last = this._history.stack[this._history.offset];\n\n      if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\n        // A previous entry exists and was in short interval\n\n        // Match the last word in the line\n        const re = /[^a-z0-9]([a-z0-9]+)$/i;\n\n        // Get the previous line\n        const previous = this._getLines(last.value, last.selectionStart)\n          .pop()\n          .match(re);\n\n        // Get the current line\n        const current = this._getLines(record.value, record.selectionStart)\n          .pop()\n          .match(re);\n\n        if (previous && current && current[1].startsWith(previous[1])) {\n          // The last word of the previous line and current line match\n          // Overwrite previous entry so that undo will remove whole word\n          this._history.stack[this._history.offset] = { ...record, timestamp };\n\n          return;\n        }\n      }\n    }\n\n    // Add the new operation to the stack\n    this._history.stack.push({ ...record, timestamp });\n    this._history.offset++;\n  };\n\n  _updateInput = (record: Record) => {\n    const input = this._input;\n\n    if (!input) return;\n\n    // Update values and selection state\n    input.value = record.value;\n    input.selectionStart = record.selectionStart;\n    input.selectionEnd = record.selectionEnd;\n\n    this.props.onValueChange(record.value);\n  };\n\n  _applyEdits = (record: Record) => {\n    // Save last selection state\n    const input = this._input;\n    const last = this._history.stack[this._history.offset];\n\n    if (last && input) {\n      this._history.stack[this._history.offset] = {\n        ...last,\n        selectionStart: input.selectionStart,\n        selectionEnd: input.selectionEnd,\n      };\n    }\n\n    // Save the changes\n    this._recordChange(record);\n    this._updateInput(record);\n  };\n\n  _undoEdit = () => {\n    const { stack, offset } = this._history;\n\n    // Get the previous edit\n    const record = stack[offset - 1];\n\n    if (record) {\n      // Apply the changes and update the offset\n      this._updateInput(record);\n      this._history.offset = Math.max(offset - 1, 0);\n    }\n  };\n\n  _redoEdit = () => {\n    const { stack, offset } = this._history;\n\n    // Get the next edit\n    const record = stack[offset + 1];\n\n    if (record) {\n      // Apply the changes and update the offset\n      this._updateInput(record);\n      this._history.offset = Math.min(offset + 1, stack.length - 1);\n    }\n  };\n\n  _handleKeyDown = (e: *) => {\n    const { tabSize, insertSpaces, ignoreTabKey, onKeyDown } = this.props;\n\n    if (onKeyDown) {\n      onKeyDown(e);\n\n      if (e.defaultPrevented) {\n        return;\n      }\n    }\n\n    if (e.keyCode === KEYCODE_ESCAPE) {\n      e.target.blur();\n    }\n\n    const { value, selectionStart, selectionEnd } = e.target;\n\n    const tabCharacter = (insertSpaces ? ' ' : '\\t').repeat(tabSize);\n\n    if (e.keyCode === KEYCODE_TAB && !ignoreTabKey && this.state.capture) {\n      // Prevent focus change\n      e.preventDefault();\n\n      if (e.shiftKey) {\n        // Unindent selected lines\n        const linesBeforeCaret = this._getLines(value, selectionStart);\n        const startLine = linesBeforeCaret.length - 1;\n        const endLine = this._getLines(value, selectionEnd).length - 1;\n        const nextValue = value\n          .split('\\n')\n          .map((line, i) => {\n            if (\n              i >= startLine &&\n              i <= endLine &&\n              line.startsWith(tabCharacter)\n            ) {\n              return line.substring(tabCharacter.length);\n            }\n\n            return line;\n          })\n          .join('\\n');\n\n        if (value !== nextValue) {\n          const startLineText = linesBeforeCaret[startLine];\n\n          this._applyEdits({\n            value: nextValue,\n            // Move the start cursor if first line in selection was modified\n            // It was modified only if it started with a tab\n            selectionStart: startLineText.startsWith(tabCharacter)\n              ? selectionStart - tabCharacter.length\n              : selectionStart,\n            // Move the end cursor by total number of characters removed\n            selectionEnd: selectionEnd - (value.length - nextValue.length),\n          });\n        }\n      } else if (selectionStart !== selectionEnd) {\n        // Indent selected lines\n        const linesBeforeCaret = this._getLines(value, selectionStart);\n        const startLine = linesBeforeCaret.length - 1;\n        const endLine = this._getLines(value, selectionEnd).length - 1;\n        const startLineText = linesBeforeCaret[startLine];\n\n        this._applyEdits({\n          value: value\n            .split('\\n')\n            .map((line, i) => {\n              if (i >= startLine && i <= endLine) {\n                return tabCharacter + line;\n              }\n\n              return line;\n            })\n            .join('\\n'),\n          // Move the start cursor by number of characters added in first line of selection\n          // Don't move it if it there was no text before cursor\n          selectionStart: /\\S/.test(startLineText)\n            ? selectionStart + tabCharacter.length\n            : selectionStart,\n          // Move the end cursor by total number of characters added\n          selectionEnd:\n            selectionEnd + tabCharacter.length * (endLine - startLine + 1),\n        });\n      } else {\n        const updatedSelection = selectionStart + tabCharacter.length;\n\n        this._applyEdits({\n          // Insert tab character at caret\n          value:\n            value.substring(0, selectionStart) +\n            tabCharacter +\n            value.substring(selectionEnd),\n          // Update caret position\n          selectionStart: updatedSelection,\n          selectionEnd: updatedSelection,\n        });\n      }\n    } else if (e.keyCode === KEYCODE_BACKSPACE) {\n      const hasSelection = selectionStart !== selectionEnd;\n      const textBeforeCaret = value.substring(0, selectionStart);\n\n      if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\n        // Prevent default delete behaviour\n        e.preventDefault();\n\n        const updatedSelection = selectionStart - tabCharacter.length;\n\n        this._applyEdits({\n          // Remove tab character at caret\n          value:\n            value.substring(0, selectionStart - tabCharacter.length) +\n            value.substring(selectionEnd),\n          // Update caret position\n          selectionStart: updatedSelection,\n          selectionEnd: updatedSelection,\n        });\n      }\n    } else if (e.keyCode === KEYCODE_ENTER) {\n      // Ignore selections\n      if (selectionStart === selectionEnd) {\n        // Get the current line\n        const line = this._getLines(value, selectionStart).pop();\n        const matches = line.match(/^\\s+/);\n\n        if (matches && matches[0]) {\n          e.preventDefault();\n\n          // Preserve indentation on inserting a new line\n          const indent = '\\n' + matches[0];\n          const updatedSelection = selectionStart + indent.length;\n\n          this._applyEdits({\n            // Insert indentation character at caret\n            value:\n              value.substring(0, selectionStart) +\n              indent +\n              value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection,\n          });\n        }\n      }\n    } else if (\n      e.keyCode === KEYCODE_PARENS ||\n      e.keyCode === KEYCODE_BRACKETS ||\n      e.keyCode === KEYCODE_QUOTE ||\n      e.keyCode === KEYCODE_BACK_QUOTE\n    ) {\n      let chars;\n\n      if (e.keyCode === KEYCODE_PARENS && e.shiftKey) {\n        chars = ['(', ')'];\n      } else if (e.keyCode === KEYCODE_BRACKETS) {\n        if (e.shiftKey) {\n          chars = ['{', '}'];\n        } else {\n          chars = ['[', ']'];\n        }\n      } else if (e.keyCode === KEYCODE_QUOTE) {\n        if (e.shiftKey) {\n          chars = ['\"', '\"'];\n        } else {\n          chars = [\"'\", \"'\"];\n        }\n      } else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) {\n        chars = ['`', '`'];\n      }\n\n      // If text is selected, wrap them in the characters\n      if (selectionStart !== selectionEnd && chars) {\n        e.preventDefault();\n\n        this._applyEdits({\n          value:\n            value.substring(0, selectionStart) +\n            chars[0] +\n            value.substring(selectionStart, selectionEnd) +\n            chars[1] +\n            value.substring(selectionEnd),\n          // Update caret position\n          selectionStart,\n          selectionEnd: selectionEnd + 2,\n        });\n      }\n    } else if (\n      (isMacLike\n        ? // Trigger undo with ⌘+Z on Mac\n          e.metaKey && e.keyCode === KEYCODE_Z\n        : // Trigger undo with Ctrl+Z on other platforms\n          e.ctrlKey && e.keyCode === KEYCODE_Z) &&\n      !e.shiftKey &&\n      !e.altKey\n    ) {\n      e.preventDefault();\n\n      this._undoEdit();\n    } else if (\n      (isMacLike\n        ? // Trigger redo with ⌘+Shift+Z on Mac\n          e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey\n        : isWindows\n          ? // Trigger redo with Ctrl+Y on Windows\n            e.ctrlKey && e.keyCode === KEYCODE_Y\n          : // Trigger redo with Ctrl+Shift+Z on other platforms\n            e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) &&\n      !e.altKey\n    ) {\n      e.preventDefault();\n\n      this._redoEdit();\n    } else if (\n      e.keyCode === KEYCODE_M &&\n      e.ctrlKey &&\n      (isMacLike ? e.shiftKey : true)\n    ) {\n      e.preventDefault();\n\n      // Toggle capturing tab key so users can focus away\n      this.setState(state => ({\n        capture: !state.capture,\n      }));\n    }\n  };\n\n  _handleChange = (e: *) => {\n    const { value, selectionStart, selectionEnd } = e.target;\n\n    this._recordChange(\n      {\n        value,\n        selectionStart,\n        selectionEnd,\n      },\n      true\n    );\n\n    this.props.onValueChange(value);\n  };\n\n  _history: History = {\n    stack: [],\n    offset: -1,\n  };\n\n  _input: ?HTMLTextAreaElement;\n\n  get session() {\n    return {\n      history: this._history,\n    };\n  }\n\n  set session(session: { history: History }) {\n    this._history = session.history;\n  }\n\n  render() {\n    const {\n      value,\n      style,\n      padding,\n      highlight,\n      textareaId,\n      autoFocus,\n      disabled,\n      form,\n      maxLength,\n      minLength,\n      name,\n      placeholder,\n      readOnly,\n      required,\n      onClick,\n      onFocus,\n      onBlur,\n      onKeyUp,\n      /* eslint-disable no-unused-vars */\n      onKeyDown,\n      onValueChange,\n      tabSize,\n      insertSpaces,\n      ignoreTabKey,\n      /* eslint-enable no-unused-vars */\n      ...rest\n    } = this.props;\n\n    const contentStyle = {\n      paddingTop: padding,\n      paddingRight: padding,\n      paddingBottom: padding,\n      paddingLeft: padding,\n    };\n\n    const highlighted = highlight(value);\n\n    return (\n      <div {...rest} style={{ ...styles.container, ...style }}>\n        <textarea\n          ref={c => (this._input = c)}\n          style={{\n            ...styles.editor,\n            ...styles.textarea,\n            ...contentStyle,\n          }}\n          className={className}\n          id={textareaId}\n          value={value}\n          onChange={this._handleChange}\n          onKeyDown={this._handleKeyDown}\n          onClick={onClick}\n          onKeyUp={onKeyUp}\n          onFocus={onFocus}\n          onBlur={onBlur}\n          disabled={disabled}\n          form={form}\n          maxLength={maxLength}\n          minLength={minLength}\n          name={name}\n          placeholder={placeholder}\n          readOnly={readOnly}\n          required={required}\n          autoFocus={autoFocus}\n          autoCapitalize=\"off\"\n          autoComplete=\"off\"\n          autoCorrect=\"off\"\n          spellCheck={false}\n          data-gramm={false}\n        />\n        <pre\n          aria-hidden=\"true\"\n          style={{ ...styles.editor, ...styles.highlight, ...contentStyle }}\n          {...(typeof highlighted === 'string'\n            ? { dangerouslySetInnerHTML: { __html: highlighted + '<br />' } }\n            : { children: highlighted })}\n        />\n        {/* eslint-disable-next-line react/no-danger */}\n        <style type=\"text/css\" dangerouslySetInnerHTML={{ __html: cssText }} />\n      </div>\n    );\n  }\n}\n\nconst styles = {\n  container: {\n    position: 'relative',\n    textAlign: 'left',\n    boxSizing: 'border-box',\n    padding: 0,\n    overflow: 'hidden',\n  },\n  textarea: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    height: '100%',\n    width: '100%',\n    resize: 'none',\n    color: 'inherit',\n    overflow: 'hidden',\n    MozOsxFontSmoothing: 'grayscale',\n    WebkitFontSmoothing: 'antialiased',\n    WebkitTextFillColor: 'transparent',\n  },\n  highlight: {\n    position: 'relative',\n    pointerEvents: 'none',\n  },\n  editor: {\n    margin: 0,\n    border: 0,\n    background: 'none',\n    boxSizing: 'inherit',\n    display: 'inherit',\n    fontFamily: 'inherit',\n    fontSize: 'inherit',\n    fontStyle: 'inherit',\n    fontVariantLigatures: 'inherit',\n    fontWeight: 'inherit',\n    letterSpacing: 'inherit',\n    lineHeight: 'inherit',\n    tabSize: 'inherit',\n    textIndent: 'inherit',\n    textRendering: 'inherit',\n    textTransform: 'inherit',\n    whiteSpace: 'pre-wrap',\n    wordBreak: 'keep-all',\n    overflowWrap: 'break-word',\n  },\n};\n"]},"metadata":{},"sourceType":"script"}