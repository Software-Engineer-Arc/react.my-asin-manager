{"ast":null,"code":"var charToInteger = {};\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nfor (var i = 0; i < chars.length; i++) {\n  charToInteger[chars.charCodeAt(i)] = i;\n}\nfunction decode(mappings) {\n  var decoded = [];\n  var line = [];\n  var segment = [0, 0, 0, 0, 0];\n  var j = 0;\n  for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n    var c = mappings.charCodeAt(i);\n    if (c === 44) {\n      // \",\"\n      segmentify(line, segment, j);\n      j = 0;\n    } else if (c === 59) {\n      // \";\"\n      segmentify(line, segment, j);\n      j = 0;\n      decoded.push(line);\n      line = [];\n      segment[0] = 0;\n    } else {\n      var integer = charToInteger[c];\n      if (integer === undefined) {\n        throw new Error('Invalid character (' + String.fromCharCode(c) + ')');\n      }\n      var hasContinuationBit = integer & 32;\n      integer &= 31;\n      value += integer << shift;\n      if (hasContinuationBit) {\n        shift += 5;\n      } else {\n        var shouldNegate = value & 1;\n        value >>>= 1;\n        if (shouldNegate) {\n          value = value === 0 ? -0x80000000 : -value;\n        }\n        segment[j] += value;\n        j++;\n        value = shift = 0; // reset\n      }\n    }\n  }\n\n  segmentify(line, segment, j);\n  decoded.push(line);\n  return decoded;\n}\nfunction segmentify(line, segment, j) {\n  // This looks ugly, but we're creating specialized arrays with a specific\n  // length. This is much faster than creating a new array (which v8 expands to\n  // a capacity of 17 after pushing the first item), or slicing out a subarray\n  // (which is slow). Length 4 is assumed to be the most frequent, followed by\n  // length 5 (since not everything will have an associated name), followed by\n  // length 1 (it's probably rare for a source substring to not have an\n  // associated segment data).\n  if (j === 4) line.push([segment[0], segment[1], segment[2], segment[3]]);else if (j === 5) line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);else if (j === 1) line.push([segment[0]]);\n}\nfunction encode(decoded) {\n  var sourceFileIndex = 0; // second field\n  var sourceCodeLine = 0; // third field\n  var sourceCodeColumn = 0; // fourth field\n  var nameIndex = 0; // fifth field\n  var mappings = '';\n  for (var i = 0; i < decoded.length; i++) {\n    var line = decoded[i];\n    if (i > 0) mappings += ';';\n    if (line.length === 0) continue;\n    var generatedCodeColumn = 0; // first field\n    var lineMappings = [];\n    for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {\n      var segment = line_1[_i];\n      var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n      generatedCodeColumn = segment[0];\n      if (segment.length > 1) {\n        segmentMappings += encodeInteger(segment[1] - sourceFileIndex) + encodeInteger(segment[2] - sourceCodeLine) + encodeInteger(segment[3] - sourceCodeColumn);\n        sourceFileIndex = segment[1];\n        sourceCodeLine = segment[2];\n        sourceCodeColumn = segment[3];\n      }\n      if (segment.length === 5) {\n        segmentMappings += encodeInteger(segment[4] - nameIndex);\n        nameIndex = segment[4];\n      }\n      lineMappings.push(segmentMappings);\n    }\n    mappings += lineMappings.join(',');\n  }\n  return mappings;\n}\nfunction encodeInteger(num) {\n  var result = '';\n  num = num < 0 ? -num << 1 | 1 : num << 1;\n  do {\n    var clamped = num & 31;\n    num >>>= 5;\n    if (num > 0) {\n      clamped |= 32;\n    }\n    result += chars[clamped];\n  } while (num > 0);\n  return result;\n}\nexport { decode, encode };","map":{"version":3,"sources":["../src/sourcemap-codec.ts"],"names":[],"mappings":"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","sourcesContent":["export type SourceMapSegment =\n\t| [number]\n\t| [number, number, number, number]\n\t| [number, number, number, number, number];\nexport type SourceMapLine = SourceMapSegment[];\nexport type SourceMapMappings = SourceMapLine[];\n\nconst charToInteger: { [charCode: number]: number } = {};\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfor (let i = 0; i < chars.length; i++) {\n\tcharToInteger[chars.charCodeAt(i)] = i;\n}\n\nexport function decode(mappings: string): SourceMapMappings {\n\tconst decoded: SourceMapMappings = [];\n\tlet line: SourceMapLine = [];\n\tconst segment: SourceMapSegment = [\n\t\t0, // generated code column\n\t\t0, // source file index\n\t\t0, // source code line\n\t\t0, // source code column\n\t\t0, // name index\n\t];\n\n\tlet j = 0;\n\tfor (let i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n\t\tconst c = mappings.charCodeAt(i);\n\n\t\tif (c === 44) { // \",\"\n\t\t\tsegmentify(line, segment, j);\n\t\t\tj = 0;\n\n\t\t} else if (c === 59) { // \";\"\n\t\t\tsegmentify(line, segment, j);\n\t\t\tj = 0;\n\t\t\tdecoded.push(line);\n\t\t\tline = [];\n\t\t\tsegment[0] = 0;\n\n\t\t} else {\n\t\t\tlet integer = charToInteger[c];\n\t\t\tif (integer === undefined) {\n\t\t\t\tthrow new Error('Invalid character (' + String.fromCharCode(c) + ')');\n\t\t\t}\n\n\t\t\tconst hasContinuationBit = integer & 32;\n\n\t\t\tinteger &= 31;\n\t\t\tvalue += integer << shift;\n\n\t\t\tif (hasContinuationBit) {\n\t\t\t\tshift += 5;\n\t\t\t} else {\n\t\t\t\tconst shouldNegate = value & 1;\n\t\t\t\tvalue >>>= 1;\n\n\t\t\t\tif (shouldNegate) {\n\t\t\t\t\tvalue = value === 0 ? -0x80000000 : -value;\n\t\t\t\t}\n\n\t\t\t\tsegment[j] += value;\n\t\t\t\tj++;\n\t\t\t\tvalue = shift = 0; // reset\n\t\t\t}\n\t\t}\n\t}\n\n\tsegmentify(line, segment, j);\n\tdecoded.push(line);\n\n\treturn decoded;\n}\n\nfunction segmentify(line: SourceMapSegment[], segment: SourceMapSegment, j: number) {\n\t// This looks ugly, but we're creating specialized arrays with a specific\n\t// length. This is much faster than creating a new array (which v8 expands to\n\t// a capacity of 17 after pushing the first item), or slicing out a subarray\n\t// (which is slow). Length 4 is assumed to be the most frequent, followed by\n\t// length 5 (since not everything will have an associated name), followed by\n\t// length 1 (it's probably rare for a source substring to not have an\n\t// associated segment data).\n\tif (j === 4) line.push([segment[0], segment[1], segment[2], segment[3]]);\n\telse if (j === 5) line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);\n\telse if (j === 1) line.push([segment[0]]);\n}\n\nexport function encode(decoded: SourceMapMappings): string {\n\tlet sourceFileIndex = 0;  // second field\n\tlet sourceCodeLine = 0;   // third field\n\tlet sourceCodeColumn = 0; // fourth field\n\tlet nameIndex = 0;        // fifth field\n\tlet mappings = '';\n\n\tfor (let i = 0; i < decoded.length; i++) {\n\t\tconst line = decoded[i];\n\t\tif (i > 0) mappings += ';';\n\t\tif (line.length === 0) continue;\n\n\t\tlet generatedCodeColumn = 0; // first field\n\n\t\tconst lineMappings: string[] = [];\n\n\t\tfor (const segment of line) {\n\t\t\tlet segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n\t\t\tgeneratedCodeColumn = segment[0];\n\n\t\t\tif (segment.length > 1) {\n\t\t\t\tsegmentMappings +=\n\t\t\t\t\tencodeInteger(segment[1] - sourceFileIndex) +\n\t\t\t\t\tencodeInteger(segment[2] - sourceCodeLine) +\n\t\t\t\t\tencodeInteger(segment[3] - sourceCodeColumn);\n\n\t\t\t\tsourceFileIndex = segment[1];\n\t\t\t\tsourceCodeLine = segment[2];\n\t\t\t\tsourceCodeColumn = segment[3];\n\t\t\t}\n\n\t\t\tif (segment.length === 5) {\n\t\t\t\tsegmentMappings += encodeInteger(segment[4] - nameIndex);\n\t\t\t\tnameIndex = segment[4];\n\t\t\t}\n\n\t\t\tlineMappings.push(segmentMappings);\n\t\t}\n\n\t\tmappings += lineMappings.join(',');\n\t}\n\n\treturn mappings;\n}\n\nfunction encodeInteger(num: number): string {\n\tvar result = '';\n\tnum = num < 0 ? (-num << 1) | 1 : num << 1;\n\tdo {\n\t\tvar clamped = num & 31;\n\t\tnum >>>= 5;\n\t\tif (num > 0) {\n\t\t\tclamped |= 32;\n\t\t}\n\t\tresult += chars[clamped];\n\t} while (num > 0);\n\n\treturn result;\n}\n"]},"metadata":{},"sourceType":"module"}