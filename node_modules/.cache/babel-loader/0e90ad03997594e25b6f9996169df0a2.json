{"ast":null,"code":"'use strict';\n\nconst generate = require('regjsgen').generate;\nconst parse = require('regjsparser').parse;\nconst regenerate = require('regenerate');\nconst unicodeMatchProperty = require('unicode-match-property-ecmascript');\nconst unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');\nconst iuMappings = require('./data/iu-mappings.js');\nconst ESCAPE_SETS = require('./data/character-class-escape-sets.js');\n\n// Prepare a Regenerate set containing all code points, used for negative\n// character classes (if any).\nconst UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);\n// Without the `u` flag, the range stops at 0xFFFF.\n// https://mths.be/es6#sec-pattern-semantics\nconst BMP_SET = regenerate().addRange(0x0, 0xFFFF);\n\n// Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./u`. https://mths.be/es6#sec-atom\nconst DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\n.remove(\n// minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\n0x000A,\n// Line Feed <LF>\n0x000D,\n// Carriage Return <CR>\n0x2028,\n// Line Separator <LS>\n0x2029 // Paragraph Separator <PS>\n);\n\nconst getCharacterClassEscapeSet = (character, unicode, ignoreCase) => {\n  if (unicode) {\n    if (ignoreCase) {\n      return ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);\n    }\n    return ESCAPE_SETS.UNICODE.get(character);\n  }\n  return ESCAPE_SETS.REGULAR.get(character);\n};\nconst getUnicodeDotSet = dotAll => {\n  return dotAll ? UNICODE_SET : DOT_SET_UNICODE;\n};\nconst getUnicodePropertyValueSet = (property, value) => {\n  const path = value ? `${property}/${value}` : `Binary_Property/${property}`;\n  try {\n    return require(`regenerate-unicode-properties/${path}.js`);\n  } catch (exception) {\n    throw new Error(`Failed to recognize value \\`${value}\\` for property ` + `\\`${property}\\`.`);\n  }\n};\nconst handleLoneUnicodePropertyNameOrValue = value => {\n  // It could be a `General_Category` value or a binary property.\n  // Note: `unicodeMatchPropertyValue` throws on invalid values.\n  try {\n    const property = 'General_Category';\n    const category = unicodeMatchPropertyValue(property, value);\n    return getUnicodePropertyValueSet(property, category);\n  } catch (exception) {}\n  // It’s not a `General_Category` value, so check if it’s a binary\n  // property. Note: `unicodeMatchProperty` throws on invalid properties.\n  const property = unicodeMatchProperty(value);\n  return getUnicodePropertyValueSet(property);\n};\nconst getUnicodePropertyEscapeSet = (value, isNegative) => {\n  const parts = value.split('=');\n  const firstPart = parts[0];\n  let set;\n  if (parts.length == 1) {\n    set = handleLoneUnicodePropertyNameOrValue(firstPart);\n  } else {\n    // The pattern consists of two parts, i.e. `Property=Value`.\n    const property = unicodeMatchProperty(firstPart);\n    const value = unicodeMatchPropertyValue(property, parts[1]);\n    set = getUnicodePropertyValueSet(property, value);\n  }\n  if (isNegative) {\n    return UNICODE_SET.clone().remove(set);\n  }\n  return set.clone();\n};\n\n// Given a range of code points, add any case-folded code points in that range\n// to a set.\nregenerate.prototype.iuAddRange = function (min, max) {\n  const $this = this;\n  do {\n    const folded = caseFold(min);\n    if (folded) {\n      $this.add(folded);\n    }\n  } while (++min <= max);\n  return $this;\n};\nconst update = (item, pattern) => {\n  let tree = parse(pattern, config.useUnicodeFlag ? 'u' : '');\n  switch (tree.type) {\n    case 'characterClass':\n    case 'group':\n    case 'value':\n      // No wrapping needed.\n      break;\n    default:\n      // Wrap the pattern in a non-capturing group.\n      tree = wrap(tree, pattern);\n  }\n  Object.assign(item, tree);\n};\nconst wrap = (tree, pattern) => {\n  // Wrap the pattern in a non-capturing group.\n  return {\n    'type': 'group',\n    'behavior': 'ignore',\n    'body': [tree],\n    'raw': `(?:${pattern})`\n  };\n};\nconst caseFold = codePoint => {\n  return iuMappings.get(codePoint) || false;\n};\nconst processCharacterClass = (characterClassItem, regenerateOptions) => {\n  const set = regenerate();\n  for (const item of characterClassItem.body) {\n    switch (item.type) {\n      case 'value':\n        set.add(item.codePoint);\n        if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n          const folded = caseFold(item.codePoint);\n          if (folded) {\n            set.add(folded);\n          }\n        }\n        break;\n      case 'characterClassRange':\n        const min = item.min.codePoint;\n        const max = item.max.codePoint;\n        set.addRange(min, max);\n        if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n          set.iuAddRange(min, max);\n        }\n        break;\n      case 'characterClassEscape':\n        set.add(getCharacterClassEscapeSet(item.value, config.unicode, config.ignoreCase));\n        break;\n      case 'unicodePropertyEscape':\n        set.add(getUnicodePropertyEscapeSet(item.value, item.negative));\n        break;\n      // The `default` clause is only here as a safeguard; it should never be\n      // reached. Code coverage tools should ignore it.\n      /* istanbul ignore next */\n      default:\n        throw new Error(`Unknown term type: ${item.type}`);\n    }\n  }\n  if (characterClassItem.negative) {\n    update(characterClassItem, `(?!${set.toString(regenerateOptions)})[\\\\s\\\\S]`);\n  } else {\n    update(characterClassItem, set.toString(regenerateOptions));\n  }\n  return characterClassItem;\n};\nconst updateNamedReference = (item, index) => {\n  delete item.name;\n  item.matchIndex = index;\n};\nconst assertNoUnmatchedReferences = groups => {\n  const unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);\n  if (unmatchedReferencesNames.length > 0) {\n    throw new Error(`Unknown group names: ${unmatchedReferencesNames}`);\n  }\n};\nconst processTerm = (item, regenerateOptions, groups) => {\n  switch (item.type) {\n    case 'dot':\n      if (config.useDotAllFlag) {\n        break;\n      } else if (config.unicode) {\n        update(item, getUnicodeDotSet(config.dotAll).toString(regenerateOptions));\n      } else if (config.dotAll) {\n        // TODO: consider changing this at the regenerate level.\n        update(item, '[\\\\s\\\\S]');\n      }\n      break;\n    case 'characterClass':\n      item = processCharacterClass(item, regenerateOptions);\n      break;\n    case 'unicodePropertyEscape':\n      if (config.unicodePropertyEscape) {\n        update(item, getUnicodePropertyEscapeSet(item.value, item.negative).toString(regenerateOptions));\n      }\n      break;\n    case 'characterClassEscape':\n      update(item, getCharacterClassEscapeSet(item.value, config.unicode, config.ignoreCase).toString(regenerateOptions));\n      break;\n    case 'group':\n      if (item.behavior == 'normal') {\n        groups.lastIndex++;\n      }\n      if (item.name && config.namedGroup) {\n        const name = item.name.value;\n        if (groups.names[name]) {\n          throw new Error(`Multiple groups with the same name (${name}) are not allowed.`);\n        }\n        const index = groups.lastIndex;\n        delete item.name;\n        groups.names[name] = index;\n        if (groups.onNamedGroup) {\n          groups.onNamedGroup.call(null, name, index);\n        }\n        if (groups.unmatchedReferences[name]) {\n          groups.unmatchedReferences[name].forEach(reference => {\n            updateNamedReference(reference, index);\n          });\n          delete groups.unmatchedReferences[name];\n        }\n      }\n    /* falls through */\n    case 'alternative':\n    case 'disjunction':\n    case 'quantifier':\n      item.body = item.body.map(term => {\n        return processTerm(term, regenerateOptions, groups);\n      });\n      break;\n    case 'value':\n      const codePoint = item.codePoint;\n      const set = regenerate(codePoint);\n      if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n        const folded = caseFold(codePoint);\n        if (folded) {\n          set.add(folded);\n        }\n      }\n      update(item, set.toString(regenerateOptions));\n      break;\n    case 'reference':\n      if (item.name) {\n        const name = item.name.value;\n        const index = groups.names[name];\n        if (index) {\n          updateNamedReference(item, index);\n          break;\n        }\n        if (!groups.unmatchedReferences[name]) {\n          groups.unmatchedReferences[name] = [];\n        }\n        // Keep track of references used before the corresponding group.\n        groups.unmatchedReferences[name].push(item);\n      }\n      break;\n    case 'anchor':\n    case 'empty':\n    case 'group':\n      // Nothing to do here.\n      break;\n    // The `default` clause is only here as a safeguard; it should never be\n    // reached. Code coverage tools should ignore it.\n    /* istanbul ignore next */\n    default:\n      throw new Error(`Unknown term type: ${item.type}`);\n  }\n  return item;\n};\nconst config = {\n  'ignoreCase': false,\n  'unicode': false,\n  'dotAll': false,\n  'useDotAllFlag': false,\n  'useUnicodeFlag': false,\n  'unicodePropertyEscape': false,\n  'namedGroup': false\n};\nconst rewritePattern = (pattern, flags, options) => {\n  config.unicode = flags && flags.includes('u');\n  const regjsparserFeatures = {\n    'unicodePropertyEscape': config.unicode,\n    'namedGroups': true,\n    'lookbehind': options && options.lookbehind\n  };\n  config.ignoreCase = flags && flags.includes('i');\n  const supportDotAllFlag = options && options.dotAllFlag;\n  config.dotAll = supportDotAllFlag && flags && flags.includes('s');\n  config.namedGroup = options && options.namedGroup;\n  config.useDotAllFlag = options && options.useDotAllFlag;\n  config.useUnicodeFlag = options && options.useUnicodeFlag;\n  config.unicodePropertyEscape = options && options.unicodePropertyEscape;\n  if (supportDotAllFlag && config.useDotAllFlag) {\n    throw new Error('`useDotAllFlag` and `dotAllFlag` cannot both be true!');\n  }\n  const regenerateOptions = {\n    'hasUnicodeFlag': config.useUnicodeFlag,\n    'bmpOnly': !config.unicode\n  };\n  const groups = {\n    'onNamedGroup': options && options.onNamedGroup,\n    'lastIndex': 0,\n    'names': Object.create(null),\n    // { [name]: index }\n    'unmatchedReferences': Object.create(null) // { [name]: Array<reference> }\n  };\n\n  const tree = parse(pattern, flags, regjsparserFeatures);\n  // Note: `processTerm` mutates `tree` and `groups`.\n  processTerm(tree, regenerateOptions, groups);\n  assertNoUnmatchedReferences(groups);\n  return generate(tree);\n};\nmodule.exports = rewritePattern;","map":{"version":3,"names":["generate","require","parse","regenerate","unicodeMatchProperty","unicodeMatchPropertyValue","iuMappings","ESCAPE_SETS","UNICODE_SET","addRange","BMP_SET","DOT_SET_UNICODE","clone","remove","getCharacterClassEscapeSet","character","unicode","ignoreCase","UNICODE_IGNORE_CASE","get","UNICODE","REGULAR","getUnicodeDotSet","dotAll","getUnicodePropertyValueSet","property","value","path","exception","Error","handleLoneUnicodePropertyNameOrValue","category","getUnicodePropertyEscapeSet","isNegative","parts","split","firstPart","set","length","prototype","iuAddRange","min","max","$this","folded","caseFold","add","update","item","pattern","tree","config","useUnicodeFlag","type","wrap","Object","assign","codePoint","processCharacterClass","characterClassItem","regenerateOptions","body","negative","toString","updateNamedReference","index","name","matchIndex","assertNoUnmatchedReferences","groups","unmatchedReferencesNames","keys","unmatchedReferences","processTerm","useDotAllFlag","unicodePropertyEscape","behavior","lastIndex","namedGroup","names","onNamedGroup","call","forEach","reference","map","term","push","rewritePattern","flags","options","includes","regjsparserFeatures","lookbehind","supportDotAllFlag","dotAllFlag","create","module","exports"],"sources":["/Users/arturo.velazquez/Documents/GIT/SWE/TEMPLATES/react.my-asin-manager/node_modules/regexpu-core/rewrite-pattern.js"],"sourcesContent":["'use strict';\n\nconst generate = require('regjsgen').generate;\nconst parse = require('regjsparser').parse;\nconst regenerate = require('regenerate');\nconst unicodeMatchProperty = require('unicode-match-property-ecmascript');\nconst unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');\nconst iuMappings = require('./data/iu-mappings.js');\nconst ESCAPE_SETS = require('./data/character-class-escape-sets.js');\n\n// Prepare a Regenerate set containing all code points, used for negative\n// character classes (if any).\nconst UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);\n// Without the `u` flag, the range stops at 0xFFFF.\n// https://mths.be/es6#sec-pattern-semantics\nconst BMP_SET = regenerate().addRange(0x0, 0xFFFF);\n\n// Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./u`. https://mths.be/es6#sec-atom\nconst DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\n\t.remove(\n\t\t// minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\n\t\t0x000A, // Line Feed <LF>\n\t\t0x000D, // Carriage Return <CR>\n\t\t0x2028, // Line Separator <LS>\n\t\t0x2029  // Paragraph Separator <PS>\n\t);\n\nconst getCharacterClassEscapeSet = (character, unicode, ignoreCase) => {\n\tif (unicode) {\n\t\tif (ignoreCase) {\n\t\t\treturn ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);\n\t\t}\n\t\treturn ESCAPE_SETS.UNICODE.get(character);\n\t}\n\treturn ESCAPE_SETS.REGULAR.get(character);\n};\n\nconst getUnicodeDotSet = (dotAll) => {\n\treturn dotAll ? UNICODE_SET : DOT_SET_UNICODE;\n};\n\nconst getUnicodePropertyValueSet = (property, value) => {\n\tconst path = value ?\n\t\t`${ property }/${ value }` :\n\t\t`Binary_Property/${ property }`;\n\ttry {\n\t\treturn require(`regenerate-unicode-properties/${ path }.js`);\n\t} catch (exception) {\n\t\tthrow new Error(\n\t\t\t`Failed to recognize value \\`${ value }\\` for property ` +\n\t\t\t`\\`${ property }\\`.`\n\t\t);\n\t}\n};\n\nconst handleLoneUnicodePropertyNameOrValue = (value) => {\n\t// It could be a `General_Category` value or a binary property.\n\t// Note: `unicodeMatchPropertyValue` throws on invalid values.\n\ttry {\n\t\tconst property = 'General_Category';\n\t\tconst category = unicodeMatchPropertyValue(property, value);\n\t\treturn getUnicodePropertyValueSet(property, category);\n\t} catch (exception) {}\n\t// It’s not a `General_Category` value, so check if it’s a binary\n\t// property. Note: `unicodeMatchProperty` throws on invalid properties.\n\tconst property = unicodeMatchProperty(value);\n\treturn getUnicodePropertyValueSet(property);\n};\n\nconst getUnicodePropertyEscapeSet = (value, isNegative) => {\n\tconst parts = value.split('=');\n\tconst firstPart = parts[0];\n\tlet set;\n\tif (parts.length == 1) {\n\t\tset = handleLoneUnicodePropertyNameOrValue(firstPart);\n\t} else {\n\t\t// The pattern consists of two parts, i.e. `Property=Value`.\n\t\tconst property = unicodeMatchProperty(firstPart);\n\t\tconst value = unicodeMatchPropertyValue(property, parts[1]);\n\t\tset = getUnicodePropertyValueSet(property, value);\n\t}\n\tif (isNegative) {\n\t\treturn UNICODE_SET.clone().remove(set);\n\t}\n\treturn set.clone();\n};\n\n// Given a range of code points, add any case-folded code points in that range\n// to a set.\nregenerate.prototype.iuAddRange = function(min, max) {\n\tconst $this = this;\n\tdo {\n\t\tconst folded = caseFold(min);\n\t\tif (folded) {\n\t\t\t$this.add(folded);\n\t\t}\n\t} while (++min <= max);\n\treturn $this;\n};\n\nconst update = (item, pattern) => {\n\tlet tree = parse(pattern, config.useUnicodeFlag ? 'u' : '');\n\tswitch (tree.type) {\n\t\tcase 'characterClass':\n\t\tcase 'group':\n\t\tcase 'value':\n\t\t\t// No wrapping needed.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Wrap the pattern in a non-capturing group.\n\t\t\ttree = wrap(tree, pattern);\n\t}\n\tObject.assign(item, tree);\n};\n\nconst wrap = (tree, pattern) => {\n\t// Wrap the pattern in a non-capturing group.\n\treturn {\n\t\t'type': 'group',\n\t\t'behavior': 'ignore',\n\t\t'body': [tree],\n\t\t'raw': `(?:${ pattern })`\n\t};\n};\n\nconst caseFold = (codePoint) => {\n\treturn iuMappings.get(codePoint) || false;\n};\n\nconst processCharacterClass = (characterClassItem, regenerateOptions) => {\n\tconst set = regenerate();\n\tfor (const item of characterClassItem.body) {\n\t\tswitch (item.type) {\n\t\t\tcase 'value':\n\t\t\t\tset.add(item.codePoint);\n\t\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n\t\t\t\t\tconst folded = caseFold(item.codePoint);\n\t\t\t\t\tif (folded) {\n\t\t\t\t\t\tset.add(folded);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassRange':\n\t\t\t\tconst min = item.min.codePoint;\n\t\t\t\tconst max = item.max.codePoint;\n\t\t\t\tset.addRange(min, max);\n\t\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n\t\t\t\t\tset.iuAddRange(min, max);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassEscape':\n\t\t\t\tset.add(getCharacterClassEscapeSet(\n\t\t\t\t\titem.value,\n\t\t\t\t\tconfig.unicode,\n\t\t\t\t\tconfig.ignoreCase\n\t\t\t\t));\n\t\t\t\tbreak;\n\t\t\tcase 'unicodePropertyEscape':\n\t\t\t\tset.add(getUnicodePropertyEscapeSet(item.value, item.negative));\n\t\t\t\tbreak;\n\t\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t\t// reached. Code coverage tools should ignore it.\n\t\t\t/* istanbul ignore next */\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\n\t\t}\n\t}\n\tif (characterClassItem.negative) {\n\t\tupdate(characterClassItem, `(?!${set.toString(regenerateOptions)})[\\\\s\\\\S]`)\n\t} else {\n\t\tupdate(characterClassItem, set.toString(regenerateOptions));\n\t}\n\treturn characterClassItem;\n};\n\nconst updateNamedReference = (item, index) => {\n\tdelete item.name;\n\titem.matchIndex = index;\n};\n\nconst assertNoUnmatchedReferences = (groups) => {\n\tconst unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);\n\tif (unmatchedReferencesNames.length > 0) {\n\t\tthrow new Error(`Unknown group names: ${unmatchedReferencesNames}`);\n\t}\n};\n\nconst processTerm = (item, regenerateOptions, groups) => {\n\tswitch (item.type) {\n\t\tcase 'dot':\n\t\t\tif (config.useDotAllFlag) {\n\t\t\t\tbreak;\n\t\t\t} else if (config.unicode) {\n\t\t\t\tupdate(\n\t\t\t\t\titem,\n\t\t\t\t\tgetUnicodeDotSet(config.dotAll).toString(regenerateOptions)\n\t\t\t\t);\n\t\t\t} else if (config.dotAll) {\n\t\t\t\t// TODO: consider changing this at the regenerate level.\n\t\t\t\tupdate(item, '[\\\\s\\\\S]');\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'characterClass':\n\t\t\titem = processCharacterClass(item, regenerateOptions);\n\t\t\tbreak;\n\t\tcase 'unicodePropertyEscape':\n\t\t\tif (config.unicodePropertyEscape) {\n\t\t\t\tupdate(\n\t\t\t\t\titem,\n\t\t\t\t\tgetUnicodePropertyEscapeSet(item.value, item.negative)\n\t\t\t\t\t\t.toString(regenerateOptions)\n\t\t\t\t);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'characterClassEscape':\n\t\t\tupdate(\n\t\t\t\titem,\n\t\t\t\tgetCharacterClassEscapeSet(\n\t\t\t\t\titem.value,\n\t\t\t\t\tconfig.unicode,\n\t\t\t\t\tconfig.ignoreCase\n\t\t\t\t).toString(regenerateOptions)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 'group':\n\t\t\tif (item.behavior == 'normal') {\n\t\t\t\tgroups.lastIndex++;\n\t\t\t}\n\t\t\tif (item.name && config.namedGroup) {\n\t\t\t\tconst name = item.name.value;\n\n\t\t\t\tif (groups.names[name]) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Multiple groups with the same name (${ name }) are not allowed.`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst index = groups.lastIndex;\n\t\t\t\tdelete item.name;\n\n\t\t\t\tgroups.names[name] = index;\n\t\t\t\tif (groups.onNamedGroup) {\n\t\t\t\t\tgroups.onNamedGroup.call(null, name, index);\n\t\t\t\t}\n\n\t\t\t\tif (groups.unmatchedReferences[name]) {\n\t\t\t\t\tgroups.unmatchedReferences[name].forEach(reference => {\n\t\t\t\t\t\tupdateNamedReference(reference, index);\n\t\t\t\t\t});\n\t\t\t\t\tdelete groups.unmatchedReferences[name];\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* falls through */\n\t\tcase 'alternative':\n\t\tcase 'disjunction':\n\t\tcase 'quantifier':\n\t\t\titem.body = item.body.map(term => {\n\t\t\t\treturn processTerm(term, regenerateOptions, groups);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'value':\n\t\t\tconst codePoint = item.codePoint;\n\t\t\tconst set = regenerate(codePoint);\n\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n\t\t\t\tconst folded = caseFold(codePoint);\n\t\t\t\tif (folded) {\n\t\t\t\t\tset.add(folded);\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdate(item, set.toString(regenerateOptions));\n\t\t\tbreak;\n\t\tcase 'reference':\n\t\t\tif (item.name) {\n\t\t\t\tconst name = item.name.value;\n\t\t\t\tconst index = groups.names[name];\n\t\t\t\tif (index) {\n\t\t\t\t\tupdateNamedReference(item, index);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!groups.unmatchedReferences[name]) {\n\t\t\t\t\tgroups.unmatchedReferences[name] = [];\n\t\t\t\t}\n\t\t\t\t// Keep track of references used before the corresponding group.\n\t\t\t\tgroups.unmatchedReferences[name].push(item);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'anchor':\n\t\tcase 'empty':\n\t\tcase 'group':\n\t\t\t// Nothing to do here.\n\t\t\tbreak;\n\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t// reached. Code coverage tools should ignore it.\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\n\t}\n\treturn item;\n};\n\nconst config = {\n\t'ignoreCase': false,\n\t'unicode': false,\n\t'dotAll': false,\n\t'useDotAllFlag': false,\n\t'useUnicodeFlag': false,\n\t'unicodePropertyEscape': false,\n\t'namedGroup': false\n};\nconst rewritePattern = (pattern, flags, options) => {\n\tconfig.unicode = flags && flags.includes('u');\n\tconst regjsparserFeatures = {\n\t\t'unicodePropertyEscape': config.unicode,\n\t\t'namedGroups': true,\n\t\t'lookbehind': options && options.lookbehind\n\t};\n\tconfig.ignoreCase = flags && flags.includes('i');\n\tconst supportDotAllFlag = options && options.dotAllFlag;\n\tconfig.dotAll = supportDotAllFlag && flags && flags.includes('s');\n\tconfig.namedGroup = options && options.namedGroup;\n\tconfig.useDotAllFlag = options && options.useDotAllFlag;\n\tconfig.useUnicodeFlag = options && options.useUnicodeFlag;\n\tconfig.unicodePropertyEscape = options && options.unicodePropertyEscape;\n\tif (supportDotAllFlag && config.useDotAllFlag) {\n\t\tthrow new Error('`useDotAllFlag` and `dotAllFlag` cannot both be true!');\n\t}\n\tconst regenerateOptions = {\n\t\t'hasUnicodeFlag': config.useUnicodeFlag,\n\t\t'bmpOnly': !config.unicode\n\t};\n\tconst groups = {\n\t\t'onNamedGroup': options && options.onNamedGroup,\n\t\t'lastIndex': 0,\n\t\t'names': Object.create(null), // { [name]: index }\n\t\t'unmatchedReferences': Object.create(null) // { [name]: Array<reference> }\n\t};\n\tconst tree = parse(pattern, flags, regjsparserFeatures);\n\t// Note: `processTerm` mutates `tree` and `groups`.\n\tprocessTerm(tree, regenerateOptions, groups);\n\tassertNoUnmatchedReferences(groups);\n\treturn generate(tree);\n};\n\nmodule.exports = rewritePattern;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}