{"ast":null,"code":"import { encode } from 'sourcemap-codec';\nvar BitSet = function BitSet(arg) {\n  this.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n};\nBitSet.prototype.add = function add(n) {\n  this.bits[n >> 5] |= 1 << (n & 31);\n};\nBitSet.prototype.has = function has(n) {\n  return !!(this.bits[n >> 5] & 1 << (n & 31));\n};\nvar Chunk = function Chunk(start, end, content) {\n  this.start = start;\n  this.end = end;\n  this.original = content;\n  this.intro = '';\n  this.outro = '';\n  this.content = content;\n  this.storeName = false;\n  this.edited = false;\n\n  // we make these non-enumerable, for sanity while debugging\n  Object.defineProperties(this, {\n    previous: {\n      writable: true,\n      value: null\n    },\n    next: {\n      writable: true,\n      value: null\n    }\n  });\n};\nChunk.prototype.appendLeft = function appendLeft(content) {\n  this.outro += content;\n};\nChunk.prototype.appendRight = function appendRight(content) {\n  this.intro = this.intro + content;\n};\nChunk.prototype.clone = function clone() {\n  var chunk = new Chunk(this.start, this.end, this.original);\n  chunk.intro = this.intro;\n  chunk.outro = this.outro;\n  chunk.content = this.content;\n  chunk.storeName = this.storeName;\n  chunk.edited = this.edited;\n  return chunk;\n};\nChunk.prototype.contains = function contains(index) {\n  return this.start < index && index < this.end;\n};\nChunk.prototype.eachNext = function eachNext(fn) {\n  var chunk = this;\n  while (chunk) {\n    fn(chunk);\n    chunk = chunk.next;\n  }\n};\nChunk.prototype.eachPrevious = function eachPrevious(fn) {\n  var chunk = this;\n  while (chunk) {\n    fn(chunk);\n    chunk = chunk.previous;\n  }\n};\nChunk.prototype.edit = function edit(content, storeName, contentOnly) {\n  this.content = content;\n  if (!contentOnly) {\n    this.intro = '';\n    this.outro = '';\n  }\n  this.storeName = storeName;\n  this.edited = true;\n  return this;\n};\nChunk.prototype.prependLeft = function prependLeft(content) {\n  this.outro = content + this.outro;\n};\nChunk.prototype.prependRight = function prependRight(content) {\n  this.intro = content + this.intro;\n};\nChunk.prototype.split = function split(index) {\n  var sliceIndex = index - this.start;\n  var originalBefore = this.original.slice(0, sliceIndex);\n  var originalAfter = this.original.slice(sliceIndex);\n  this.original = originalBefore;\n  var newChunk = new Chunk(index, this.end, originalAfter);\n  newChunk.outro = this.outro;\n  this.outro = '';\n  this.end = index;\n  if (this.edited) {\n    // TODO is this block necessary?...\n    newChunk.edit('', false);\n    this.content = '';\n  } else {\n    this.content = originalBefore;\n  }\n  newChunk.next = this.next;\n  if (newChunk.next) {\n    newChunk.next.previous = newChunk;\n  }\n  newChunk.previous = this;\n  this.next = newChunk;\n  return newChunk;\n};\nChunk.prototype.toString = function toString() {\n  return this.intro + this.content + this.outro;\n};\nChunk.prototype.trimEnd = function trimEnd(rx) {\n  this.outro = this.outro.replace(rx, '');\n  if (this.outro.length) {\n    return true;\n  }\n  var trimmed = this.content.replace(rx, '');\n  if (trimmed.length) {\n    if (trimmed !== this.content) {\n      this.split(this.start + trimmed.length).edit('', undefined, true);\n    }\n    return true;\n  } else {\n    this.edit('', undefined, true);\n    this.intro = this.intro.replace(rx, '');\n    if (this.intro.length) {\n      return true;\n    }\n  }\n};\nChunk.prototype.trimStart = function trimStart(rx) {\n  this.intro = this.intro.replace(rx, '');\n  if (this.intro.length) {\n    return true;\n  }\n  var trimmed = this.content.replace(rx, '');\n  if (trimmed.length) {\n    if (trimmed !== this.content) {\n      this.split(this.end - trimmed.length);\n      this.edit('', undefined, true);\n    }\n    return true;\n  } else {\n    this.edit('', undefined, true);\n    this.outro = this.outro.replace(rx, '');\n    if (this.outro.length) {\n      return true;\n    }\n  }\n};\nvar btoa = function () {\n  throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n  btoa = function (str) {\n    return window.btoa(unescape(encodeURIComponent(str)));\n  };\n} else if (typeof Buffer === 'function') {\n  btoa = function (str) {\n    return Buffer.from(str, 'utf-8').toString('base64');\n  };\n}\nvar SourceMap = function SourceMap(properties) {\n  this.version = 3;\n  this.file = properties.file;\n  this.sources = properties.sources;\n  this.sourcesContent = properties.sourcesContent;\n  this.names = properties.names;\n  this.mappings = encode(properties.mappings);\n};\nSourceMap.prototype.toString = function toString() {\n  return JSON.stringify(this);\n};\nSourceMap.prototype.toUrl = function toUrl() {\n  return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n};\nfunction guessIndent(code) {\n  var lines = code.split('\\n');\n  var tabbed = lines.filter(function (line) {\n    return /^\\t+/.test(line);\n  });\n  var spaced = lines.filter(function (line) {\n    return /^ {2,}/.test(line);\n  });\n  if (tabbed.length === 0 && spaced.length === 0) {\n    return null;\n  }\n\n  // More lines tabbed than spaced? Assume tabs, and\n  // default to tabs in the case of a tie (or nothing\n  // to go on)\n  if (tabbed.length >= spaced.length) {\n    return '\\t';\n  }\n\n  // Otherwise, we need to guess the multiple\n  var min = spaced.reduce(function (previous, current) {\n    var numSpaces = /^ +/.exec(current)[0].length;\n    return Math.min(numSpaces, previous);\n  }, Infinity);\n  return new Array(min + 1).join(' ');\n}\nfunction getRelativePath(from, to) {\n  var fromParts = from.split(/[/\\\\]/);\n  var toParts = to.split(/[/\\\\]/);\n  fromParts.pop(); // get dirname\n\n  while (fromParts[0] === toParts[0]) {\n    fromParts.shift();\n    toParts.shift();\n  }\n  if (fromParts.length) {\n    var i = fromParts.length;\n    while (i--) {\n      fromParts[i] = '..';\n    }\n  }\n  return fromParts.concat(toParts).join('/');\n}\nvar toString = Object.prototype.toString;\nfunction isObject(thing) {\n  return toString.call(thing) === '[object Object]';\n}\nfunction getLocator(source) {\n  var originalLines = source.split('\\n');\n  var lineOffsets = [];\n  for (var i = 0, pos = 0; i < originalLines.length; i++) {\n    lineOffsets.push(pos);\n    pos += originalLines[i].length + 1;\n  }\n  return function locate(index) {\n    var i = 0;\n    var j = lineOffsets.length;\n    while (i < j) {\n      var m = i + j >> 1;\n      if (index < lineOffsets[m]) {\n        j = m;\n      } else {\n        i = m + 1;\n      }\n    }\n    var line = i - 1;\n    var column = index - lineOffsets[line];\n    return {\n      line: line,\n      column: column\n    };\n  };\n}\nvar Mappings = function Mappings(hires) {\n  this.hires = hires;\n  this.generatedCodeLine = 0;\n  this.generatedCodeColumn = 0;\n  this.raw = [];\n  this.rawSegments = this.raw[this.generatedCodeLine] = [];\n  this.pending = null;\n};\nMappings.prototype.addEdit = function addEdit(sourceIndex, content, loc, nameIndex) {\n  if (content.length) {\n    var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n    if (nameIndex >= 0) {\n      segment.push(nameIndex);\n    }\n    this.rawSegments.push(segment);\n  } else if (this.pending) {\n    this.rawSegments.push(this.pending);\n  }\n  this.advance(content);\n  this.pending = null;\n};\nMappings.prototype.addUneditedChunk = function addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n  var originalCharIndex = chunk.start;\n  var first = true;\n  while (originalCharIndex < chunk.end) {\n    if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n      this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n    }\n    if (original[originalCharIndex] === '\\n') {\n      loc.line += 1;\n      loc.column = 0;\n      this.generatedCodeLine += 1;\n      this.raw[this.generatedCodeLine] = this.rawSegments = [];\n      this.generatedCodeColumn = 0;\n      first = true;\n    } else {\n      loc.column += 1;\n      this.generatedCodeColumn += 1;\n      first = false;\n    }\n    originalCharIndex += 1;\n  }\n  this.pending = null;\n};\nMappings.prototype.advance = function advance(str) {\n  if (!str) {\n    return;\n  }\n  var lines = str.split('\\n');\n  if (lines.length > 1) {\n    for (var i = 0; i < lines.length - 1; i++) {\n      this.generatedCodeLine++;\n      this.raw[this.generatedCodeLine] = this.rawSegments = [];\n    }\n    this.generatedCodeColumn = 0;\n  }\n  this.generatedCodeColumn += lines[lines.length - 1].length;\n};\nvar n = '\\n';\nvar warned = {\n  insertLeft: false,\n  insertRight: false,\n  storeName: false\n};\nvar MagicString = function MagicString(string, options) {\n  if (options === void 0) options = {};\n  var chunk = new Chunk(0, string.length, string);\n  Object.defineProperties(this, {\n    original: {\n      writable: true,\n      value: string\n    },\n    outro: {\n      writable: true,\n      value: ''\n    },\n    intro: {\n      writable: true,\n      value: ''\n    },\n    firstChunk: {\n      writable: true,\n      value: chunk\n    },\n    lastChunk: {\n      writable: true,\n      value: chunk\n    },\n    lastSearchedChunk: {\n      writable: true,\n      value: chunk\n    },\n    byStart: {\n      writable: true,\n      value: {}\n    },\n    byEnd: {\n      writable: true,\n      value: {}\n    },\n    filename: {\n      writable: true,\n      value: options.filename\n    },\n    indentExclusionRanges: {\n      writable: true,\n      value: options.indentExclusionRanges\n    },\n    sourcemapLocations: {\n      writable: true,\n      value: new BitSet()\n    },\n    storedNames: {\n      writable: true,\n      value: {}\n    },\n    indentStr: {\n      writable: true,\n      value: guessIndent(string)\n    }\n  });\n  this.byStart[0] = chunk;\n  this.byEnd[string.length] = chunk;\n};\nMagicString.prototype.addSourcemapLocation = function addSourcemapLocation(char) {\n  this.sourcemapLocations.add(char);\n};\nMagicString.prototype.append = function append(content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('outro content must be a string');\n  }\n  this.outro += content;\n  return this;\n};\nMagicString.prototype.appendLeft = function appendLeft(index, content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('inserted content must be a string');\n  }\n  this._split(index);\n  var chunk = this.byEnd[index];\n  if (chunk) {\n    chunk.appendLeft(content);\n  } else {\n    this.intro += content;\n  }\n  return this;\n};\nMagicString.prototype.appendRight = function appendRight(index, content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('inserted content must be a string');\n  }\n  this._split(index);\n  var chunk = this.byStart[index];\n  if (chunk) {\n    chunk.appendRight(content);\n  } else {\n    this.outro += content;\n  }\n  return this;\n};\nMagicString.prototype.clone = function clone() {\n  var cloned = new MagicString(this.original, {\n    filename: this.filename\n  });\n  var originalChunk = this.firstChunk;\n  var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();\n  while (originalChunk) {\n    cloned.byStart[clonedChunk.start] = clonedChunk;\n    cloned.byEnd[clonedChunk.end] = clonedChunk;\n    var nextOriginalChunk = originalChunk.next;\n    var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n    if (nextClonedChunk) {\n      clonedChunk.next = nextClonedChunk;\n      nextClonedChunk.previous = clonedChunk;\n      clonedChunk = nextClonedChunk;\n    }\n    originalChunk = nextOriginalChunk;\n  }\n  cloned.lastChunk = clonedChunk;\n  if (this.indentExclusionRanges) {\n    cloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n  }\n  cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n  cloned.intro = this.intro;\n  cloned.outro = this.outro;\n  return cloned;\n};\nMagicString.prototype.generateDecodedMap = function generateDecodedMap(options) {\n  var this$1 = this;\n  options = options || {};\n  var sourceIndex = 0;\n  var names = Object.keys(this.storedNames);\n  var mappings = new Mappings(options.hires);\n  var locate = getLocator(this.original);\n  if (this.intro) {\n    mappings.advance(this.intro);\n  }\n  this.firstChunk.eachNext(function (chunk) {\n    var loc = locate(chunk.start);\n    if (chunk.intro.length) {\n      mappings.advance(chunk.intro);\n    }\n    if (chunk.edited) {\n      mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n    } else {\n      mappings.addUneditedChunk(sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations);\n    }\n    if (chunk.outro.length) {\n      mappings.advance(chunk.outro);\n    }\n  });\n  return {\n    file: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n    sources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n    sourcesContent: options.includeContent ? [this.original] : [null],\n    names: names,\n    mappings: mappings.raw\n  };\n};\nMagicString.prototype.generateMap = function generateMap(options) {\n  return new SourceMap(this.generateDecodedMap(options));\n};\nMagicString.prototype.getIndentString = function getIndentString() {\n  return this.indentStr === null ? '\\t' : this.indentStr;\n};\nMagicString.prototype.indent = function indent(indentStr, options) {\n  var pattern = /^[^\\r\\n]/gm;\n  if (isObject(indentStr)) {\n    options = indentStr;\n    indentStr = undefined;\n  }\n  indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n  if (indentStr === '') {\n    return this;\n  } // noop\n\n  options = options || {};\n\n  // Process exclusion ranges\n  var isExcluded = {};\n  if (options.exclude) {\n    var exclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n    exclusions.forEach(function (exclusion) {\n      for (var i = exclusion[0]; i < exclusion[1]; i += 1) {\n        isExcluded[i] = true;\n      }\n    });\n  }\n  var shouldIndentNextCharacter = options.indentStart !== false;\n  var replacer = function (match) {\n    if (shouldIndentNextCharacter) {\n      return \"\" + indentStr + match;\n    }\n    shouldIndentNextCharacter = true;\n    return match;\n  };\n  this.intro = this.intro.replace(pattern, replacer);\n  var charIndex = 0;\n  var chunk = this.firstChunk;\n  while (chunk) {\n    var end = chunk.end;\n    if (chunk.edited) {\n      if (!isExcluded[charIndex]) {\n        chunk.content = chunk.content.replace(pattern, replacer);\n        if (chunk.content.length) {\n          shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n        }\n      }\n    } else {\n      charIndex = chunk.start;\n      while (charIndex < end) {\n        if (!isExcluded[charIndex]) {\n          var char = this.original[charIndex];\n          if (char === '\\n') {\n            shouldIndentNextCharacter = true;\n          } else if (char !== '\\r' && shouldIndentNextCharacter) {\n            shouldIndentNextCharacter = false;\n            if (charIndex === chunk.start) {\n              chunk.prependRight(indentStr);\n            } else {\n              this._splitChunk(chunk, charIndex);\n              chunk = chunk.next;\n              chunk.prependRight(indentStr);\n            }\n          }\n        }\n        charIndex += 1;\n      }\n    }\n    charIndex = chunk.end;\n    chunk = chunk.next;\n  }\n  this.outro = this.outro.replace(pattern, replacer);\n  return this;\n};\nMagicString.prototype.insert = function insert() {\n  throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');\n};\nMagicString.prototype.insertLeft = function insertLeft(index, content) {\n  if (!warned.insertLeft) {\n    console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console\n    warned.insertLeft = true;\n  }\n  return this.appendLeft(index, content);\n};\nMagicString.prototype.insertRight = function insertRight(index, content) {\n  if (!warned.insertRight) {\n    console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console\n    warned.insertRight = true;\n  }\n  return this.prependRight(index, content);\n};\nMagicString.prototype.move = function move(start, end, index) {\n  if (index >= start && index <= end) {\n    throw new Error('Cannot move a selection inside itself');\n  }\n  this._split(start);\n  this._split(end);\n  this._split(index);\n  var first = this.byStart[start];\n  var last = this.byEnd[end];\n  var oldLeft = first.previous;\n  var oldRight = last.next;\n  var newRight = this.byStart[index];\n  if (!newRight && last === this.lastChunk) {\n    return this;\n  }\n  var newLeft = newRight ? newRight.previous : this.lastChunk;\n  if (oldLeft) {\n    oldLeft.next = oldRight;\n  }\n  if (oldRight) {\n    oldRight.previous = oldLeft;\n  }\n  if (newLeft) {\n    newLeft.next = first;\n  }\n  if (newRight) {\n    newRight.previous = last;\n  }\n  if (!first.previous) {\n    this.firstChunk = last.next;\n  }\n  if (!last.next) {\n    this.lastChunk = first.previous;\n    this.lastChunk.next = null;\n  }\n  first.previous = newLeft;\n  last.next = newRight || null;\n  if (!newLeft) {\n    this.firstChunk = first;\n  }\n  if (!newRight) {\n    this.lastChunk = last;\n  }\n  return this;\n};\nMagicString.prototype.overwrite = function overwrite(start, end, content, options) {\n  if (typeof content !== 'string') {\n    throw new TypeError('replacement content must be a string');\n  }\n  while (start < 0) {\n    start += this.original.length;\n  }\n  while (end < 0) {\n    end += this.original.length;\n  }\n  if (end > this.original.length) {\n    throw new Error('end is out of bounds');\n  }\n  if (start === end) {\n    throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead');\n  }\n  this._split(start);\n  this._split(end);\n  if (options === true) {\n    if (!warned.storeName) {\n      console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console\n      warned.storeName = true;\n    }\n    options = {\n      storeName: true\n    };\n  }\n  var storeName = options !== undefined ? options.storeName : false;\n  var contentOnly = options !== undefined ? options.contentOnly : false;\n  if (storeName) {\n    var original = this.original.slice(start, end);\n    this.storedNames[original] = true;\n  }\n  var first = this.byStart[start];\n  var last = this.byEnd[end];\n  if (first) {\n    if (end > first.end && first.next !== this.byStart[first.end]) {\n      throw new Error('Cannot overwrite across a split point');\n    }\n    first.edit(content, storeName, contentOnly);\n    if (first !== last) {\n      var chunk = first.next;\n      while (chunk !== last) {\n        chunk.edit('', false);\n        chunk = chunk.next;\n      }\n      chunk.edit('', false);\n    }\n  } else {\n    // must be inserting at the end\n    var newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n    // TODO last chunk in the array may not be the last chunk, if it's moved...\n    last.next = newChunk;\n    newChunk.previous = last;\n  }\n  return this;\n};\nMagicString.prototype.prepend = function prepend(content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('outro content must be a string');\n  }\n  this.intro = content + this.intro;\n  return this;\n};\nMagicString.prototype.prependLeft = function prependLeft(index, content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('inserted content must be a string');\n  }\n  this._split(index);\n  var chunk = this.byEnd[index];\n  if (chunk) {\n    chunk.prependLeft(content);\n  } else {\n    this.intro = content + this.intro;\n  }\n  return this;\n};\nMagicString.prototype.prependRight = function prependRight(index, content) {\n  if (typeof content !== 'string') {\n    throw new TypeError('inserted content must be a string');\n  }\n  this._split(index);\n  var chunk = this.byStart[index];\n  if (chunk) {\n    chunk.prependRight(content);\n  } else {\n    this.outro = content + this.outro;\n  }\n  return this;\n};\nMagicString.prototype.remove = function remove(start, end) {\n  while (start < 0) {\n    start += this.original.length;\n  }\n  while (end < 0) {\n    end += this.original.length;\n  }\n  if (start === end) {\n    return this;\n  }\n  if (start < 0 || end > this.original.length) {\n    throw new Error('Character is out of bounds');\n  }\n  if (start > end) {\n    throw new Error('end must be greater than start');\n  }\n  this._split(start);\n  this._split(end);\n  var chunk = this.byStart[start];\n  while (chunk) {\n    chunk.intro = '';\n    chunk.outro = '';\n    chunk.edit('');\n    chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n  }\n  return this;\n};\nMagicString.prototype.lastChar = function lastChar() {\n  if (this.outro.length) {\n    return this.outro[this.outro.length - 1];\n  }\n  var chunk = this.lastChunk;\n  do {\n    if (chunk.outro.length) {\n      return chunk.outro[chunk.outro.length - 1];\n    }\n    if (chunk.content.length) {\n      return chunk.content[chunk.content.length - 1];\n    }\n    if (chunk.intro.length) {\n      return chunk.intro[chunk.intro.length - 1];\n    }\n  } while (chunk = chunk.previous);\n  if (this.intro.length) {\n    return this.intro[this.intro.length - 1];\n  }\n  return '';\n};\nMagicString.prototype.lastLine = function lastLine() {\n  var lineIndex = this.outro.lastIndexOf(n);\n  if (lineIndex !== -1) {\n    return this.outro.substr(lineIndex + 1);\n  }\n  var lineStr = this.outro;\n  var chunk = this.lastChunk;\n  do {\n    if (chunk.outro.length > 0) {\n      lineIndex = chunk.outro.lastIndexOf(n);\n      if (lineIndex !== -1) {\n        return chunk.outro.substr(lineIndex + 1) + lineStr;\n      }\n      lineStr = chunk.outro + lineStr;\n    }\n    if (chunk.content.length > 0) {\n      lineIndex = chunk.content.lastIndexOf(n);\n      if (lineIndex !== -1) {\n        return chunk.content.substr(lineIndex + 1) + lineStr;\n      }\n      lineStr = chunk.content + lineStr;\n    }\n    if (chunk.intro.length > 0) {\n      lineIndex = chunk.intro.lastIndexOf(n);\n      if (lineIndex !== -1) {\n        return chunk.intro.substr(lineIndex + 1) + lineStr;\n      }\n      lineStr = chunk.intro + lineStr;\n    }\n  } while (chunk = chunk.previous);\n  lineIndex = this.intro.lastIndexOf(n);\n  if (lineIndex !== -1) {\n    return this.intro.substr(lineIndex + 1) + lineStr;\n  }\n  return this.intro + lineStr;\n};\nMagicString.prototype.slice = function slice(start, end) {\n  if (start === void 0) start = 0;\n  if (end === void 0) end = this.original.length;\n  while (start < 0) {\n    start += this.original.length;\n  }\n  while (end < 0) {\n    end += this.original.length;\n  }\n  var result = '';\n\n  // find start chunk\n  var chunk = this.firstChunk;\n  while (chunk && (chunk.start > start || chunk.end <= start)) {\n    // found end chunk before start\n    if (chunk.start < end && chunk.end >= end) {\n      return result;\n    }\n    chunk = chunk.next;\n  }\n  if (chunk && chunk.edited && chunk.start !== start) {\n    throw new Error(\"Cannot use replaced character \" + start + \" as slice start anchor.\");\n  }\n  var startChunk = chunk;\n  while (chunk) {\n    if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n      result += chunk.intro;\n    }\n    var containsEnd = chunk.start < end && chunk.end >= end;\n    if (containsEnd && chunk.edited && chunk.end !== end) {\n      throw new Error(\"Cannot use replaced character \" + end + \" as slice end anchor.\");\n    }\n    var sliceStart = startChunk === chunk ? start - chunk.start : 0;\n    var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n    result += chunk.content.slice(sliceStart, sliceEnd);\n    if (chunk.outro && (!containsEnd || chunk.end === end)) {\n      result += chunk.outro;\n    }\n    if (containsEnd) {\n      break;\n    }\n    chunk = chunk.next;\n  }\n  return result;\n};\n\n// TODO deprecate this? not really very useful\nMagicString.prototype.snip = function snip(start, end) {\n  var clone = this.clone();\n  clone.remove(0, start);\n  clone.remove(end, clone.original.length);\n  return clone;\n};\nMagicString.prototype._split = function _split(index) {\n  if (this.byStart[index] || this.byEnd[index]) {\n    return;\n  }\n  var chunk = this.lastSearchedChunk;\n  var searchForward = index > chunk.end;\n  while (chunk) {\n    if (chunk.contains(index)) {\n      return this._splitChunk(chunk, index);\n    }\n    chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n  }\n};\nMagicString.prototype._splitChunk = function _splitChunk(chunk, index) {\n  if (chunk.edited && chunk.content.length) {\n    // zero-length edited chunks are a special case (overlapping replacements)\n    var loc = getLocator(this.original)(index);\n    throw new Error(\"Cannot split a chunk that has already been edited (\" + loc.line + \":\" + loc.column + \" – \\\"\" + chunk.original + \"\\\")\");\n  }\n  var newChunk = chunk.split(index);\n  this.byEnd[index] = chunk;\n  this.byStart[index] = newChunk;\n  this.byEnd[newChunk.end] = newChunk;\n  if (chunk === this.lastChunk) {\n    this.lastChunk = newChunk;\n  }\n  this.lastSearchedChunk = chunk;\n  return true;\n};\nMagicString.prototype.toString = function toString() {\n  var str = this.intro;\n  var chunk = this.firstChunk;\n  while (chunk) {\n    str += chunk.toString();\n    chunk = chunk.next;\n  }\n  return str + this.outro;\n};\nMagicString.prototype.isEmpty = function isEmpty() {\n  var chunk = this.firstChunk;\n  do {\n    if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) {\n      return false;\n    }\n  } while (chunk = chunk.next);\n  return true;\n};\nMagicString.prototype.length = function length() {\n  var chunk = this.firstChunk;\n  var length = 0;\n  do {\n    length += chunk.intro.length + chunk.content.length + chunk.outro.length;\n  } while (chunk = chunk.next);\n  return length;\n};\nMagicString.prototype.trimLines = function trimLines() {\n  return this.trim('[\\\\r\\\\n]');\n};\nMagicString.prototype.trim = function trim(charType) {\n  return this.trimStart(charType).trimEnd(charType);\n};\nMagicString.prototype.trimEndAborted = function trimEndAborted(charType) {\n  var rx = new RegExp((charType || '\\\\s') + '+$');\n  this.outro = this.outro.replace(rx, '');\n  if (this.outro.length) {\n    return true;\n  }\n  var chunk = this.lastChunk;\n  do {\n    var end = chunk.end;\n    var aborted = chunk.trimEnd(rx);\n\n    // if chunk was trimmed, we have a new lastChunk\n    if (chunk.end !== end) {\n      if (this.lastChunk === chunk) {\n        this.lastChunk = chunk.next;\n      }\n      this.byEnd[chunk.end] = chunk;\n      this.byStart[chunk.next.start] = chunk.next;\n      this.byEnd[chunk.next.end] = chunk.next;\n    }\n    if (aborted) {\n      return true;\n    }\n    chunk = chunk.previous;\n  } while (chunk);\n  return false;\n};\nMagicString.prototype.trimEnd = function trimEnd(charType) {\n  this.trimEndAborted(charType);\n  return this;\n};\nMagicString.prototype.trimStartAborted = function trimStartAborted(charType) {\n  var rx = new RegExp('^' + (charType || '\\\\s') + '+');\n  this.intro = this.intro.replace(rx, '');\n  if (this.intro.length) {\n    return true;\n  }\n  var chunk = this.firstChunk;\n  do {\n    var end = chunk.end;\n    var aborted = chunk.trimStart(rx);\n    if (chunk.end !== end) {\n      // special case...\n      if (chunk === this.lastChunk) {\n        this.lastChunk = chunk.next;\n      }\n      this.byEnd[chunk.end] = chunk;\n      this.byStart[chunk.next.start] = chunk.next;\n      this.byEnd[chunk.next.end] = chunk.next;\n    }\n    if (aborted) {\n      return true;\n    }\n    chunk = chunk.next;\n  } while (chunk);\n  return false;\n};\nMagicString.prototype.trimStart = function trimStart(charType) {\n  this.trimStartAborted(charType);\n  return this;\n};\nvar hasOwnProp = Object.prototype.hasOwnProperty;\nvar Bundle = function Bundle(options) {\n  if (options === void 0) options = {};\n  this.intro = options.intro || '';\n  this.separator = options.separator !== undefined ? options.separator : '\\n';\n  this.sources = [];\n  this.uniqueSources = [];\n  this.uniqueSourceIndexByFilename = {};\n};\nBundle.prototype.addSource = function addSource(source) {\n  if (source instanceof MagicString) {\n    return this.addSource({\n      content: source,\n      filename: source.filename,\n      separator: this.separator\n    });\n  }\n  if (!isObject(source) || !source.content) {\n    throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');\n  }\n  ['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {\n    if (!hasOwnProp.call(source, option)) {\n      source[option] = source.content[option];\n    }\n  });\n  if (source.separator === undefined) {\n    // TODO there's a bunch of this sort of thing, needs cleaning up\n    source.separator = this.separator;\n  }\n  if (source.filename) {\n    if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n      this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n      this.uniqueSources.push({\n        filename: source.filename,\n        content: source.content.original\n      });\n    } else {\n      var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n      if (source.content.original !== uniqueSource.content) {\n        throw new Error(\"Illegal source: same filename (\" + source.filename + \"), different contents\");\n      }\n    }\n  }\n  this.sources.push(source);\n  return this;\n};\nBundle.prototype.append = function append(str, options) {\n  this.addSource({\n    content: new MagicString(str),\n    separator: options && options.separator || ''\n  });\n  return this;\n};\nBundle.prototype.clone = function clone() {\n  var bundle = new Bundle({\n    intro: this.intro,\n    separator: this.separator\n  });\n  this.sources.forEach(function (source) {\n    bundle.addSource({\n      filename: source.filename,\n      content: source.content.clone(),\n      separator: source.separator\n    });\n  });\n  return bundle;\n};\nBundle.prototype.generateDecodedMap = function generateDecodedMap(options) {\n  var this$1 = this;\n  if (options === void 0) options = {};\n  var names = [];\n  this.sources.forEach(function (source) {\n    Object.keys(source.content.storedNames).forEach(function (name) {\n      if (!~names.indexOf(name)) {\n        names.push(name);\n      }\n    });\n  });\n  var mappings = new Mappings(options.hires);\n  if (this.intro) {\n    mappings.advance(this.intro);\n  }\n  this.sources.forEach(function (source, i) {\n    if (i > 0) {\n      mappings.advance(this$1.separator);\n    }\n    var sourceIndex = source.filename ? this$1.uniqueSourceIndexByFilename[source.filename] : -1;\n    var magicString = source.content;\n    var locate = getLocator(magicString.original);\n    if (magicString.intro) {\n      mappings.advance(magicString.intro);\n    }\n    magicString.firstChunk.eachNext(function (chunk) {\n      var loc = locate(chunk.start);\n      if (chunk.intro.length) {\n        mappings.advance(chunk.intro);\n      }\n      if (source.filename) {\n        if (chunk.edited) {\n          mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n        } else {\n          mappings.addUneditedChunk(sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations);\n        }\n      } else {\n        mappings.advance(chunk.content);\n      }\n      if (chunk.outro.length) {\n        mappings.advance(chunk.outro);\n      }\n    });\n    if (magicString.outro) {\n      mappings.advance(magicString.outro);\n    }\n  });\n  return {\n    file: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n    sources: this.uniqueSources.map(function (source) {\n      return options.file ? getRelativePath(options.file, source.filename) : source.filename;\n    }),\n    sourcesContent: this.uniqueSources.map(function (source) {\n      return options.includeContent ? source.content : null;\n    }),\n    names: names,\n    mappings: mappings.raw\n  };\n};\nBundle.prototype.generateMap = function generateMap(options) {\n  return new SourceMap(this.generateDecodedMap(options));\n};\nBundle.prototype.getIndentString = function getIndentString() {\n  var indentStringCounts = {};\n  this.sources.forEach(function (source) {\n    var indentStr = source.content.indentStr;\n    if (indentStr === null) {\n      return;\n    }\n    if (!indentStringCounts[indentStr]) {\n      indentStringCounts[indentStr] = 0;\n    }\n    indentStringCounts[indentStr] += 1;\n  });\n  return Object.keys(indentStringCounts).sort(function (a, b) {\n    return indentStringCounts[a] - indentStringCounts[b];\n  })[0] || '\\t';\n};\nBundle.prototype.indent = function indent(indentStr) {\n  var this$1 = this;\n  if (!arguments.length) {\n    indentStr = this.getIndentString();\n  }\n  if (indentStr === '') {\n    return this;\n  } // noop\n\n  var trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n  this.sources.forEach(function (source, i) {\n    var separator = source.separator !== undefined ? source.separator : this$1.separator;\n    var indentStart = trailingNewline || i > 0 && /\\r?\\n$/.test(separator);\n    source.content.indent(indentStr, {\n      exclude: source.indentExclusionRanges,\n      indentStart: indentStart //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n    });\n\n    trailingNewline = source.content.lastChar() === '\\n';\n  });\n  if (this.intro) {\n    this.intro = indentStr + this.intro.replace(/^[^\\n]/gm, function (match, index) {\n      return index > 0 ? indentStr + match : match;\n    });\n  }\n  return this;\n};\nBundle.prototype.prepend = function prepend(str) {\n  this.intro = str + this.intro;\n  return this;\n};\nBundle.prototype.toString = function toString() {\n  var this$1 = this;\n  var body = this.sources.map(function (source, i) {\n    var separator = source.separator !== undefined ? source.separator : this$1.separator;\n    var str = (i > 0 ? separator : '') + source.content.toString();\n    return str;\n  }).join('');\n  return this.intro + body;\n};\nBundle.prototype.isEmpty = function isEmpty() {\n  if (this.intro.length && this.intro.trim()) {\n    return false;\n  }\n  if (this.sources.some(function (source) {\n    return !source.content.isEmpty();\n  })) {\n    return false;\n  }\n  return true;\n};\nBundle.prototype.length = function length() {\n  return this.sources.reduce(function (length, source) {\n    return length + source.content.length();\n  }, this.intro.length);\n};\nBundle.prototype.trimLines = function trimLines() {\n  return this.trim('[\\\\r\\\\n]');\n};\nBundle.prototype.trim = function trim(charType) {\n  return this.trimStart(charType).trimEnd(charType);\n};\nBundle.prototype.trimStart = function trimStart(charType) {\n  var rx = new RegExp('^' + (charType || '\\\\s') + '+');\n  this.intro = this.intro.replace(rx, '');\n  if (!this.intro) {\n    var source;\n    var i = 0;\n    do {\n      source = this.sources[i++];\n      if (!source) {\n        break;\n      }\n    } while (!source.content.trimStartAborted(charType));\n  }\n  return this;\n};\nBundle.prototype.trimEnd = function trimEnd(charType) {\n  var rx = new RegExp((charType || '\\\\s') + '+$');\n  var source;\n  var i = this.sources.length - 1;\n  do {\n    source = this.sources[i--];\n    if (!source) {\n      this.intro = this.intro.replace(rx, '');\n      break;\n    }\n  } while (!source.content.trimEndAborted(charType));\n  return this;\n};\nexport default MagicString;\nexport { Bundle, SourceMap };","map":{"version":3,"sources":["../src/BitSet.js","../src/Chunk.js","../src/SourceMap.js","../src/utils/guessIndent.js","../src/utils/getRelativePath.js","../src/utils/isObject.js","../src/utils/getLocator.js","../src/utils/Mappings.js","../src/MagicString.js","../src/Bundle.js"],"names":["const","let","this"],"mappings":"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","sourcesContent":["export default class BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}","export default class Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t// we make these non-enumerable, for sanity while debugging\n\t\tObject.defineProperties(this, {\n\t\t\tprevious: { writable: true, value: null },\n\t\t\tnext:     { writable: true, value: null }\n\t\t});\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.end - trimmed.length);\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n","import { encode } from 'sourcemap-codec';\n\nlet btoa = () => {\n\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\tbtoa = str => window.btoa(unescape(encodeURIComponent(str)));\n} else if (typeof Buffer === 'function') {\n\tbtoa = str => Buffer.from(str, 'utf-8').toString('base64');\n}\n\nexport default class SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n","export default function guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter(line => /^\\t+/.test(line));\n\tconst spaced = lines.filter(line => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n","export default function getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n","const toString = Object.prototype.toString;\n\nexport default function isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n","export default function getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n","export default class Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t}\n\n\t\tthis.advance(content);\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n","import BitSet from './BitSet.js';\nimport Chunk from './Chunk.js';\nimport SourceMap from './SourceMap.js';\nimport guessIndent from './utils/guessIndent.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\nimport Stats from './utils/Stats.js';\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false\n};\n\nexport default class MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal:              { writable: true, value: string },\n\t\t\toutro:                 { writable: true, value: '' },\n\t\t\tintro:                 { writable: true, value: '' },\n\t\t\tfirstChunk:            { writable: true, value: chunk },\n\t\t\tlastChunk:             { writable: true, value: chunk },\n\t\t\tlastSearchedChunk:     { writable: true, value: chunk },\n\t\t\tbyStart:               { writable: true, value: {} },\n\t\t\tbyEnd:                 { writable: true, value: {} },\n\t\t\tfilename:              { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations:    { writable: true, value: new BitSet() },\n\t\t\tstoredNames:           { writable: true, value: {} },\n\t\t\tindentStr:             { writable: true, value: guessIndent(string) }\n\t\t});\n\n\t\tif (DEBUG) {\n\t\t\tObject.defineProperty(this, 'stats', { value: new Stats() });\n\t\t}\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendLeft');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendLeft');\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendRight');\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext(chunk => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames,\n\t\t\tmappings: mappings.raw\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tindentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach(exclusion => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = match => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tif (DEBUG) this.stats.time('move');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\n\t\tif (DEBUG) this.stats.timeEnd('move');\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead');\n\n\t\tif (DEBUG) this.stats.time('overwrite');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst contentOnly = options !== undefined ? options.contentOnly : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tthis.storedNames[original] = true;\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tif (end > first.end && first.next !== this.byStart[first.end]) {\n\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, contentOnly);\n\n\t\t\tif (first !== last) {\n\t\t\t\tlet chunk = first.next;\n\t\t\t\twhile (chunk !== last) {\n\t\t\t\t\tchunk.edit('', false);\n\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('overwrite');\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tif (DEBUG) this.stats.time('remove');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('remove');\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length)\n\t\t\treturn this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length)\n\t\t\t\treturn chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length)\n\t\t\t\treturn chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length)\n\t\t\t\treturn chunk.intro[chunk.intro.length - 1];\n\t\t} while (chunk = chunk.previous);\n\t\tif (this.intro.length)\n\t\t\treturn this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1)\n\t\t\treturn this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1)\n\t\t\t\t\treturn chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1)\n\t\t\t\t\treturn chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1)\n\t\t\t\t\treturn chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while (chunk = chunk.previous);\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1)\n\t\t\treturn this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tif (DEBUG) this.stats.time('_split');\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${\n\t\t\t\t\tchunk.original\n\t\t\t\t}\")`\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\tif (DEBUG) this.stats.timeEnd('_split');\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (chunk.intro.length && chunk.intro.trim() ||\n\t\t\t\t\tchunk.content.length && chunk.content.trim() ||\n\t\t\t\t\tchunk.outro.length && chunk.outro.trim())\n\t\t\t\treturn false;\n\t\t} while (chunk = chunk.next);\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while (chunk = chunk.next);\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n}\n","import MagicString from './MagicString.js';\nimport SourceMap from './SourceMap.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nexport default class Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');\n\t\t}\n\n\t\t['filename', 'indentExclusionRanges', 'separator'].forEach(option => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || ''\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator\n\t\t});\n\n\t\tthis.sources.forEach(source => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tthis.sources.forEach(source => {\n\t\t\tObject.keys(source.content.storedNames).forEach(name => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext(chunk => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: this.uniqueSources.map(source => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map(source => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach(source => {\n\t\t\tconst indentStr = source.content.indentStr;\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty () {\n\t\tif (this.intro.length && this.intro.trim())\n\t\t\treturn false;\n\t\tif (this.sources.some(source => !source.content.isEmpty()))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce((length, source) => length + source.content.length(), this.intro.length);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}