{"ast":null,"code":"/**\n * Bundle of @devexpress/dx-grid-core\n * Generated: 2022-10-14\n * Version: 3.0.6\n * License: https://js.devexpress.com/Licensing\n */\n\nimport { slice, easeOutCubic } from '@devexpress/dx-core';\nvar GRID_GROUP_TYPE = Symbol('group');\nvar GRID_GROUP_CHECK = Symbol(GRID_GROUP_TYPE.toString() + \"_check\");\nvar GRID_GROUP_LEVEL_KEY = Symbol(GRID_GROUP_TYPE.toString() + \"_levelKey\");\nvar GRID_GROUP_COLLAPSED_ROWS = Symbol(GRID_GROUP_TYPE.toString() + \"_collapsedRows\");\nvar warnIfRowIdUndefined = function (getRowId) {\n  return function (row) {\n    var result = getRowId(row);\n    if (!row[GRID_GROUP_CHECK] && result === undefined) {\n      // tslint:disable-next-line: no-console\n      console.warn('The row id is undefined. Check the getRowId function. The row is', row);\n    }\n    return result;\n  };\n};\nvar rowIdGetter = function (getRowId, rows) {\n  if (!getRowId) {\n    var map_1 = new Map(rows.map(function (row, rowIndex) {\n      return [row, rowIndex];\n    }));\n    return function (row) {\n      return map_1.get(row);\n    };\n  }\n  return warnIfRowIdUndefined(getRowId);\n};\nvar defaultGetCellValue = function (row, columnName) {\n  return row[columnName];\n};\nvar cellValueGetter = function (getCellValue, columns) {\n  if (getCellValue === void 0) {\n    getCellValue = defaultGetCellValue;\n  }\n  var useFastAccessor = true;\n  var map = columns.reduce(function (acc, column) {\n    if (column.getCellValue) {\n      useFastAccessor = false;\n      acc[column.name] = column.getCellValue;\n    }\n    return acc;\n  }, {});\n  if (useFastAccessor) {\n    return getCellValue;\n  }\n  return function (row, columnName) {\n    return map[columnName] ? map[columnName](row, columnName) : getCellValue(row, columnName);\n  };\n};\nvar changeColumnSorting = function (state, _a) {\n  var columnName = _a.columnName,\n    direction = _a.direction,\n    keepOther = _a.keepOther,\n    sortIndex = _a.sortIndex;\n  var sorting = state.sorting;\n  var nextSorting = [];\n  if (keepOther === true) {\n    nextSorting = sorting;\n  }\n  if (Array.isArray(keepOther)) {\n    nextSorting = slice(sorting).filter(function (s) {\n      return keepOther.indexOf(s.columnName) > -1;\n    });\n  }\n  var columnSortingIndex = sorting.findIndex(function (s) {\n    return s.columnName === columnName;\n  });\n  var columnSorting = sorting[columnSortingIndex];\n  var newColumnSorting = {\n    columnName: columnName,\n    direction: direction || (!columnSorting || columnSorting.direction === 'desc' ? 'asc' : 'desc')\n  };\n  if (columnSortingIndex > -1) {\n    nextSorting = slice(nextSorting);\n    nextSorting.splice(columnSortingIndex, 1);\n  }\n  if (direction !== null) {\n    var newIndexFallback = columnSortingIndex > -1 ? columnSortingIndex : nextSorting.length;\n    var newIndex = sortIndex !== undefined ? sortIndex : newIndexFallback;\n    nextSorting = slice(nextSorting);\n    nextSorting.splice(newIndex, 0, newColumnSorting);\n  }\n  return {\n    sorting: nextSorting\n  };\n};\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n}\n\n/** @deprecated */\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\nvar unique = function (arr) {\n  return __spread(Array.from(new Set(arr)));\n};\nvar getColumnSortingDirection = function (sorting, columnName) {\n  var columnSorting = sorting.filter(function (s) {\n    return s.columnName === columnName;\n  })[0];\n  return columnSorting ? columnSorting.direction : null;\n};\nvar getPersistentSortedColumns = function (sorting, columnExtensions) {\n  if (columnExtensions === void 0) {\n    columnExtensions = [];\n  }\n  return columnExtensions.reduce(function (acc, _a) {\n    var columnName = _a.columnName,\n      sortingEnabled = _a.sortingEnabled;\n    if (!sortingEnabled) {\n      if (sorting.findIndex(function (sortItem) {\n        return sortItem.columnName === columnName;\n      }) > -1) {\n        acc.push(columnName);\n      }\n    }\n    return acc;\n  }, []);\n};\nvar calculateKeepOther = function (sorting, keepOther, persistentSortedColumns) {\n  if (persistentSortedColumns === void 0) {\n    persistentSortedColumns = [];\n  }\n  if (!persistentSortedColumns.length) return keepOther;\n  if (!keepOther) return persistentSortedColumns;\n  return Array.isArray(keepOther) ? unique(__spread(keepOther, persistentSortedColumns)) : unique(__spread(sorting.map(function (item) {\n    return item.columnName;\n  }), persistentSortedColumns));\n};\n\n/* eslint-disable no-plusplus, no-param-reassign, no-use-before-define, no-constant-condition */\n/* tslint:disable no-increment-decrement */\nvar merge = function (array, auxiliary, lo, mid, hi, compare) {\n  var i = lo;\n  var j = mid + 1;\n  var k = lo;\n  while (true) {\n    var cmp = compare(array[i], array[j]);\n    if (cmp <= 0) {\n      auxiliary[k++] = array[i++];\n      if (i > mid) {\n        do {\n          auxiliary[k++] = array[j++];\n        } while (j <= hi);\n        break;\n      }\n    } else {\n      auxiliary[k++] = array[j++];\n      if (j > hi) {\n        do {\n          auxiliary[k++] = array[i++];\n        } while (i <= mid);\n        break;\n      }\n    }\n  }\n};\nvar sortArrayToAuxiliary = function (array, auxiliary, lo, hi, compare) {\n  if (hi < lo) return;\n  if (hi === lo) {\n    auxiliary[lo] = array[lo];\n    return;\n  }\n  var mid = Math.floor(lo + (hi - lo) / 2);\n  sortAuxiliaryToArray(array, auxiliary, lo, mid, compare);\n  sortAuxiliaryToArray(array, auxiliary, mid + 1, hi, compare);\n  merge(array, auxiliary, lo, mid, hi, compare);\n};\nvar sortAuxiliaryToArray = function (array, auxiliary, lo, hi, compare) {\n  if (hi <= lo) return;\n  var mid = Math.floor(lo + (hi - lo) / 2);\n  sortArrayToAuxiliary(array, auxiliary, lo, mid, compare);\n  sortArrayToAuxiliary(array, auxiliary, mid + 1, hi, compare);\n  merge(auxiliary, array, lo, mid, hi, compare);\n};\nvar mergeSort = function (array, compare) {\n  if (compare === void 0) {\n    compare = function (a, b) {\n      if (a < b) return -1;\n      if (a > b) return 1;\n      return 0;\n    };\n  }\n  var result = slice(array);\n  var auxiliary = slice(array);\n  sortAuxiliaryToArray(result, auxiliary, 0, result.length - 1, compare);\n  return result;\n};\nvar NODE_CHECK = Symbol('node');\nvar rowsToTree = function (rows, getRowLevelKey) {\n  if (!rows.length) return rows;\n  var levels = [{\n    children: []\n  }];\n  rows.forEach(function (row) {\n    var _a;\n    var levelKey = getRowLevelKey(row);\n    if (levelKey) {\n      var levelIndex = levels.slice(1).findIndex(function (level) {\n        return getRowLevelKey(level.root) === levelKey;\n      }) + 1;\n      if (levelIndex > 0) {\n        levels.splice(levelIndex, levels.length - levelIndex);\n      }\n      var node = (_a = {}, _a[NODE_CHECK] = true, _a.root = row, _a.children = [], _a);\n      levels[levels.length - 1].children.push(node);\n      levels.push(node);\n    } else {\n      levels[levels.length - 1].children.push(row);\n    }\n  });\n  return levels[0].children;\n};\nvar treeToRows = function (tree, rows) {\n  if (rows === void 0) {\n    rows = [];\n  }\n  if (!tree.length) return tree;\n  return tree.reduce(function (acc, node) {\n    if (node[NODE_CHECK]) {\n      acc.push(node.root);\n      treeToRows(node.children, rows);\n    } else {\n      acc.push(node);\n    }\n    return acc;\n  }, rows);\n};\nvar defaultCompare = function (a, b) {\n  if (a === b) return 0;\n  if (a === null) {\n    return b === undefined ? -1 : 1;\n  }\n  if (a === undefined) {\n    return 1;\n  }\n  if (b === null || b === undefined) {\n    return -1;\n  }\n  return a < b ? -1 : 1;\n};\nvar createCompare = function (sorting, getColumnCompare, getComparableValue) {\n  return sorting.reduceRight(function (prevCompare, columnSorting) {\n    var columnName = columnSorting.columnName;\n    var inverse = columnSorting.direction === 'desc';\n    var columnCompare = getColumnCompare && getColumnCompare(columnName) || defaultCompare;\n    return function (aRow, bRow) {\n      var a = getComparableValue(aRow, columnName);\n      var b = getComparableValue(bRow, columnName);\n      var result = columnCompare(a, b);\n      if (result !== 0) {\n        return inverse ? -result : result;\n      }\n      return prevCompare(aRow, bRow);\n    };\n  }, function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    return 0;\n  });\n};\nvar sortTree = function (tree, compare) {\n  var sortedTree = tree.map(function (node) {\n    if (node[NODE_CHECK]) {\n      return __assign(__assign({}, node), {\n        children: sortTree(node.children, compare)\n      });\n    }\n    return node;\n  });\n  return mergeSort(sortedTree, function (a, b) {\n    return compare(a[NODE_CHECK] ? a.root : a, b[NODE_CHECK] ? b.root : b);\n  });\n};\nvar sortHierarchicalRows = function (rows, compare, getRowLevelKey) {\n  var tree = rowsToTree(rows, getRowLevelKey);\n  var sortedTree = sortTree(tree, compare);\n  return treeToRows(sortedTree);\n};\nvar sortedRows = function (rows, sorting, getCellValue, getColumnCompare, isGroupRow, getRowLevelKey) {\n  if (!sorting.length || !rows.length) return rows;\n  var compare;\n  if (!getRowLevelKey) {\n    compare = createCompare(sorting, getColumnCompare, getCellValue);\n    return mergeSort(rows.slice(), compare);\n  }\n  compare = createCompare(sorting, getColumnCompare, function (row, columnName) {\n    if (isGroupRow && isGroupRow(row)) {\n      if (row.groupedBy === columnName) {\n        return row.value;\n      }\n      return undefined;\n    }\n    return getCellValue(row, columnName);\n  });\n  return sortHierarchicalRows(rows, compare, getRowLevelKey);\n};\nvar changeColumnFilter = function (filters, _a) {\n  var columnName = _a.columnName,\n    config = _a.config;\n  var filterIndex = filters.findIndex(function (f) {\n    return f.columnName === columnName;\n  });\n  var nextState = slice(filters);\n  if (config) {\n    var filter = __assign({\n      columnName: columnName\n    }, config);\n    if (filterIndex > -1) {\n      nextState.splice(filterIndex, 1, filter);\n    } else {\n      nextState.push(filter);\n    }\n  } else if (filterIndex > -1) {\n    nextState.splice(filterIndex, 1);\n  }\n  return nextState;\n};\nvar getColumnFilterConfig = function (filters, columnName) {\n  return filters.length && filters.filter(function (s) {\n    return s.columnName === columnName;\n  })[0] || null;\n};\nvar filterExpression = function (filters, expression) {\n  // tslint:disable-next-line: no-object-literal-type-assertion\n  var selfFilterExpr = {\n    filters: filters,\n    operator: 'and'\n  };\n  if (!expression) {\n    return selfFilterExpr;\n  }\n  return {\n    operator: 'and',\n    filters: [expression, selfFilterExpr]\n  };\n};\nvar operators = {\n  or: function (predicates) {\n    return function (row) {\n      return predicates.reduce(function (acc, predicate) {\n        return acc || predicate(row);\n      }, false);\n    };\n  },\n  and: function (predicates) {\n    return function (row) {\n      return predicates.reduce(function (acc, predicate) {\n        return acc && predicate(row);\n      }, true);\n    };\n  }\n};\nvar toLowerCase = function (value) {\n  return String(value).toLowerCase();\n};\nvar operationPredicates = {\n  contains: function (value, filter) {\n    return toLowerCase(value).indexOf(toLowerCase(filter.value)) > -1;\n  },\n  notContains: function (value, filter) {\n    return toLowerCase(value).indexOf(toLowerCase(filter.value)) === -1;\n  },\n  startsWith: function (value, filter) {\n    return toLowerCase(value).startsWith(toLowerCase(filter.value));\n  },\n  endsWith: function (value, filter) {\n    return toLowerCase(value).endsWith(toLowerCase(filter.value));\n  },\n  equal: function (value, filter) {\n    return String(value) === String(filter.value);\n  },\n  notEqual: function (value, filter) {\n    return String(value) !== String(filter.value);\n  },\n  greaterThan: function (value, filter) {\n    return value > filter.value;\n  },\n  greaterThanOrEqual: function (value, filter) {\n    return value >= filter.value;\n  },\n  lessThan: function (value, filter) {\n    return value < filter.value;\n  },\n  lessThanOrEqual: function (value, filter) {\n    return value <= filter.value;\n  }\n};\nvar defaultFilterPredicate = function (value, filter) {\n  var operation = filter.operation || 'contains';\n  return operationPredicates[operation](value, filter);\n};\nvar filterTree = function (tree, predicate) {\n  return tree.reduce(function (acc, node) {\n    if (node[NODE_CHECK]) {\n      var filteredChildren = filterTree(node.children, predicate);\n      if (filteredChildren.length > 0) {\n        acc.push(__assign(__assign({}, node), {\n          children: filteredChildren\n        }));\n        return acc;\n      }\n      if (predicate(node.root, true)) {\n        acc.push(node.root);\n        return acc;\n      }\n      return acc;\n    }\n    if (predicate(node)) {\n      acc.push(node);\n      return acc;\n    }\n    return acc;\n  }, []);\n};\nvar filterHierarchicalRows = function (rows, predicate, getRowLevelKey, getCollapsedRows) {\n  var tree = rowsToTree(rows, getRowLevelKey);\n  var collapsedRowsMeta = [];\n  var filteredTree = filterTree(tree, function (row, isNode) {\n    if (isNode) {\n      var collapsedRows = getCollapsedRows && getCollapsedRows(row);\n      if (collapsedRows && collapsedRows.length) {\n        var filteredCollapsedRows = collapsedRows.filter(predicate);\n        collapsedRowsMeta.push([row, filteredCollapsedRows]);\n        return !!filteredCollapsedRows.length || predicate(row);\n      }\n      if (predicate(row)) {\n        collapsedRowsMeta.push([row, []]);\n        return true;\n      }\n      return false;\n    }\n    return predicate(row);\n  });\n  return {\n    rows: treeToRows(filteredTree),\n    collapsedRowsMeta: new Map(collapsedRowsMeta)\n  };\n};\nvar buildPredicate = function (initialFilterExpression, getCellValue, getColumnPredicate) {\n  var getSimplePredicate = function (filter) {\n    var columnName = filter.columnName;\n    var customPredicate = getColumnPredicate && getColumnPredicate(columnName);\n    var predicate = customPredicate || defaultFilterPredicate;\n    return function (row) {\n      return predicate(getCellValue(row, columnName), filter, row);\n    };\n  };\n  var getOperatorPredicate = function (filterExpression) {\n    var build = operators[toLowerCase(filterExpression.operator)];\n    return build && build(filterExpression.filters.map(getPredicate));\n  };\n  var getPredicate = function (filterExpression) {\n    return getOperatorPredicate(filterExpression) || getSimplePredicate(filterExpression);\n  };\n  return getPredicate(initialFilterExpression);\n};\nvar filteredRows = function (rows, filterExpression, getCellValue, getColumnPredicate, getRowLevelKey, getCollapsedRows) {\n  if (!(filterExpression && Object.keys(filterExpression).length && rows.length)) {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    return {\n      rows: rows\n    };\n  }\n  var predicate = buildPredicate(filterExpression, getCellValue, getColumnPredicate);\n  return getRowLevelKey ? filterHierarchicalRows(rows, predicate, getRowLevelKey, getCollapsedRows) : {\n    rows: rows.filter(predicate)\n  };\n};\nvar filteredCollapsedRowsGetter = function (_a) {\n  var collapsedRowsMeta = _a.collapsedRowsMeta;\n  return function (row) {\n    return collapsedRowsMeta && collapsedRowsMeta.get(row);\n  };\n};\nvar unwrappedFilteredRows = function (_a) {\n  var rows = _a.rows;\n  return rows;\n};\nvar GROUP_KEY_SEPARATOR = '|';\nvar applyColumnGrouping = function (grouping, _a) {\n  var columnName = _a.columnName,\n    groupIndex = _a.groupIndex;\n  var nextGrouping = grouping;\n  var groupingIndex = nextGrouping.findIndex(function (g) {\n    return g.columnName === columnName;\n  });\n  var targetIndex = groupIndex;\n  if (groupingIndex > -1) {\n    nextGrouping = slice(grouping);\n    nextGrouping.splice(groupingIndex, 1);\n  } else if (groupIndex === undefined) {\n    targetIndex = nextGrouping.length;\n  }\n  if (targetIndex > -1) {\n    nextGrouping = slice(nextGrouping);\n    nextGrouping.splice(targetIndex, 0, {\n      columnName: columnName\n    });\n  }\n  return nextGrouping;\n};\nvar changeColumnGrouping = function (_a, _b) {\n  var grouping = _a.grouping,\n    expandedGroups = _a.expandedGroups;\n  var columnName = _b.columnName,\n    groupIndex = _b.groupIndex;\n  var nextGrouping = applyColumnGrouping(grouping, {\n    columnName: columnName,\n    groupIndex: groupIndex\n  });\n  var ungroupedColumnIndex = grouping.findIndex(function (group, index) {\n    return !nextGrouping[index] || group.columnName !== nextGrouping[index].columnName;\n  });\n  if (ungroupedColumnIndex === -1) {\n    return {\n      grouping: nextGrouping\n    };\n  }\n  var filteredExpandedGroups = expandedGroups.filter(function (group) {\n    return group.split(GROUP_KEY_SEPARATOR).length <= ungroupedColumnIndex;\n  });\n  if (filteredExpandedGroups.length === expandedGroups.length) {\n    return {\n      grouping: nextGrouping\n    };\n  }\n  return {\n    grouping: nextGrouping,\n    expandedGroups: filteredExpandedGroups\n  };\n};\nvar toggleExpandedGroups = function (state, _a) {\n  var groupKey = _a.groupKey;\n  var expandedGroups = slice(state.expandedGroups);\n  var groupKeyIndex = expandedGroups.indexOf(groupKey);\n  if (groupKeyIndex > -1) {\n    expandedGroups.splice(groupKeyIndex, 1);\n  } else {\n    expandedGroups.push(groupKey);\n  }\n  return {\n    expandedGroups: expandedGroups\n  };\n};\nvar draftColumnGrouping = function (_a, _b) {\n  var grouping = _a.grouping,\n    draftGrouping = _a.draftGrouping;\n  var columnName = _b.columnName,\n    groupIndex = _b.groupIndex;\n  return {\n    draftGrouping: applyColumnGrouping(draftGrouping || grouping, {\n      columnName: columnName,\n      groupIndex: groupIndex\n    })\n  };\n};\nvar cancelColumnGroupingDraft = function () {\n  return {\n    draftGrouping: null\n  };\n};\nvar adjustSortIndex = function (groupingIndex, grouping, sorting) {\n  return Math.max(grouping.slice(0, groupingIndex).reduce(function (acc, columnGrouping) {\n    var columnSortingIndex = sorting.findIndex(function (columnSorting) {\n      return columnSorting.columnName === columnGrouping.columnName;\n    });\n    return columnSortingIndex === -1 ? acc - 1 : acc;\n  }, groupingIndex), 0);\n};\nvar defaultColumnCriteria = function (value) {\n  return {\n    value: value,\n    key: String(value)\n  };\n};\nvar getGroupRows = function (rows, grouping, groupsGetter) {\n  if (grouping.length === 0) {\n    return rows;\n  }\n  var keyPrefixes = [{\n    prefix: '',\n    level: 0,\n    rows: rows\n  }];\n  var resultRows = [];\n  var compoundKeys = {};\n  var _loop_1 = function () {\n    var _a = keyPrefixes.pop(),\n      keyPrefix = _a.prefix,\n      level = _a.level,\n      currentRows = _a.rows;\n    var currentCompoundKey = keyPrefix.slice(0, keyPrefix.length - 1);\n    var groupIndex = (_a = compoundKeys[currentCompoundKey]) !== null && _a !== void 0 ? _a : -1;\n    var groupRows = grouping[level] && currentRows.length ? groupsGetter(currentRows, grouping[level], keyPrefix).map(function (_a, rowIndex) {\n      var childRows = _a.childRows,\n        params = __rest(_a, [\"childRows\"]);\n      var compoundKey = params.compoundKey;\n      compoundKeys[compoundKey] = groupIndex + rowIndex + 1;\n      keyPrefixes.push({\n        prefix: \"\" + compoundKey + GROUP_KEY_SEPARATOR,\n        level: level + 1,\n        rows: childRows || []\n      });\n      return params;\n    }) : currentRows;\n    if (groupIndex > -1) {\n      resultRows.splice.apply(resultRows, __spread([groupIndex + 1, 0], groupRows));\n    } else {\n      groupRows.forEach(function (row) {\n        return resultRows.push(row);\n      });\n    }\n  };\n  while (keyPrefixes.length) {\n    _loop_1();\n  }\n  return resultRows;\n};\nvar getIntegratedGroups = function (rows, grouping, keyPrefix, getCellValue, getColumnCriteria) {\n  var columnName = grouping.columnName;\n  var groupCriteria = getColumnCriteria && getColumnCriteria(columnName) || defaultColumnCriteria;\n  var groups = new Map();\n  rows.forEach(function (row) {\n    var rawValue = getCellValue(row, columnName);\n    var _a = groupCriteria(rawValue, row),\n      key = _a.key,\n      value = _a.value;\n    var sameKeyItems = groups.get(key);\n    if (!sameKeyItems) {\n      var groupingValue = value === rawValue ? value : value || key;\n      groups.set(key, [groupingValue, key, [row]]);\n    } else {\n      sameKeyItems[2].push(row);\n    }\n  });\n  var groupedBy = columnName;\n  return __spread(groups.values()).map(function (_a) {\n    var _b;\n    var _c = __read(_a, 3),\n      value = _c[0],\n      key = _c[1],\n      childRows = _c[2];\n    return _b = {\n      groupedBy: groupedBy,\n      compoundKey: \"\" + keyPrefix + key,\n      key: key,\n      value: value\n    }, _b[GRID_GROUP_CHECK] = true, _b[GRID_GROUP_LEVEL_KEY] = GRID_GROUP_TYPE.toString() + \"_\" + groupedBy, _b.childRows = childRows, _b;\n  });\n};\nvar groupRowChecker = function (row) {\n  return row[GRID_GROUP_CHECK];\n};\nvar groupRowLevelKeyGetter = function (row) {\n  return row ? row[GRID_GROUP_LEVEL_KEY] : undefined;\n};\nvar groupedRows = function (rows, grouping, getCellValue, getColumnCriteria) {\n  var groupsGetter = function (currentRows, currentGrouping, prefix) {\n    return getIntegratedGroups(currentRows, currentGrouping, prefix, getCellValue, getColumnCriteria);\n  };\n  return getGroupRows(rows, grouping, groupsGetter);\n};\nvar expandedGroupRows = function (rows, grouping, expandedGroups, isExporting) {\n  if (!grouping.length) return rows;\n  var groupingColumnNames = grouping.map(function (columnGrouping) {\n    return columnGrouping.columnName;\n  });\n  var expandedGroupsSet = new Set(expandedGroups);\n  var currentGroupExpanded = true;\n  var currentGroupLevel = 0;\n  return rows.reduce(function (acc, row) {\n    var _a;\n    if (!row[GRID_GROUP_CHECK]) {\n      if (currentGroupExpanded) {\n        acc.push(row);\n      } else {\n        acc[acc.length - 1][GRID_GROUP_COLLAPSED_ROWS].push(row);\n      }\n      return acc;\n    }\n    var groupLevel = groupingColumnNames.indexOf(row.groupedBy);\n    if (groupLevel > currentGroupLevel && !currentGroupExpanded) {\n      return acc;\n    }\n    currentGroupExpanded = expandedGroupsSet.has(row.compoundKey) || isExporting;\n    currentGroupLevel = groupLevel;\n    if (currentGroupExpanded) {\n      acc.push(row);\n    } else {\n      acc.push(__assign(__assign({}, row), (_a = {}, _a[GRID_GROUP_COLLAPSED_ROWS] = [], _a)));\n    }\n    return acc;\n  }, []);\n};\nvar groupCollapsedRowsGetter = function (getCollapsedRows) {\n  return function (row) {\n    return row[GRID_GROUP_COLLAPSED_ROWS] || getCollapsedRows && getCollapsedRows(row);\n  };\n};\nvar getCustomGroups = function (rows, grouping, keyPrefix, getChildGroups, rootRows) {\n  var groupedBy = grouping.columnName;\n  return getChildGroups(rows, grouping, rootRows).map(function (_a) {\n    var _b;\n    var key = _a.key,\n      _c = _a.value,\n      value = _c === void 0 ? key : _c,\n      childRows = _a.childRows;\n    return _b = {\n      groupedBy: groupedBy,\n      compoundKey: \"\" + keyPrefix + key,\n      key: key,\n      value: value\n    }, _b[GRID_GROUP_CHECK] = true, _b[GRID_GROUP_LEVEL_KEY] = GRID_GROUP_TYPE.toString() + \"_\" + groupedBy, _b.childRows = childRows, _b;\n  });\n};\nvar customGroupedRows = function (rows, grouping, getChildGroups, rootRows) {\n  if (rootRows === void 0) {\n    rootRows = rows;\n  }\n  var groupsGetter = function (currentRows, currentGrouping, prefix) {\n    return getCustomGroups(currentRows, currentGrouping, prefix, getChildGroups, rootRows);\n  };\n  return getGroupRows(rows, grouping, groupsGetter);\n};\nvar customGroupingRowIdGetter = function (getRowId, rows) {\n  var firstRow = rows.find(function (row) {\n    return !row[GRID_GROUP_CHECK];\n  });\n  if (!firstRow || getRowId(firstRow) !== undefined) {\n    return getRowId;\n  }\n  var map = new Map(rows.filter(function (row) {\n    return !row[GRID_GROUP_CHECK];\n  }).map(function (row, rowIndex) {\n    return [row, rowIndex];\n  }));\n  return function (row) {\n    return map.get(row);\n  };\n};\nvar groupingPanelItems = function (columns, grouping, draftGrouping) {\n  var items = draftGrouping.map(function (_a) {\n    var columnName = _a.columnName;\n    return {\n      column: columns.find(function (c) {\n        return c.name === columnName;\n      }),\n      draft: !grouping.some(function (columnGrouping) {\n        return columnGrouping.columnName === columnName;\n      })\n    };\n  });\n  grouping.forEach(function (_a, index) {\n    var columnName = _a.columnName;\n    if (draftGrouping.some(function (columnGrouping) {\n      return columnGrouping.columnName === columnName;\n    })) return;\n    items.splice(index, 0, {\n      column: columns.find(function (c) {\n        return c.name === columnName;\n      }),\n      draft: true\n    });\n  });\n  return items;\n};\nvar setCurrentPage = function (prevPage, page) {\n  return page;\n};\nvar setPageSize = function (prevPageSize, size) {\n  return size;\n};\nvar clamp = function (value, max) {\n  return Math.max(Math.min(value, max), 0);\n};\n\n// tslint:disable-next-line:max-line-length\nvar PAGE_HEADERS_OVERFLOW_ERROR = 'Max row level exceeds the page size. Consider increasing the page size.';\nvar paginatedRows = function (rows, pageSize, page) {\n  return pageSize ? rows.slice(pageSize * page, pageSize * (page + 1)) : rows;\n};\nvar rowsWithPageHeaders = function (rows, pageSize, getRowLevelKey) {\n  if (!pageSize || !getRowLevelKey) return rows;\n  var result = rows.slice();\n  var headerRows = [];\n  var currentIndex = 0;\n  var _loop_1 = function () {\n    var row = result[currentIndex];\n    var levelKey = getRowLevelKey(row);\n    if (levelKey) {\n      var headerIndex = headerRows.findIndex(function (headerRow) {\n        return getRowLevelKey(headerRow) === levelKey;\n      });\n      // tslint:disable-next-line:prefer-conditional-expression\n      if (headerIndex === -1) {\n        headerRows = __spread(headerRows, [row]);\n      } else {\n        headerRows = __spread(headerRows.slice(0, headerIndex), [row]);\n      }\n      if (headerRows.length >= pageSize) {\n        throw new Error(PAGE_HEADERS_OVERFLOW_ERROR);\n      }\n    }\n    var indexInPage = currentIndex % pageSize;\n    if (indexInPage < headerRows.length && row !== headerRows[indexInPage]) {\n      result = __spread(result.slice(0, currentIndex), [headerRows[indexInPage]], result.slice(currentIndex));\n    }\n    currentIndex += 1;\n  };\n  while (result.length > currentIndex) {\n    _loop_1();\n  }\n  return result;\n};\nvar rowCount = function (rows) {\n  return rows.length;\n};\nvar pageCount = function (count, pageSize) {\n  return pageSize ? Math.ceil(count / pageSize) : 1;\n};\nvar currentPage = function (page, totalCount, pageSize, setCurrentPage) {\n  var totalPages = pageCount(totalCount, pageSize);\n  var adjustedCurrentPage = clamp(page, totalPages - 1);\n  if (page !== adjustedCurrentPage) {\n    setTimeout(function () {\n      return setCurrentPage(adjustedCurrentPage);\n    });\n  }\n  return adjustedCurrentPage;\n};\nvar firstRowOnPage = function (currentPage, pageSize, totalCount) {\n  if (totalCount === 0) {\n    return 0;\n  }\n  return pageSize ? currentPage * pageSize + 1 : 1;\n};\nvar lastRowOnPage = function (currentPage, pageSize, totalRowCount) {\n  var result = totalRowCount;\n  if (pageSize) {\n    var index = (currentPage + 1) * pageSize;\n    result = index > totalRowCount ? totalRowCount : index;\n  }\n  return result;\n};\nvar calculateStartPage = function (currentPage, maxButtonCount, totalPageCount) {\n  return Math.max(Math.min(currentPage - Math.floor(maxButtonCount / 2), totalPageCount - maxButtonCount + 1), 1);\n};\nvar toggle = function (source, items, state) {\n  var itemsSet = new Set(items);\n  var sourceState = state;\n  if (sourceState === undefined) {\n    var availableSelection = source.filter(function (item) {\n      return itemsSet.has(item);\n    });\n    sourceState = availableSelection.length !== itemsSet.size;\n  }\n  if (sourceState) {\n    var sourceSet_1 = new Set(source);\n    return __spread(source, items.filter(function (item) {\n      return !sourceSet_1.has(item);\n    }));\n  }\n  return source.filter(function (item) {\n    return !itemsSet.has(item);\n  });\n};\nvar toggleSelection = function (selection, _a) {\n  var rowIds = _a.rowIds,\n    state = _a.state;\n  return toggle(selection, rowIds, state);\n};\nvar rowsWithAvailableToSelect = function (rows, getRowId, isGroupRow) {\n  var dataRows = rows;\n  if (isGroupRow) {\n    dataRows = dataRows.filter(function (row) {\n      return !isGroupRow(row);\n    });\n  }\n  return {\n    rows: rows,\n    availableToSelect: dataRows.map(function (row) {\n      return getRowId(row);\n    })\n  };\n};\nvar someSelected = function (_a, selection) {\n  var availableToSelect = _a.availableToSelect;\n  var selectionSet = new Set(selection);\n  return availableToSelect.length !== 0 && selectionSet.size !== 0 && availableToSelect.some(function (elem) {\n    return selectionSet.has(elem);\n  }) && availableToSelect.some(function (elem) {\n    return !selectionSet.has(elem);\n  });\n};\nvar allSelected = function (_a, selection) {\n  var availableToSelect = _a.availableToSelect;\n  var selectionSet = new Set(selection);\n  return selectionSet.size !== 0 && availableToSelect.length !== 0 && !availableToSelect.some(function (elem) {\n    return !selectionSet.has(elem);\n  });\n};\nvar unwrapSelectedRows = function (_a) {\n  var rows = _a.rows;\n  return rows;\n};\nvar startEditRows = function (prevEditingRowIds, _a) {\n  var rowIds = _a.rowIds;\n  return __spread(prevEditingRowIds, rowIds);\n};\nvar stopEditRows = function (prevEditingRowIds, _a) {\n  var rowIds = _a.rowIds;\n  var rowIdSet = new Set(rowIds);\n  return prevEditingRowIds.filter(function (id) {\n    return !rowIdSet.has(id);\n  });\n};\nvar startEditCells = function (prevEditingCells, _a) {\n  var editingCells = _a.editingCells;\n  return __spread(prevEditingCells, editingCells);\n};\nvar stopEditCells = function (prevEditingCells, _a) {\n  var editingCells = _a.editingCells;\n  return prevEditingCells.filter(function (_a) {\n    var rowId = _a.rowId,\n      columnName = _a.columnName;\n    return !editingCells.some(function (_a) {\n      var currentRowId = _a.rowId,\n        currentColumnName = _a.columnName;\n      return currentRowId === rowId && currentColumnName === columnName;\n    });\n  });\n};\nvar addRow = function (addedRows, _a) {\n  var _b = _a === void 0 ? {\n      row: {}\n    } : _a,\n    row = _b.row;\n  return __spread(addedRows, [row]);\n};\nvar changeAddedRow = function (addedRows, _a) {\n  var rowId = _a.rowId,\n    change = _a.change;\n  var result = addedRows.slice();\n  result[rowId] = __assign(__assign({}, result[rowId]), change);\n  return result;\n};\nvar cancelAddedRows = function (addedRows, _a) {\n  var rowIds = _a.rowIds;\n  var result = [];\n  var indexSet = new Set(rowIds);\n  addedRows.forEach(function (row, index) {\n    if (!indexSet.has(index)) {\n      result.push(row);\n    }\n  });\n  return result;\n};\nvar changeRow = function (prevRowChanges, _a) {\n  var _b;\n  var rowId = _a.rowId,\n    change = _a.change;\n  var prevChange = prevRowChanges[rowId] || {};\n  return __assign(__assign({}, prevRowChanges), (_b = {}, _b[rowId] = __assign(__assign({}, prevChange), change), _b));\n};\nvar cancelChanges = function (prevRowChanges, _a) {\n  var rowIds = _a.rowIds;\n  var result = __assign({}, prevRowChanges);\n  rowIds.forEach(function (rowId) {\n    delete result[rowId];\n  });\n  return result;\n};\nvar deleteRows = function (deletedRowIds, _a) {\n  var rowIds = _a.rowIds;\n  return __spread(deletedRowIds, rowIds);\n};\nvar cancelDeletedRows = function (deletedRowIds, _a) {\n  var rowIds = _a.rowIds;\n  var rowIdSet = new Set(rowIds);\n  return deletedRowIds.filter(function (rowId) {\n    return !rowIdSet.has(rowId);\n  });\n};\nvar changedRowsByIds = function (changes, rowIds) {\n  var result = {};\n  rowIds.forEach(function (rowId) {\n    result[rowId] = changes[rowId];\n  });\n  return result;\n};\nvar addedRowsByIds = function (addedRows, rowIds) {\n  var rowIdSet = new Set(rowIds);\n  var result = [];\n  addedRows.forEach(function (row, index) {\n    if (rowIdSet.has(index)) {\n      result.push(row);\n    }\n  });\n  return result;\n};\nvar defaultCreateRowChange = function (row, value, columnName) {\n  var _a;\n  return _a = {}, _a[columnName] = value, _a;\n};\nvar createRowChangeGetter = function (createRowChange, columnExtensions) {\n  if (createRowChange === void 0) {\n    createRowChange = defaultCreateRowChange;\n  }\n  if (columnExtensions === void 0) {\n    columnExtensions = [];\n  }\n  var map = columnExtensions.reduce(function (acc, columnExtension) {\n    if (columnExtension.createRowChange) {\n      acc[columnExtension.columnName] = columnExtension.createRowChange;\n    }\n    return acc;\n  }, {});\n  return function (row, value, columnName) {\n    if (map[columnName]) {\n      return map[columnName](row, value, columnName);\n    }\n    return createRowChange(row, value, columnName);\n  };\n};\nvar getRowChange = function (rowChanges, rowId) {\n  return rowChanges[rowId] || {};\n};\nvar TABLE_REORDERING_TYPE = Symbol('reordering');\nvar changeColumnOrder = function (order, _a) {\n  var sourceColumnName = _a.sourceColumnName,\n    targetColumnName = _a.targetColumnName;\n  var sourceColumnIndex = order.indexOf(sourceColumnName);\n  var targetColumnIndex = order.indexOf(targetColumnName);\n  var newOrder = slice(order);\n  newOrder.splice(sourceColumnIndex, 1);\n  newOrder.splice(targetColumnIndex, 0, sourceColumnName);\n  return newOrder;\n};\nvar TABLE_DATA_TYPE = Symbol('data');\nvar TABLE_NODATA_TYPE = Symbol('nodata');\nvar TABLE_FLEX_TYPE = Symbol('flex');\nvar orderedColumns = function (tableColumns, order) {\n  if (tableColumns === void 0) {\n    tableColumns = [];\n  }\n  return mergeSort(tableColumns, function (a, b) {\n    if (a.type !== TABLE_DATA_TYPE || b.type !== TABLE_DATA_TYPE) return 0;\n    var aPos = order.indexOf(a.column.name);\n    var bPos = order.indexOf(b.column.name);\n    return aPos - bPos;\n  });\n};\nvar tableHeaderRowsWithReordering = function (tableHeaderRows) {\n  return __spread(tableHeaderRows, [{\n    key: TABLE_REORDERING_TYPE.toString(),\n    type: TABLE_REORDERING_TYPE,\n    height: 0\n  }]);\n};\nvar draftOrder = function (order, sourceColumnIndex, targetColumnIndex) {\n  if (sourceColumnIndex === -1 || targetColumnIndex === -1 || sourceColumnIndex === targetColumnIndex) {\n    return order;\n  }\n  var result = slice(order);\n  var sourceColumn = order[sourceColumnIndex];\n  result.splice(sourceColumnIndex, 1);\n  result.splice(targetColumnIndex, 0, sourceColumn);\n  return result;\n};\nvar getColumnWidth = function (columnWidths, name, _a) {\n  var columnName = _a.columnName,\n    cachedWidths = _a.cachedWidths,\n    shift = _a.shift,\n    minColumnWidth = _a.minColumnWidth,\n    maxColumnWidth = _a.maxColumnWidth,\n    _b = _a.columnExtensions,\n    columnExtensions = _b === void 0 ? [] : _b;\n  var change = name === columnName ? shift : -shift;\n  var column = columnWidths.find(function (elem) {\n    return elem.columnName === name;\n  });\n  var extension = columnExtensions.find(function (elem) {\n    return elem.columnName === name;\n  });\n  var width = typeof column.width === 'number' ? column.width : cachedWidths[name];\n  var minWidth = extension && extension.minWidth >= 0 ? extension.minWidth : minColumnWidth;\n  var maxWidth = extension && extension.maxWidth >= 0 ? extension.maxWidth : maxColumnWidth;\n  var size = Math.max(minWidth, Math.min(width + change, maxWidth));\n  return {\n    width: width,\n    size: size\n  };\n};\nvar getColumnSizes = function (columnWidths, payload) {\n  var columnName = payload.columnName,\n    nextColumnName = payload.nextColumnName,\n    resizingMode = payload.resizingMode,\n    shift = payload.shift;\n  var _a = getColumnWidth(columnWidths, columnName, payload),\n    width = _a.width,\n    size = _a.size;\n  if (resizingMode === 'nextColumn') {\n    var _b = getColumnWidth(columnWidths, nextColumnName, payload),\n      nextWidth = _b.width,\n      nextSize = _b.size;\n    if (size + nextSize !== width + nextWidth) {\n      var moreThanLimit = size + nextSize > width + nextWidth;\n      var columnExpand = shift > 0;\n      if (moreThanLimit !== columnExpand) {\n        return {\n          size: size,\n          nextSize: width + nextWidth - size\n        };\n      }\n      return {\n        size: width + nextWidth - nextSize,\n        nextSize: nextSize\n      };\n    }\n    return {\n      size: size,\n      nextSize: nextSize\n    };\n  }\n  return {\n    size: size\n  };\n};\nvar isValidValue = function (value, validUnits) {\n  var numb = parseInt(value, 10);\n  var unit = numb ? value.substr(numb.toString().length) : value;\n  var sizeIsAuto = isNaN(numb) && unit === 'auto';\n  var sizeIsValid = numb >= 0 && validUnits.some(function (validUnit) {\n    return validUnit === unit;\n  });\n  return sizeIsAuto || sizeIsValid;\n};\nvar convertWidth = function (value) {\n  if (typeof value === 'string') {\n    var numb = parseInt(value, 10);\n    if (value.substr(numb.toString().length).length > 0) {\n      return value;\n    }\n    return numb;\n  }\n  return value;\n};\nvar VALID_UNITS = ['px', '%', 'em', 'rem', 'vm', 'vh', 'vmin', 'vmax', ''];\nvar NOT_FOR_WIDGET_UNITS = ['%'];\n/* tslint:disable max-line-length */\nvar COLUMN_RESIZING_ERROR = 'The columnWidths property of the TableColumnResizing plugin is given an invalid value.';\nvar specifyWidths = function (tableColumns, widths, resizingMode, onError) {\n  if (resizingMode !== 'widget' && resizingMode !== 'nextColumn') {\n    onError();\n  }\n  if (!widths.length) return tableColumns;\n  return tableColumns.reduce(function (acc, tableColumn) {\n    if (tableColumn.type === TABLE_DATA_TYPE) {\n      var columnName_1 = tableColumn.column.name;\n      var column = widths.find(function (el) {\n        return el.columnName === columnName_1;\n      });\n      var width = column && column.width;\n      if (typeof width !== 'number') {\n        if (width === undefined) {\n          onError();\n        } else if (!isValidValue(width, VALID_UNITS)) {\n          onError();\n        } else if (resizingMode === 'widget' && isValidValue(width, NOT_FOR_WIDGET_UNITS)) {\n          onError();\n        }\n      } else if (width < 0) {\n        onError();\n      }\n      if (width === undefined) {\n        acc.push(tableColumn);\n      } else {\n        acc.push(__assign(__assign({}, tableColumn), {\n          width: convertWidth(width)\n        }));\n      }\n    } else {\n      acc.push(tableColumn);\n    }\n    return acc;\n  }, []);\n};\nvar tableColumnsWithWidths = function (tableColumns, columnWidths, resizingMode) {\n  return specifyWidths(tableColumns, columnWidths, resizingMode, throwError);\n};\nvar tableColumnsWithDraftWidths = function (tableColumns, draftColumnWidths, resizingMode) {\n  return specifyWidths(tableColumns, draftColumnWidths, resizingMode, function () {});\n};\nvar throwError = function () {\n  throw new Error(COLUMN_RESIZING_ERROR);\n};\nvar changeTableColumnWidth = function (state, payload) {\n  var columnWidths = state.columnWidths;\n  var columnName = payload.columnName,\n    nextColumnName = payload.nextColumnName,\n    resizingMode = payload.resizingMode;\n  var nextColumnWidth = slice(columnWidths);\n  var index = nextColumnWidth.findIndex(function (elem) {\n    return elem.columnName === columnName;\n  });\n  var nextIndex = nextColumnWidth.findIndex(function (elem) {\n    return elem.columnName === nextColumnName;\n  });\n  var _a = getColumnSizes(columnWidths, payload),\n    size = _a.size,\n    nextSize = _a.nextSize;\n  nextColumnWidth.splice(index, 1, {\n    columnName: columnName,\n    width: size\n  });\n  if (resizingMode === 'nextColumn') {\n    nextColumnWidth.splice(nextIndex, 1, {\n      columnName: nextColumnName,\n      width: nextSize\n    });\n  }\n  return {\n    columnWidths: nextColumnWidth\n  };\n};\nvar draftTableColumnWidth = function (state, payload) {\n  var columnWidths = state.columnWidths;\n  var columnName = payload.columnName,\n    nextColumnName = payload.nextColumnName,\n    resizingMode = payload.resizingMode;\n  var _a = getColumnSizes(columnWidths, payload),\n    size = _a.size,\n    nextSize = _a.nextSize;\n  if (resizingMode === 'nextColumn') {\n    return {\n      draftColumnWidths: [{\n        columnName: columnName,\n        width: size\n      }, {\n        columnName: nextColumnName,\n        width: nextSize\n      }]\n    };\n  }\n  return {\n    draftColumnWidths: [{\n      columnName: columnName,\n      width: size\n    }]\n  };\n};\nvar cancelTableColumnWidthDraft = function () {\n  return {\n    draftColumnWidths: []\n  };\n};\nvar TABLE_EDIT_COMMAND_TYPE = Symbol('editCommand');\nvar TABLE_ADDED_TYPE = Symbol('added');\nvar TABLE_EDIT_TYPE = Symbol('edit');\nvar TABLE_HEADING_TYPE = Symbol('heading');\nvar isHeadingEditCommandsTableCell = function (tableRow, tableColumn) {\n  return tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_EDIT_COMMAND_TYPE;\n};\nvar isEditCommandsTableCell = function (tableRow, tableColumn) {\n  return (tableRow.type === TABLE_DATA_TYPE || tableRow.type === TABLE_ADDED_TYPE || tableRow.type === TABLE_EDIT_TYPE) && tableColumn.type === TABLE_EDIT_COMMAND_TYPE;\n};\nvar tableColumnsWithEditing = function (tableColumns, width) {\n  return __spread([{\n    width: convertWidth(width),\n    key: TABLE_EDIT_COMMAND_TYPE.toString(),\n    type: TABLE_EDIT_COMMAND_TYPE\n  }], tableColumns);\n};\nvar isEditTableCell = function (tableRow, tableColumn) {\n  return (tableRow.type === TABLE_ADDED_TYPE || tableRow.type === TABLE_EDIT_TYPE) && tableColumn.type === TABLE_DATA_TYPE;\n};\nvar isAddedTableRow = function (tableRow) {\n  return tableRow.type === TABLE_ADDED_TYPE;\n};\nvar isEditTableRow = function (tableRow) {\n  return tableRow.type === TABLE_EDIT_TYPE;\n};\nvar tableRowsWithEditing = function (tableRows, editingRowIds, addedRows, rowHeight) {\n  var rowIds = new Set(editingRowIds);\n  var editedTableRows = tableRows.map(function (tableRow) {\n    return tableRow.type === TABLE_DATA_TYPE && rowIds.has(tableRow.rowId) ? __assign(__assign({}, tableRow), {\n      type: TABLE_EDIT_TYPE,\n      height: rowHeight\n    }) : tableRow;\n  });\n  var addedTableRows = addedRows.map(function (row, rowIndex) {\n    return {\n      row: row,\n      key: TABLE_ADDED_TYPE.toString() + \"_\" + rowIndex,\n      type: TABLE_ADDED_TYPE,\n      rowId: rowIndex,\n      height: rowHeight\n    };\n  });\n  return __spread(slice(addedTableRows).reverse(), editedTableRows);\n};\nvar rowsWithEditingCells = function (tableBodyRows, editingCells) {\n  return tableBodyRows.map(function (row) {\n    var rowId = row.rowId,\n      type = row.type;\n    if (rowId !== undefined && type === TABLE_DATA_TYPE && editingCells.some(function (elem) {\n      return elem.rowId === rowId;\n    })) {\n      return __assign(__assign({}, row), {\n        hasEditCell: true\n      });\n    }\n    return row;\n  });\n};\nvar columnsWithEditingCells = function (tableColumns, editingCells) {\n  return tableColumns.map(function (tableColumn) {\n    var columnName = tableColumn.column ? tableColumn.column.name : undefined;\n    if (columnName !== undefined && editingCells.some(function (elem) {\n      return elem.columnName === columnName;\n    })) {\n      return __assign(__assign({}, tableColumn), {\n        hasEditCell: true\n      });\n    }\n    return tableColumn;\n  });\n};\nvar TABLE_FILTER_TYPE = Symbol('filter');\nvar DEFAULT_FILTER_OPERATIONS = ['contains', 'notContains', 'startsWith', 'endsWith', 'equal', 'notEqual'];\nvar isFilterTableCell = function (tableRow, tableColumn) {\n  return tableRow.type === TABLE_FILTER_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n};\nvar isFilterTableRow = function (tableRow) {\n  return tableRow.type === TABLE_FILTER_TYPE;\n};\nvar getColumnFilterOperations = function (getAvailableFilterOperations, columnName) {\n  return getAvailableFilterOperations && getAvailableFilterOperations(columnName) || DEFAULT_FILTER_OPERATIONS;\n};\nvar isFilterValueEmpty = function (value) {\n  return value === undefined || !String(value).length;\n};\nvar getSelectedFilterOperation = function (filterOperations, columnName, columnFilter, columnFilterOperations) {\n  if (columnFilter && columnFilter.operation) {\n    return columnFilter.operation;\n  }\n  if (filterOperations[columnName]) {\n    return filterOperations[columnName];\n  }\n  return columnFilterOperations[0];\n};\nvar tableHeaderRowsWithFilter = function (headerRows, rowHeight) {\n  return __spread(headerRows, [{\n    key: TABLE_FILTER_TYPE.toString(),\n    type: TABLE_FILTER_TYPE,\n    height: rowHeight\n  }]);\n};\nvar TABLE_GROUP_TYPE = Symbol('group');\nvar TABLE_STUB_TYPE = Symbol('stub');\nvar getVisibleBoundaryWithFixed = function (visibleBoundary, items) {\n  return items.reduce(function (acc, item, index) {\n    if (item.fixed && (index < visibleBoundary[0] || index > visibleBoundary[1])) {\n      acc.push([index, index]);\n    }\n    return acc;\n  }, [visibleBoundary]);\n};\nvar getVisibleBoundary = function (items, viewportStart, viewportSize, getItemSize, skipItems, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  var start;\n  var end;\n  var index = items[0] && items[0].rowId >= skipItems[0] ? 0 : skipItems[0];\n  var itemSize = getItemSize();\n  var beforePosition = offset !== 0 ? (offset - skipItems[0]) * itemSize : 0;\n  var viewportEnd = viewportStart + viewportSize;\n  while (end === undefined && index < items.length) {\n    var item = items[index];\n    var afterPosition = beforePosition + getItemSize(item);\n    var isVisible = beforePosition >= viewportStart && beforePosition < viewportEnd || afterPosition > viewportStart && afterPosition <= viewportEnd || beforePosition < viewportStart && afterPosition > viewportEnd;\n    if (isVisible && start === undefined) {\n      start = index;\n    }\n    if (!isVisible && start !== undefined) {\n      end = index - 1;\n      break;\n    }\n    index += 1;\n    beforePosition = afterPosition;\n  }\n  if (start !== undefined && end === undefined) {\n    end = index - 1;\n  }\n  end = end === undefined ? 0 : end;\n  start = start === undefined ? 0 : start;\n  return [start + offset, end + offset];\n};\nvar getRenderBoundary = function (itemsCount, visibleBoundary, overscan) {\n  var _a = __read(visibleBoundary, 2),\n    start = _a[0],\n    end = _a[1];\n  start = Math.max(0, start - overscan);\n  end = Math.min(itemsCount - 1, end + overscan);\n  return [start, end];\n};\nvar getColumnBoundaries = function (columns, left, width, getColumnWidth) {\n  return getVisibleBoundaryWithFixed(getColumnsRenderBoundary(columns.length, getVisibleBoundary(columns, left, width, getColumnWidth, [0, 0], 0)), columns);\n};\nvar getRowsVisibleBoundary = function (rows, top, height, getRowHeight, skipItems, offset, isDataRemote) {\n  var rowHeight = getRowHeight();\n  var beforePosition = offset !== 0 ? (offset - skipItems[0]) * rowHeight : 0;\n  var noVisibleRowsLoaded = rowHeight > 0 && beforePosition + rows.length * rowHeight < top || top < beforePosition;\n  var boundaries;\n  if (isDataRemote && noVisibleRowsLoaded) {\n    var topIndex = Math.round(top / rowHeight) + skipItems[0];\n    boundaries = [topIndex, topIndex];\n  } else {\n    boundaries = getVisibleBoundary(rows, top, height, getRowHeight, skipItems, offset);\n  }\n  return boundaries;\n};\nvar getColumnsRenderBoundary = function (columnCount, visibleBoundary) {\n  return getRenderBoundary(columnCount, visibleBoundary, 1);\n};\nvar getRowsRenderBoundary = function (rowsCount, visibleBoundary) {\n  return getRenderBoundary(rowsCount, visibleBoundary, 3);\n};\nvar getSpanBoundary = function (items, visibleBoundaries, getItemSpan) {\n  return visibleBoundaries.map(function (visibleBoundary) {\n    var endIndex = Math.min(visibleBoundary[1], items.length - 1);\n    var end = endIndex;\n    var start = visibleBoundary[0] <= end ? visibleBoundary[0] : 0;\n    for (var index = 0; index <= endIndex; index += 1) {\n      var span = getItemSpan(items[index]);\n      if (index < visibleBoundary[0] && index + span > visibleBoundary[0]) {\n        start = index;\n      }\n      if (index + (span - 1) > visibleBoundary[1]) {\n        end = index + (span - 1);\n      }\n    }\n    return [start, end];\n  });\n};\nvar collapseBoundaries = function (itemsCount, visibleBoundaries, spanBoundaries) {\n  var breakpoints = new Set([0, itemsCount]);\n  spanBoundaries.forEach(function (rowBoundaries) {\n    return rowBoundaries.forEach(function (boundary) {\n      breakpoints.add(boundary[0]);\n      // next interval starts after span end point\n      breakpoints.add(Math.min(boundary[1] + 1, itemsCount));\n    });\n  });\n  visibleBoundaries.filter(function (boundary) {\n    return boundary.every(function (bound) {\n      return 0 <= bound && bound < itemsCount;\n    });\n  }).forEach(function (boundary) {\n    for (var point = boundary[0]; point <= boundary[1]; point += 1) {\n      breakpoints.add(point);\n    }\n    if (boundary[1] + 1 < itemsCount) {\n      // close last visible point\n      breakpoints.add(boundary[1] + 1);\n    }\n  });\n  var bp = __spread(breakpoints).sort(function (a, b) {\n    return a - b;\n  });\n  var bounds = [];\n  for (var i = 0; i < bp.length - 1; i += 1) {\n    bounds.push([bp[i], bp[i + 1] - 1]);\n  }\n  return bounds;\n};\nvar getItemsSize = function (items, startIndex, endIndex, getItemSize) {\n  var size = 0;\n  for (var i = startIndex; i <= endIndex; i += 1) {\n    size += getItemSize(items[i]);\n  }\n  return size;\n};\nvar getCollapsedColumns = function (columns, visibleBoundaries, boundaries, getColumnWidth) {\n  var collapsedColumns = [];\n  boundaries.forEach(function (boundary) {\n    var isVisible = visibleBoundaries.reduce(function (acc, visibleBoundary) {\n      return acc || visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1];\n    }, false);\n    if (isVisible) {\n      var column = columns[boundary[0]];\n      collapsedColumns.push(__assign(__assign({}, column), {\n        width: column.type === TABLE_FLEX_TYPE ? undefined : getColumnWidth(column)\n      }));\n    } else {\n      collapsedColumns.push({\n        key: TABLE_STUB_TYPE.toString() + \"_\" + boundary[0] + \"_\" + boundary[1],\n        type: TABLE_STUB_TYPE,\n        width: getItemsSize(columns, boundary[0], boundary[1], getColumnWidth)\n      });\n    }\n  });\n  return collapsedColumns;\n};\nvar getCollapsedRows = function (rows, visibleBoundary, boundaries, skipItems, getRowHeight, getCells, offset) {\n  var collapsedRows = [];\n  boundaries.forEach(function (boundary) {\n    var isVisible = visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1];\n    if (isVisible) {\n      var row = rows[boundary[0] - offset];\n      collapsedRows.push({\n        row: row,\n        cells: getCells(row)\n      });\n    } else {\n      var row = {};\n      collapsedRows.push({\n        row: {\n          key: TABLE_STUB_TYPE.toString() + \"_\" + boundary[0] + \"_\" + boundary[1],\n          type: TABLE_STUB_TYPE,\n          height: calculateRowHeight(rows, skipItems, getRowHeight, boundary[0], boundary[1])\n        },\n        cells: getCells(row)\n      });\n    }\n  });\n  return collapsedRows;\n};\nvar calculateRowHeight = function (rows, skipItems, getRowHeight, bound1, bound2) {\n  if (bound1 === 0) {\n    var end = bound2;\n    if (rows.length && bound2 > rows[rows.length - 1].rowId) {\n      end = bound2 - skipItems[1];\n    }\n    return getItemsSize(rows, skipItems[0], end, getRowHeight);\n  }\n  return getItemsSize(rows, bound1, bound2 - skipItems[1], getRowHeight);\n};\nvar getCollapsedCells = function (row, columns, spanBoundaries, boundaries, getColSpan) {\n  var collapsedCells = [];\n  var index = 0;\n  var _loop_1 = function () {\n    var boundary = boundaries[index];\n    var isSpan = spanBoundaries.reduce(function (acc, spanBoundary) {\n      return acc || spanBoundary[0] <= boundary[0] && boundary[1] <= spanBoundary[1];\n    }, false);\n    if (isSpan) {\n      var column = columns[boundary[0]];\n      var realColSpan = getColSpan(row, column);\n      if (realColSpan + index - 1 !== columns.length) {\n        var realColSpanEnd_1 = realColSpan + boundary[0] - 1;\n        var colSpanEnd = boundaries.findIndex(function (colSpanBoundary) {\n          return colSpanBoundary[0] <= realColSpanEnd_1 && realColSpanEnd_1 <= colSpanBoundary[1];\n        });\n        collapsedCells.push({\n          column: column,\n          colSpan: colSpanEnd - index + 1\n        });\n      } else {\n        collapsedCells.push({\n          column: column,\n          colSpan: realColSpan\n        });\n      }\n      index += 1;\n    } else {\n      collapsedCells.push({\n        column: {\n          key: TABLE_STUB_TYPE.toString() + \"_\" + boundary[0] + \"_\" + boundary[1],\n          type: TABLE_STUB_TYPE\n        },\n        colSpan: 1\n      });\n      index += 1;\n    }\n  };\n  while (index < boundaries.length) {\n    _loop_1();\n  }\n  return collapsedCells;\n};\nvar getVisibleColumnBoundaries = function (rows, boundaries, columns, columnsVisibleBoundary, getColSpan) {\n  var rowSpanBoundaries = rows.slice(boundaries[0], boundaries[1] + 1).map(function (row) {\n    return getSpanBoundaryByRow(row, columns, columnsVisibleBoundary, getColSpan);\n  });\n  return collapseBoundaries(columns.length, columnsVisibleBoundary, rowSpanBoundaries);\n};\nvar getCollapsedGrid = function (_a) {\n  var rows = _a.rows,\n    columns = _a.columns,\n    rowsVisibleBoundary = _a.rowsVisibleBoundary,\n    columnsVisibleBoundary = _a.columnsVisibleBoundary,\n    getColumnWidth = _a.getColumnWidth,\n    getRowHeight = _a.getRowHeight,\n    getColSpan = _a.getColSpan,\n    totalRowCount = _a.totalRowCount,\n    offset = _a.offset;\n  if (!columns.length) {\n    return {\n      columns: [],\n      rows: []\n    };\n  }\n  var boundaries = rowsVisibleBoundary || [0, rows.length - 1 || 1];\n  var columnBoundaries = getVisibleColumnBoundaries(rows, boundaries, columns, columnsVisibleBoundary, getColSpan);\n  var rowBoundaries = collapseBoundaries(totalRowCount, [boundaries], []);\n  return {\n    columns: getCollapsedColumns(columns, columnsVisibleBoundary, columnBoundaries, getColumnWidth),\n    rows: getCollapsedRows(rows, boundaries, rowBoundaries, [0, 0], getRowHeight, function (row) {\n      return getCollapsedCells(row, columns, getSpanBoundaryByRow(row, columns, columnsVisibleBoundary, getColSpan), columnBoundaries, getColSpan);\n    }, offset)\n  };\n};\nvar getColumnWidthGetter = function (tableColumns, tableWidth, minColumnWidth) {\n  var colsHavingWidth = tableColumns.filter(function (col) {\n    return typeof col.width === 'number';\n  });\n  var columnsWidth = colsHavingWidth.reduce(function (acc, col) {\n    return acc + col.width;\n  }, 0);\n  var autoWidth = (tableWidth - columnsWidth) / (tableColumns.length - colsHavingWidth.length);\n  var autoColWidth = Math.max(autoWidth, minColumnWidth);\n  return function (column) {\n    if (column) {\n      return column.type === TABLE_FLEX_TYPE ? 0 : typeof column.width === 'number' ? column.width : autoColWidth;\n    }\n    return autoColWidth;\n  };\n};\nvar getSpanBoundaryByRow = function (row, columns, visibleColumns, getColSpan) {\n  return getSpanBoundary(columns, visibleColumns, function (column) {\n    return getColSpan(row, column);\n  });\n};\nvar getCollapsedGrids = function (_a) {\n  var headerRows = _a.headerRows,\n    bodyRows = _a.bodyRows,\n    footerRows = _a.footerRows,\n    columns = _a.columns,\n    loadedRowsStart = _a.loadedRowsStart,\n    totalRowCount = _a.totalRowCount,\n    getCellColSpan = _a.getCellColSpan,\n    viewport = _a.viewport,\n    skipItems = _a.skipItems,\n    getRowHeight = _a.getRowHeight,\n    getColumnWidth = _a.getColumnWidth;\n  if (!columns.length) {\n    return {\n      headerGrid: {\n        columns: [],\n        rows: []\n      },\n      bodyGrid: {\n        columns: [],\n        rows: []\n      },\n      footerGrid: {\n        columns: [],\n        rows: []\n      }\n    };\n  }\n  var getColSpan = function (tableRow, tableColumn) {\n    return getCellColSpan({\n      tableRow: tableRow,\n      tableColumn: tableColumn,\n      tableColumns: columns\n    });\n  };\n  var getCollapsedGridRows = function (rows, rowsBoundary, columnsBoundary, rowCount, offset) {\n    if (rowCount === void 0) {\n      rowCount = rows.length;\n    }\n    if (offset === void 0) {\n      offset = 0;\n    }\n    return getCollapsedRows(rows, rowsBoundary, collapseBoundaries(rowCount, [rowsBoundary], []), skipItems, getRowHeight, function (row) {\n      return getCollapsedCells(row, columns, getSpanBoundaryByRow(row, columns, viewport.columns, getColSpan), columnsBoundary, getColSpan);\n    }, offset);\n  };\n  var rowsVisibleBoundary = adjustedRenderRowBounds(viewport.rows, bodyRows.length, loadedRowsStart);\n  var columnBoundaries = getVisibleColumnBoundaries(bodyRows, rowsVisibleBoundary, columns, viewport.columns, getColSpan);\n  var commonColumns = getCollapsedColumns(columns, viewport.columns, columnBoundaries, getColumnWidth);\n  return {\n    headerGrid: {\n      columns: commonColumns,\n      rows: getCollapsedGridRows(headerRows, getRowsRenderBoundary(headerRows.length, viewport.headerRows), columnBoundaries)\n    },\n    bodyGrid: {\n      columns: commonColumns,\n      rows: getCollapsedGridRows(bodyRows, rowsVisibleBoundary, columnBoundaries, totalRowCount || 1, loadedRowsStart)\n    },\n    footerGrid: {\n      columns: commonColumns,\n      rows: getCollapsedGridRows(footerRows, getRowsRenderBoundary(footerRows.length, viewport.footerRows), columnBoundaries)\n    }\n  };\n};\nvar adjustedRenderRowBounds = function (visibleBounds, rowCount, loadedRowsStart) {\n  var renderRowBoundaries = getRowsRenderBoundary(loadedRowsStart + rowCount, visibleBounds);\n  var adjustedInterval = intervalUtil.intersect({\n    start: renderRowBoundaries[0],\n    end: renderRowBoundaries[1]\n  }, {\n    start: loadedRowsStart,\n    end: loadedRowsStart + rowCount\n  });\n  return [adjustedInterval.start, adjustedInterval.end];\n};\nvar getGroupIndexByColumn = function (grouping, tableColumn) {\n  return grouping.findIndex(function (columnGrouping) {\n    return !!tableColumn.column && columnGrouping.columnName === tableColumn.column.name;\n  });\n};\nvar isIndentCell = function (tableRow, tableColumn, grouping) {\n  if (tableColumn.column && tableRow.row.groupedBy === tableColumn.column.name) return false;\n  var rowGroupIndex = grouping.findIndex(function (columnGrouping) {\n    return columnGrouping.columnName === tableRow.row.groupedBy;\n  });\n  var columnGroupIndex = getGroupIndexByColumn(grouping, tableColumn);\n  return columnGroupIndex < rowGroupIndex;\n};\nvar isGroupTableCell = function (tableRow, tableColumn) {\n  return !!(tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE && tableColumn.column && tableColumn.column.name === tableRow.row.groupedBy);\n};\nvar isGroupIndentTableCell = function (tableRow, tableColumn, grouping) {\n  return tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE && isIndentCell(tableRow, tableColumn, grouping);\n};\nvar isGroupIndentStubTableCell = function (tableRow, tableColumn, grouping) {\n  return tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_STUB_TYPE && isIndentCell(tableRow, tableColumn, grouping);\n};\nvar isGroupTableRow = function (tableRow) {\n  return tableRow.type === TABLE_GROUP_TYPE;\n};\nvar isGroupRowOrdinaryCell = function (tableRow, tableColumn) {\n  return isGroupTableRow(tableRow) && !isGroupTableCell(tableRow, tableColumn);\n};\nvar columnHasGroupRowSummary = function (tableColumn, groupSummaryItems) {\n  return !!(groupSummaryItems && groupSummaryItems.some(function (item) {\n    return !item.showInGroupFooter && item.alignByColumn && item.columnName === (tableColumn.column && tableColumn.column.name);\n  }));\n};\nvar isRowSummaryCell = function (tableRow, tableColumn, grouping, groupSummaryItems) {\n  return columnHasGroupRowSummary(tableColumn, groupSummaryItems) && !isGroupIndentTableCell(tableRow, tableColumn, grouping);\n};\nvar isPreviousCellContainSummary = function (tableRow, tableColumn, tableColumns, grouping, groupSummaryItems) {\n  var columnIndex = tableColumns.indexOf(tableColumn);\n  return columnIndex > 0 && isRowSummaryCell(tableRow, tableColumns[columnIndex - 1], grouping, groupSummaryItems);\n};\nvar calculateGroupCellIndent = function (tableColumn, grouping, indentWidth) {\n  return indentWidth * getGroupIndexByColumn(grouping, tableColumn);\n};\nvar sortAndSpliceColumns = function (tableColumns, firstVisibleColumnIndex) {\n  var groupColumns = tableColumns.filter(function (col) {\n    return col.type === TABLE_GROUP_TYPE;\n  });\n  var dataColumns = tableColumns.filter(function (col) {\n    return col.type === TABLE_DATA_TYPE;\n  });\n  var otherColumns = tableColumns.filter(function (col) {\n    return col.type !== TABLE_DATA_TYPE && col.type !== TABLE_GROUP_TYPE && col.type !== TABLE_FLEX_TYPE;\n  });\n  if (firstVisibleColumnIndex) {\n    var firstGroupIndex = tableColumns.indexOf(groupColumns[0]);\n    otherColumns.splice(0, Math.min(firstVisibleColumnIndex, firstGroupIndex));\n  }\n  return __spread(groupColumns, otherColumns, dataColumns);\n};\nvar tableColumnsWithDraftGrouping = function (tableColumns, grouping, draftGrouping, showColumnWhenGrouped) {\n  return tableColumns.reduce(function (acc, tableColumn) {\n    if (tableColumn.type !== TABLE_DATA_TYPE) {\n      acc.push(tableColumn);\n      return acc;\n    }\n    var columnName = tableColumn.column && tableColumn.column.name || '';\n    var columnGroupingExists = grouping.some(function (columnGrouping) {\n      return columnGrouping.columnName === columnName;\n    });\n    var columnDraftGroupingExists = draftGrouping.some(function (columnGrouping) {\n      return columnGrouping.columnName === columnName;\n    });\n    if (!columnGroupingExists && !columnDraftGroupingExists || showColumnWhenGrouped(columnName)) {\n      acc.push(tableColumn);\n    } else if (!columnGroupingExists && columnDraftGroupingExists || columnGroupingExists && !columnDraftGroupingExists) {\n      acc.push(__assign(__assign({}, tableColumn), {\n        draft: true\n      }));\n    }\n    return acc;\n    // tslint:disable-next-line: prefer-array-literal\n  }, []);\n};\nvar tableColumnsWithGrouping = function (columns, tableColumns, grouping, draftGrouping, indentColumnWidth, showColumnWhenGrouped) {\n  return __spread(grouping.map(function (columnGrouping) {\n    var groupedColumn = columns.find(function (column) {\n      return column.name === columnGrouping.columnName;\n    });\n    return {\n      key: TABLE_GROUP_TYPE.toString() + \"_\" + groupedColumn.name,\n      type: TABLE_GROUP_TYPE,\n      column: groupedColumn,\n      width: indentColumnWidth\n    };\n  }), tableColumnsWithDraftGrouping(tableColumns, grouping, draftGrouping, showColumnWhenGrouped));\n};\nvar tableRowsWithGrouping = function (tableRows, isGroupRow) {\n  return tableRows.map(function (tableRow) {\n    if (tableRow.type !== TABLE_DATA_TYPE || !isGroupRow(tableRow.row)) {\n      return tableRow;\n    }\n    return __assign(__assign({}, tableRow), {\n      key: TABLE_GROUP_TYPE.toString() + \"_\" + tableRow.row.compoundKey,\n      type: TABLE_GROUP_TYPE\n    });\n  });\n};\nvar isRowLevelSummary = function (groupSummaryItems, colName) {\n  return groupSummaryItems.some(function (item) {\n    return !item.showInGroupFooter && item.alignByColumn && item.columnName === colName;\n  });\n};\nvar groupSummaryChains = function (tableRow, tableColumns, groupSummaryItems, firstVisibleColumnIndex) {\n  var captionStarted = false;\n  return sortAndSpliceColumns(tableColumns, firstVisibleColumnIndex).reduce(function (acc, col) {\n    var colName = col.column && col.column.name;\n    var colKey = col.key;\n    var isStartOfGroupCaption = col.type === TABLE_GROUP_TYPE && tableRow.row.groupedBy === colName;\n    var isIndentColumn = col.type === TABLE_GROUP_TYPE && tableRow.row.groupedBy !== colName && !captionStarted;\n    if (isStartOfGroupCaption) {\n      captionStarted = true;\n    }\n    if (isStartOfGroupCaption || isIndentColumn) {\n      acc.push([colKey]);\n    } else if (groupSummaryItems && isRowLevelSummary(groupSummaryItems, colName)) {\n      acc.push([colKey]);\n      acc.push([]);\n    } else {\n      acc[acc.length - 1].push(colKey);\n    }\n    return acc;\n  }, [[]]);\n};\nvar tableGroupCellColSpanGetter = function (getTableCellColSpan, groupSummaryItems, firstVisibleColumnIndex) {\n  return function (params) {\n    var tableRow = params.tableRow,\n      tableColumns = params.tableColumns,\n      tableColumn = params.tableColumn;\n    if (tableRow.type === TABLE_GROUP_TYPE) {\n      var colKey_1 = tableColumn.key;\n      var chains = groupSummaryChains(tableRow, tableColumns, groupSummaryItems, firstVisibleColumnIndex);\n      var chain = chains.find(function (ch) {\n        return ch[0] === colKey_1;\n      });\n      if (chain) {\n        return chain.length;\n      }\n    }\n    return getTableCellColSpan(params);\n  };\n};\nvar isHeadingTableCell = function (tableRow, tableColumn) {\n  return tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n};\nvar isHeadingTableRow = function (tableRow) {\n  return tableRow.type === TABLE_HEADING_TYPE;\n};\nvar findChainByColumnIndex = function (chains, columnIndex) {\n  return chains.find(function (chain) {\n    return chain.start <= columnIndex && columnIndex < chain.start + chain.columns.length;\n  });\n};\nvar splitHeaderColumnChains = function (tableColumnChains, tableColumns, shouldSplitChain, extendChainProps) {\n  return tableColumnChains.map(function (row, rowIndex) {\n    return row.reduce(function (acc, chain) {\n      var currentChain = null;\n      chain.columns.forEach(function (col) {\n        var column = tableColumns.find(function (c) {\n          return c.key === col.key;\n        });\n        var isNewGroup = shouldSplitChain(currentChain, column, rowIndex);\n        if (isNewGroup) {\n          var start = currentChain ? currentChain.start + currentChain.columns.length : chain.start;\n          acc.push(__assign(__assign(__assign({}, chain), extendChainProps(column)), {\n            start: start,\n            columns: []\n          }));\n          currentChain = acc[acc.length - 1];\n        }\n        currentChain.columns.push(column);\n      });\n      return acc;\n    }, []);\n  });\n};\nvar generateSimpleChains = function (rows, columns) {\n  return rows.map(function () {\n    return [{\n      columns: columns,\n      start: 0\n    }];\n  });\n};\nvar nextColumnName = function (tableColumns, index) {\n  var isNextColumnHasName = index < tableColumns.length - 1 && tableColumns[index + 1].column;\n  return isNextColumnHasName ? tableColumns[index + 1].column.name : undefined;\n};\nvar getNextColumnName = function (tableColumns, columnName) {\n  var index = tableColumns.findIndex(function (elem) {\n    return elem.column && elem.column.name === columnName;\n  });\n  return index >= 0 ? nextColumnName(tableColumns, index) : undefined;\n};\nvar tableRowsWithHeading = function (headerRows) {\n  return __spread([{\n    key: TABLE_HEADING_TYPE.toString(),\n    type: TABLE_HEADING_TYPE\n  }], headerRows);\n};\nvar TABLE_BAND_TYPE = Symbol('band');\nvar BAND_GROUP_CELL = 'bandGroupCell';\nvar BAND_HEADER_CELL = 'bandHeaderCell';\nvar BAND_EMPTY_CELL = 'bandEmptyCell';\nvar BAND_DUPLICATE_RENDER = 'bandDuplicateRender';\nvar BAND_FILL_LEVEL_CELL = 'bandFillLevelCell';\nvar isBandedTableRow = function (tableRow) {\n  return tableRow.type === TABLE_BAND_TYPE;\n};\nvar isBandedOrHeaderRow = function (tableRow) {\n  return isBandedTableRow(tableRow) || tableRow.type === TABLE_HEADING_TYPE;\n};\nvar isNoDataColumn = function (columnType) {\n  return columnType !== TABLE_DATA_TYPE;\n};\nvar getColumnMeta = function (columnName, bands, tableRowLevel, key, level, title, result) {\n  if (key === void 0) {\n    key = '';\n  }\n  if (level === void 0) {\n    level = 0;\n  }\n  if (title === void 0) {\n    title = null;\n  }\n  if (result === void 0) {\n    result = null;\n  }\n  return bands.reduce(function (acc, band) {\n    if (band.columnName === columnName) {\n      return __assign(__assign({}, acc), {\n        title: title,\n        level: level,\n        key: key\n      });\n    }\n    if (band.children !== undefined) {\n      var rowLevelPassed = level > tableRowLevel;\n      var bandTitle = rowLevelPassed ? title : band.title;\n      var bandKey = rowLevelPassed ? key : key + \"_\" + bandTitle;\n      return getColumnMeta(columnName, band.children, tableRowLevel, bandKey, level + 1, bandTitle, acc);\n    }\n    return acc;\n  }, result || {\n    level: level,\n    title: title,\n    key: title\n  });\n};\nvar calculateBand = function (visibleBound, headerChain) {\n  if (visibleBound) {\n    var bandStart = Math.max(visibleBound[0], headerChain.start);\n    var bandEnd = Math.min(visibleBound[1] + 1, headerChain.start + headerChain.columns.length);\n    return [bandStart, bandEnd];\n  }\n  return [headerChain.start, headerChain.start + headerChain.columns.length];\n};\nvar getBandComponent = function (_a, tableHeaderRows, tableColumns, columnBands, tableHeaderColumnChains, columnVisibleIntervals, bandLevelsVisibility) {\n  var currentTableColumn = _a.tableColumn,\n    tableRow = _a.tableRow,\n    rowSpan = _a.rowSpan;\n  if (rowSpan) return {\n    type: BAND_DUPLICATE_RENDER,\n    payload: null\n  };\n  var maxLevel = tableHeaderRows.filter(function (column) {\n    return column.type === TABLE_BAND_TYPE;\n  }).length + 1;\n  var level = tableRow.level;\n  var currentRowLevel = level === undefined ? maxLevel - 1 : level;\n  var currentColumnMeta = currentTableColumn.type === TABLE_DATA_TYPE ? getColumnMeta(currentTableColumn.column.name, columnBands, currentRowLevel) : {\n    level: 0,\n    title: ''\n  };\n  var currentColumnIndex = tableColumns.findIndex(function (column) {\n    return column.key === currentTableColumn.key;\n  });\n  var levelsCount = bandLevelsVisibility.length;\n  var visibleLevelsCount = bandLevelsVisibility.filter(Boolean).length;\n  if (currentColumnMeta.level < currentRowLevel) {\n    var shouldFillLevel = currentRowLevel > 0 && visibleLevelsCount < levelsCount && !bandLevelsVisibility[currentRowLevel] && currentTableColumn.type === TABLE_STUB_TYPE;\n    if (shouldFillLevel) {\n      return {\n        type: BAND_FILL_LEVEL_CELL,\n        payload: null\n      };\n    }\n    return {\n      type: BAND_EMPTY_CELL,\n      payload: null\n    };\n  }\n  var previousTableColumn = tableColumns[currentColumnIndex - 1];\n  var beforeBorder = false;\n  if (currentColumnIndex > 0 && currentTableColumn.type === TABLE_DATA_TYPE && isNoDataColumn(previousTableColumn.type)) {\n    beforeBorder = true;\n  }\n  var isStubColumn = currentTableColumn.type === TABLE_STUB_TYPE;\n  var isColumnVisible = currentColumnIndex >= 0;\n  if (currentColumnMeta.level === currentRowLevel) {\n    if (isStubColumn) {\n      var cellRowSpan = visibleLevelsCount < levelsCount ? visibleLevelsCount || 1 : maxLevel;\n      return {\n        type: BAND_FILL_LEVEL_CELL,\n        payload: {\n          rowSpan: cellRowSpan\n        }\n      };\n    }\n    if (isColumnVisible) {\n      return {\n        type: BAND_HEADER_CELL,\n        payload: __assign({\n          tableRow: tableHeaderRows.find(function (row) {\n            return row.type === TABLE_HEADING_TYPE;\n          }),\n          rowSpan: maxLevel - currentRowLevel\n        }, beforeBorder && {\n          beforeBorder: beforeBorder\n        })\n      };\n    }\n  }\n  if (!isColumnVisible) return {\n    type: BAND_EMPTY_CELL,\n    payload: null\n  };\n  var currentColumnChain = findChainByColumnIndex(tableHeaderColumnChains[currentRowLevel], currentColumnIndex);\n  var columnVisibleBoundary = columnVisibleIntervals.find(function (_a) {\n    var _b = __read(_a, 2),\n      start = _b[0],\n      end = _b[1];\n    return start <= currentColumnIndex && currentColumnIndex <= end;\n  });\n  var _b = __read(calculateBand(columnVisibleBoundary, currentColumnChain), 2),\n    bandStart = _b[0],\n    bandEnd = _b[1];\n  if (bandStart < currentColumnIndex) {\n    return {\n      type: null,\n      payload: null\n    };\n  }\n  return {\n    type: BAND_GROUP_CELL,\n    payload: __assign({\n      colSpan: bandEnd - bandStart,\n      value: currentColumnMeta.title,\n      column: currentColumnMeta\n    }, beforeBorder && {\n      beforeBorder: beforeBorder\n    })\n  };\n};\nvar emptyVirtualRows = {\n  skip: Number.POSITIVE_INFINITY,\n  rows: []\n};\nvar pluckSubarray = function (source, sourceStart, left, right) {\n  return source.slice(left - sourceStart, right - sourceStart);\n};\nvar mergeRows = function (rowsInterval, cacheInterval, rows, cacheRows, rowsStart, cacheStart) {\n  var breakpoints = [rowsInterval.start, rowsInterval.end, cacheInterval.start, cacheInterval.end].filter(function (i) {\n    return 0 <= i && i < Number.POSITIVE_INFINITY;\n  }).sort(function (a, b) {\n    return a - b;\n  });\n  var result = [];\n  if (breakpoints.length > 1) {\n    for (var i = 0; i < breakpoints.length - 1; i += 1) {\n      var left = breakpoints[i];\n      var right = breakpoints[i + 1];\n      var chunk = rowsInterval.start <= left && right <= rowsInterval.end ? pluckSubarray(rows, rowsStart, left, right) // rows have higher priority\n      : pluckSubarray(cacheRows, cacheStart, left, right);\n      result = result.concat(chunk);\n    }\n  }\n  return {\n    skip: breakpoints[0],\n    rows: result\n  };\n};\nvar correctRequestedRange = function (calculatedRange, referenceIndex, pageSize) {\n  var start = calculatedRange.start,\n    end = calculatedRange.end;\n  if (start - referenceIndex > pageSize / 2) {\n    return {\n      start: start - pageSize,\n      end: start\n    };\n  }\n  return {\n    start: start,\n    end: end\n  };\n};\nvar calculateRequestedRange = function (virtualRows, newRange, pageSize, referenceIndex, isInfiniteScroll) {\n  var loadedInterval = intervalUtil.getRowsInterval(virtualRows);\n  var isAdjacentPage = Math.abs(loadedInterval.start - newRange.start) < 2 * pageSize;\n  if (isAdjacentPage) {\n    var calculatedRange = intervalUtil.difference(newRange, loadedInterval);\n    if (isInfiniteScroll && calculatedRange !== intervalUtil.empty) {\n      return correctRequestedRange(calculatedRange, referenceIndex, pageSize);\n    }\n    return calculatedRange;\n  }\n  // load 3 pages at once because a missing page will be loaded anyway\n  return newRange;\n};\nvar rowToPageIndex = function (rowIndex, pageSize) {\n  return Math.floor(rowIndex / pageSize);\n};\nvar recalculateBounds = function (middleIndex, pageSize, totalCount) {\n  var currentPageIndex = rowToPageIndex(middleIndex, pageSize);\n  var prevPageIndex = currentPageIndex - 1;\n  var nextPageIndex = currentPageIndex + 2;\n  var start = Math.max(0, prevPageIndex * pageSize);\n  var end = Math.min(nextPageIndex * pageSize, totalCount);\n  return {\n    start: start,\n    end: end\n  };\n};\nvar trimRowsToInterval = function (virtualRows, targetInterval) {\n  var rowsInterval = intervalUtil.getRowsInterval(virtualRows);\n  var intersection = intervalUtil.intersect(rowsInterval, targetInterval);\n  if (intervalUtil.empty === intersection) {\n    return emptyVirtualRows;\n  }\n  var rows = pluckSubarray(virtualRows.rows, virtualRows.skip, intersection.start, intersection.end);\n  return {\n    rows: rows,\n    skip: intersection.start\n  };\n};\nvar getAvailableRowCount = function (isInfiniteScroll, newRowCount, lastRowCount, totalRowCount) {\n  return isInfiniteScroll ? Math.min(Math.max(newRowCount, lastRowCount), totalRowCount) : totalRowCount;\n};\nvar getForceReloadInterval = function (virtualRows, pageSize, totalRowCount) {\n  var _a = intervalUtil.getRowsInterval(virtualRows),\n    start = _a.start,\n    intervalEnd = _a.end;\n  var end = Math.min(Math.max(start + pageSize * 2, intervalEnd), Math.max(start + pageSize * 2, totalRowCount));\n  return {\n    start: start,\n    end: end\n  };\n};\nvar getRequestMeta = function (referenceIndex, virtualRows, pageSize, totalRowCount, forceReload, isInfiniteScroll) {\n  var actualBounds = forceReload ? getForceReloadInterval(virtualRows, pageSize, totalRowCount) : recalculateBounds(referenceIndex, pageSize, totalRowCount);\n  var requestedRange = forceReload ? actualBounds : calculateRequestedRange(virtualRows, actualBounds, pageSize, referenceIndex, isInfiniteScroll);\n  return {\n    requestedRange: requestedRange,\n    actualBounds: actualBounds\n  };\n};\nvar needFetchMorePages = function (virtualRows, referenceIndex, pageSize) {\n  var _a = intervalUtil.getRowsInterval(virtualRows),\n    start = _a.start,\n    end = _a.end;\n  var loadCount = end - start;\n  var topTriggerIndex = start > 0 ? start + pageSize : 0;\n  var bottomTriggerIndex = Math.max(topTriggerIndex + pageSize, end - pageSize * 1.5);\n  if (loadCount <= 0) {\n    return false;\n  }\n  return referenceIndex < topTriggerIndex || bottomTriggerIndex < referenceIndex;\n};\nvar getReferenceIndex = function (_a) {\n  var _b = __read(_a.rows, 2),\n    top = _b[0],\n    bottom = _b[1];\n  return (top + bottom) / 2;\n};\nvar shouldSendRequest = function (_a, requestedPageIndex, requestedEndIndex) {\n  var start = _a.start,\n    end = _a.end;\n  var loadCount = end - start;\n  return (start !== requestedPageIndex || end !== requestedEndIndex) && loadCount > 0;\n};\nvar empty = {\n  start: Number.POSITIVE_INFINITY,\n  end: Number.NEGATIVE_INFINITY\n};\nvar getRowsInterval = function (r) {\n  return r === emptyVirtualRows ? empty : {\n    start: r.skip,\n    end: r.skip + r.rows.length\n  };\n};\nvar getLength = function (a) {\n  return a.end - a.start;\n};\nvar intersect = function (a, b) {\n  if (a.end < b.start || b.end < a.start) {\n    return empty;\n  }\n  return {\n    start: Math.max(a.start, b.start),\n    end: Math.min(a.end, b.end)\n  };\n};\nvar difference = function (a, b) {\n  if (empty === intervalUtil.intersect(a, b)) {\n    return a;\n  }\n  if (b.end < a.end) {\n    return {\n      start: b.end,\n      end: a.end\n    };\n  }\n  if (a.start < b.start) {\n    return {\n      start: a.start,\n      end: b.start\n    };\n  }\n  return empty;\n};\nvar intervalUtil = {\n  empty: empty,\n  getRowsInterval: getRowsInterval,\n  getLength: getLength,\n  intersect: intersect,\n  difference: difference\n};\nvar tableRowsWithBands = function (tableHeaderRows, columnBands, tableColumns) {\n  var tableDataColumns = tableColumns.filter(function (column) {\n    return column.type === TABLE_DATA_TYPE;\n  });\n  var getMaxNestedLevel = function (bands, level, result) {\n    if (level === void 0) {\n      level = 0;\n    }\n    if (result === void 0) {\n      result = null;\n    }\n    return bands.reduce(function (acc, column) {\n      if (column.children !== undefined) {\n        return getMaxNestedLevel(column.children, level + 1, acc);\n      }\n      var isDataColumn = tableDataColumns.findIndex(function (dataColumn) {\n        return !!dataColumn.column && dataColumn.column.name === column.columnName;\n      }) > -1;\n      if (level > acc.level && isDataColumn) {\n        return __assign(__assign({}, acc), {\n          level: level\n        });\n      }\n      return acc;\n    }, result || {\n      level: 0\n    });\n  };\n  var tableBandHeaders = Array.from({\n    length: getMaxNestedLevel(columnBands, 0).level\n  }).map(function (row, index) {\n    return {\n      key: TABLE_BAND_TYPE.toString() + \"_\" + index,\n      type: TABLE_BAND_TYPE,\n      level: index\n    };\n  });\n  return __spread(tableBandHeaders, tableHeaderRows);\n};\nvar tableHeaderColumnChainsWithBands = function (tableHeaderRows, tableColumns, bands) {\n  var chains = generateSimpleChains(tableHeaderRows, tableColumns);\n  var maxBandRowIndex = tableHeaderRows.filter(function (row) {\n    return row.type === TABLE_BAND_TYPE;\n  }).length;\n  var rawBandChains = chains.slice(0, maxBandRowIndex);\n  var currentBand = null;\n  var shouldSplitChain = function (chain, column, rowIndex) {\n    if (rowIndex > maxBandRowIndex) return false;\n    var columnName = column.column && column.column.name || '';\n    currentBand = getColumnMeta(columnName, bands, rowIndex);\n    return !chain || chain.key !== currentBand.key || chain.columns[0].type === TABLE_GROUP_TYPE;\n  };\n  var extendChainProps = function () {\n    return {\n      bandTitle: currentBand === null || currentBand === void 0 ? void 0 : currentBand.title,\n      key: currentBand === null || currentBand === void 0 ? void 0 : currentBand.key\n    };\n  };\n  var bandChains = splitHeaderColumnChains(rawBandChains, tableColumns, shouldSplitChain, extendChainProps);\n  return __spread(bandChains, chains.slice(maxBandRowIndex));\n};\nvar getBandLevels = function (columnsBands, levels, level) {\n  if (levels === void 0) {\n    levels = {};\n  }\n  if (level === void 0) {\n    level = 0;\n  }\n  columnsBands.forEach(function (band) {\n    if (band.title) {\n      levels[band.title] = level;\n    }\n    if (band.children) {\n      getBandLevels(band.children, levels, level + 1);\n    }\n  });\n  return levels;\n};\nvar columnBandLevels = function (columnsBands) {\n  return getBandLevels(columnsBands);\n};\nvar bandLevelsVisibility = function (columnIntervals, tableHeaderColumnChains, bandLevels) {\n  var rowsWithBands = tableHeaderColumnChains.filter(function (r) {\n    return r.filter(function (ch) {\n      return !!ch.bandTitle;\n    }).length;\n  });\n  var visibleIntervals = columnIntervals.map(function (_a) {\n    var _b = __read(_a, 2),\n      start = _b[0],\n      end = _b[1];\n    return {\n      start: start,\n      end: end\n    };\n  });\n  var isBandChainVisible = function (chain) {\n    return visibleIntervals.some(function (interval) {\n      return intervalUtil.intersect(interval, {\n        start: chain.start,\n        end: chain.start + chain.columns.length - 1\n      }) !== intervalUtil.empty;\n    });\n  };\n  var getVisibleBandsByLevel = function (level) {\n    return (\n      // Note: a visible band level always matches with it's row\n      rowsWithBands[level] ? rowsWithBands[level].filter(function (chain) {\n        return bandLevels[chain.bandTitle] === level && isBandChainVisible(chain);\n      }) : []\n    );\n  };\n  return rowsWithBands.reduce(function (acc, _, index) {\n    var rowBands = getVisibleBandsByLevel(index);\n    return __spread(acc, [!!rowBands.length]);\n  }, []);\n};\nvar columnVisibleIntervals = function (viewport, tableColumns) {\n  return viewport ? viewport.columns : [[0, tableColumns.length]];\n};\nvar toggleDetailRowExpanded = function (prevExpanded, _a) {\n  var rowId = _a.rowId,\n    state = _a.state;\n  return toggle(prevExpanded, [rowId], state);\n};\nvar TABLE_DETAIL_TYPE = Symbol('detail');\nvar isDetailRowExpanded = function (expandedDetailRowIds, rowId) {\n  return expandedDetailRowIds.indexOf(rowId) > -1;\n};\nvar isDetailToggleTableCell = function (tableRow, tableColumn) {\n  return tableColumn.type === TABLE_DETAIL_TYPE && tableRow.type === TABLE_DATA_TYPE;\n};\nvar isDetailTableRow = function (tableRow) {\n  return tableRow.type === TABLE_DETAIL_TYPE;\n};\nvar isDetailTableCell = function (tableColumn, tableColumns) {\n  return tableColumns.indexOf(tableColumn) === 0;\n};\nvar tableRowsWithExpandedDetail = function (tableRows, expandedDetailRowIds, rowHeight) {\n  var result = tableRows;\n  expandedDetailRowIds.forEach(function (expandedRowId) {\n    var rowIndex = result.findIndex(function (tableRow) {\n      return tableRow.type === TABLE_DATA_TYPE && tableRow.rowId === expandedRowId;\n    });\n    if (rowIndex === -1) return;\n    var insertIndex = rowIndex + 1;\n    var _a = result[rowIndex],\n      row = _a.row,\n      rowId = _a.rowId;\n    result = __spread(result.slice(0, insertIndex), [{\n      rowId: rowId,\n      row: row,\n      key: TABLE_DETAIL_TYPE.toString() + \"_\" + rowId,\n      type: TABLE_DETAIL_TYPE,\n      height: rowHeight\n    }], result.slice(insertIndex));\n  });\n  return result;\n};\nvar tableColumnsWithDetail = function (tableColumns, toggleColumnWidth) {\n  return __spread([{\n    key: TABLE_DETAIL_TYPE.toString(),\n    type: TABLE_DETAIL_TYPE,\n    width: toggleColumnWidth\n  }], tableColumns);\n};\nvar tableDetailCellColSpanGetter = function (getTableCellColSpan) {\n  return function (params) {\n    var tableRow = params.tableRow,\n      tableColumns = params.tableColumns,\n      tableColumn = params.tableColumn;\n    if (tableRow.type === TABLE_DETAIL_TYPE && tableColumns.indexOf(tableColumn) === 0) {\n      return tableColumns.length;\n    }\n    return getTableCellColSpan(params);\n  };\n};\nvar TABLE_SELECT_TYPE = Symbol('select');\nvar isSelectTableCell = function (tableRow, tableColumn) {\n  return tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_DATA_TYPE;\n};\nvar isSelectAllTableCell = function (tableRow, tableColumn) {\n  return tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_HEADING_TYPE;\n};\nvar isRowHighlighted = function (highlightRow, selection, tableRow, focused) {\n  var highlightion = selection ? selection.concat(focused || []) : focused;\n  return !!(highlightRow && highlightion && highlightion.includes(tableRow.rowId));\n};\nvar tableColumnsWithSelection = function (tableColumns, selectionColumnWidth, showSelectionColumn) {\n  if (showSelectionColumn) {\n    return __spread([{\n      key: TABLE_SELECT_TYPE.toString(),\n      type: TABLE_SELECT_TYPE,\n      width: selectionColumnWidth\n    }], tableColumns);\n  }\n  return tableColumns;\n};\nvar VALID_UNITS$1 = ['px', '%', 'em', 'rem', 'vm', 'vh', 'vmin', 'vmax', ''];\nvar TABLE_ERROR = 'The columnExtension property of the Table plugin is given an invalid value.';\nvar isDataTableCell = function (tableRow, tableColumn) {\n  return tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n};\nvar isHeaderStubTableCell = function (tableRow, headerRows) {\n  return headerRows.indexOf(tableRow) > -1;\n};\nvar isDataTableRow = function (tableRow) {\n  return tableRow.type === TABLE_DATA_TYPE;\n};\nvar isNoDataTableRow = function (tableRow) {\n  return tableRow.type === TABLE_NODATA_TYPE;\n};\nvar isNoDataTableCell = function (tableColumn, tableColumns) {\n  return tableColumns.indexOf(tableColumn) === 0;\n};\nvar isStubTableCell = function (tableRow) {\n  return tableRow.type === TABLE_STUB_TYPE;\n};\nvar checkTableColumnExtensions = function (columnExtensions) {\n  if (columnExtensions) {\n    columnExtensions.map(function (column) {\n      var width = column.width;\n      if (typeof width === 'string') {\n        if (!isValidValue(width, VALID_UNITS$1)) {\n          throw new Error(TABLE_ERROR);\n        }\n      }\n    });\n  }\n};\nvar getColumnExtension = function (columnExtensions, columnName) {\n  if (!columnExtensions) {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    return {};\n  }\n  var columnExtension = columnExtensions.find(function (extension) {\n    return extension.columnName === columnName;\n  });\n  if (!columnExtension) {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    return {};\n  }\n  return columnExtension;\n};\nvar getColumnExtensionValueGetter = function (columnExtensions, extensionName, defaultValue) {\n  return function (columnName) {\n    if (columnExtensions) {\n      var columnExtension = getColumnExtension(columnExtensions, columnName);\n      var extensionValue = columnExtension[extensionName];\n      return extensionValue !== undefined ? extensionValue : defaultValue;\n    }\n    return defaultValue;\n  };\n};\nvar tableColumnsWithDataRows = function (columns, columnExtensions) {\n  return columns.map(function (column) {\n    var name = column.name;\n    var columnExtension = getColumnExtension(columnExtensions, name);\n    var width = convertWidth(columnExtension.width);\n    return {\n      column: column,\n      key: TABLE_DATA_TYPE.toString() + \"_\" + name,\n      type: TABLE_DATA_TYPE,\n      width: width,\n      align: columnExtension.align,\n      wordWrapEnabled: columnExtension.wordWrapEnabled\n    };\n  });\n};\nvar tableRowsWithDataRows = function (rows, getRowId, isRemoteRowsLoading) {\n  return !rows.length && !isRemoteRowsLoading ? [{\n    key: TABLE_NODATA_TYPE.toString(),\n    type: TABLE_NODATA_TYPE\n  }] : rows.map(function (row, dataIndex) {\n    var rowId = getRowId(row);\n    return {\n      row: row,\n      // dataIndex,\n      rowId: rowId,\n      type: TABLE_DATA_TYPE,\n      key: TABLE_DATA_TYPE.toString() + \"_\" + rowId\n    };\n  });\n};\nvar tableCellColSpanGetter = function (params) {\n  var tableRow = params.tableRow,\n    tableColumns = params.tableColumns,\n    tableColumn = params.tableColumn;\n  if (tableRow.type === TABLE_NODATA_TYPE && tableColumns.indexOf(tableColumn) === 0) {\n    return tableColumns.length;\n  }\n  return 1;\n};\nvar visibleTableColumns = function (tableColumns, hiddenColumnNames) {\n  if (tableColumns === void 0) {\n    tableColumns = [];\n  }\n  return tableColumns.filter(function (tableColumn) {\n    return tableColumn.type !== TABLE_DATA_TYPE || hiddenColumnNames.indexOf(tableColumn.column.name) === -1;\n  });\n};\nvar tableDataColumnsExist = function (tableColumns) {\n  return tableColumns.some(function (column) {\n    return column.type === TABLE_DATA_TYPE;\n  });\n};\nvar columnChooserItems = function (columns, hiddenColumnNames) {\n  return columns.map(function (column) {\n    return {\n      column: column,\n      hidden: hiddenColumnNames.indexOf(column.name) !== -1\n    };\n  });\n};\nvar toggleColumn = function (hiddenColumnNames, columnName) {\n  return hiddenColumnNames.indexOf(columnName) === -1 ? __spread(hiddenColumnNames, [columnName]) : hiddenColumnNames.filter(function (hiddenColumn) {\n    return hiddenColumn !== columnName;\n  });\n};\nvar toggleRowExpanded = function (prevExpanded, _a) {\n  var rowId = _a.rowId,\n    state = _a.state;\n  return toggle(prevExpanded, [rowId], state);\n};\nvar GRID_TREE_NODE_TYPE = Symbol('treeNode');\nvar customTreeRowsWithMeta = function (rows, getChildRows) {\n  var rowsToProcess = [{\n    row: null,\n    level: -1\n  }];\n  var treeRows = [];\n  var _loop_1 = function () {\n    var _a = rowsToProcess.shift(),\n      currentRow = _a.row,\n      level = _a.level;\n    var rowIndex = treeRows.findIndex(function (_a) {\n      var row = _a.row;\n      return row === currentRow;\n    });\n    var nestedRows = (_a = getChildRows(currentRow, rows)) === null || _a === void 0 ? void 0 : _a.map(function (childRow) {\n      return {\n        row: childRow,\n        level: level + 1,\n        leaf: !getChildRows(childRow, rows)\n      };\n    });\n    if (nestedRows) {\n      if (rowIndex > -1) {\n        treeRows.splice.apply(treeRows, __spread([rowIndex + 1, 0], nestedRows));\n      } else {\n        treeRows.push.apply(treeRows, __spread(nestedRows));\n      }\n      rowsToProcess.push.apply(rowsToProcess, __spread(nestedRows));\n    }\n  };\n  while (rowsToProcess === null || rowsToProcess === void 0 ? void 0 : rowsToProcess.length) {\n    _loop_1();\n  }\n  var result = treeRows.reduce(function (acc, _a) {\n    var row = _a.row,\n      level = _a.level,\n      leaf = _a.leaf;\n    acc.rows.push(row);\n    acc.treeMeta.push([row, {\n      level: level,\n      leaf: leaf\n    }]);\n    return acc;\n  }, {\n    rows: [],\n    treeMeta: []\n  });\n  return {\n    rows: result.rows,\n    treeMeta: new Map(result.treeMeta)\n  };\n};\nvar customTreeRowIdGetter = function (getRowId, _a) {\n  var rows = _a.rows,\n    treeMeta = _a.treeMeta;\n  var firstNestedRowIndex = rows.findIndex(function (row) {\n    return treeMeta.get(row).level > 0;\n  });\n  if (firstNestedRowIndex === -1 || getRowId(rows[firstNestedRowIndex]) !== undefined) {\n    return getRowId;\n  }\n  var map = new Map(rows.map(function (row, rowIndex) {\n    return [row, rowIndex];\n  }));\n  return function (row) {\n    return map.get(row);\n  };\n};\nvar customTreeRowLevelKeyGetter = function (getRowLevelKey, _a) {\n  var treeMeta = _a.treeMeta;\n  return function (row) {\n    var rowMeta = treeMeta.get(row);\n    if (rowMeta !== undefined) {\n      return GRID_TREE_NODE_TYPE.toString() + \"_\" + rowMeta.level;\n    }\n    return getRowLevelKey && getRowLevelKey();\n  };\n};\nvar expandedTreeRows = function (_a, getRowId, expandedRowIds) {\n  var rows = _a.rows,\n    treeMeta = _a.treeMeta;\n  var expandedRowIdsSet = new Set(expandedRowIds);\n  var currentExpanded = true;\n  var currentLevel = 0;\n  var collapsedRowsMeta = new Map();\n  var resultRows = [];\n  rows.forEach(function (row) {\n    var rowMeta = treeMeta.get(row);\n    var level = rowMeta && rowMeta.level;\n    if (level === undefined && currentExpanded) {\n      resultRows.push(row);\n    } else if (!currentExpanded && (level === undefined || level > currentLevel)) {\n      var lastRow = resultRows[resultRows.length - 1];\n      var collapsedItems = collapsedRowsMeta.get(lastRow);\n      if (!collapsedItems) {\n        collapsedItems = [];\n        collapsedRowsMeta.set(lastRow, collapsedItems);\n      }\n      collapsedItems.push(row);\n    } else {\n      currentExpanded = expandedRowIdsSet.has(getRowId(row));\n      currentLevel = level;\n      resultRows.push(row);\n    }\n  });\n  return {\n    treeMeta: treeMeta,\n    collapsedRowsMeta: collapsedRowsMeta,\n    rows: resultRows\n  };\n};\nvar collapsedTreeRowsGetter = function (getCollapsedRows, _a) {\n  var collapsedRowsMeta = _a.collapsedRowsMeta;\n  return function (row) {\n    return collapsedRowsMeta.get(row) || getCollapsedRows && getCollapsedRows(row);\n  };\n};\nvar isTreeRowLeafGetter = function (_a) {\n  var treeMeta = _a.treeMeta;\n  return function (row) {\n    var rowMeta = treeMeta.get(row);\n    return rowMeta && rowMeta.leaf;\n  };\n};\nvar getTreeRowLevelGetter = function (_a) {\n  var treeMeta = _a.treeMeta;\n  return function (row) {\n    var rowMeta = treeMeta.get(row);\n    return rowMeta && rowMeta.level;\n  };\n};\nvar unwrappedCustomTreeRows = function (_a) {\n  var rows = _a.rows;\n  return rows;\n};\nvar isTreeTableCell = function (tableRow, tableColumn, forColumnName) {\n  return tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE && tableColumn.column.name === forColumnName;\n};\nvar changeSearchValue = function (prevSearchValue, searchValue) {\n  return searchValue;\n};\nvar searchFilterExpression = function (searchValue, columns, filterExpression) {\n  var filters = columns.map(function (_a) {\n    var name = _a.name;\n    return {\n      columnName: name,\n      value: searchValue\n    };\n  });\n  var selfFilterExpression = {\n    filters: filters,\n    operator: 'or'\n  };\n  if (!filterExpression) {\n    return selfFilterExpression;\n  }\n  return {\n    operator: 'and',\n    filters: [filterExpression, selfFilterExpression]\n  };\n};\nvar getAvailableFilterOperationsGetter = function (getAvailableFilterOperations, availableFilterOperations, columnNames) {\n  return function (columnName) {\n    return columnNames.indexOf(columnName) > -1 && availableFilterOperations\n    // tslint:disable-next-line: max-line-length\n    || typeof getAvailableFilterOperations === 'function' && getAvailableFilterOperations(columnName) || undefined;\n  };\n};\nvar FIXED_COLUMN_LEFT_SIDE = 'left';\nvar FIXED_COLUMN_RIGHT_SIDE = 'right';\nvar TABLE_FIXED_TYPE = Symbol('fixed');\nvar getFixedColumnKeys = function (tableColumns, fixedNames) {\n  return tableColumns.filter(function (tableColumn) {\n    return tableColumn.type === TABLE_DATA_TYPE && fixedNames.indexOf(tableColumn.column.name) !== -1 || fixedNames.indexOf(tableColumn.type) !== -1;\n  }).map(function (_a) {\n    var key = _a.key;\n    return key;\n  });\n};\nvar isFixedTableRow = function (tableRow) {\n  return tableRow.type === TABLE_FIXED_TYPE;\n};\nvar calculatePosition = function (array, index, tableColumnDimensions) {\n  return index === 0 ? 0 : array.slice(0, index).reduce(function (acc, target) {\n    return acc + tableColumnDimensions[target] || 0;\n  }, 0);\n};\nvar calculateFixedColumnProps = function (_a, _b, tableColumns, tableColumnDimensions, tableHeaderColumnChains) {\n  var tableColumn = _a.tableColumn;\n  var leftColumns = _b.leftColumns,\n    rightColumns = _b.rightColumns;\n  var side = tableColumn.fixed;\n  var targetArray = side === FIXED_COLUMN_LEFT_SIDE ? getFixedColumnKeys(tableColumns, leftColumns) : slice(getFixedColumnKeys(tableColumns, rightColumns)).reverse();\n  var index = tableColumns.findIndex(function (_a) {\n    var key = _a.key;\n    return key === tableColumn.key;\n  });\n  var fixedIndex = targetArray.indexOf(tableColumn.key);\n  var columnChain = findChainByColumnIndex(tableHeaderColumnChains[0], index);\n  var showLeftDivider = columnChain.start === index && index !== 0;\n  var showRightDivider = columnChain.start + columnChain.columns.length - 1 === index && index < tableColumns.length - 1;\n  var position = calculatePosition(targetArray, fixedIndex, tableColumnDimensions);\n  return {\n    showRightDivider: showRightDivider,\n    showLeftDivider: showLeftDivider,\n    position: position,\n    side: side\n  };\n};\nvar tableColumnsWithFixed = function (tableColumns, leftColumns, rightColumns) {\n  return tableColumns.map(function (tableColumn) {\n    var fixed;\n    if (tableColumn.type === TABLE_DATA_TYPE && leftColumns.indexOf(tableColumn.column.name) !== -1 || leftColumns.indexOf(tableColumn.type) !== -1) {\n      fixed = FIXED_COLUMN_LEFT_SIDE;\n    }\n    if (tableColumn.type === TABLE_DATA_TYPE && rightColumns.indexOf(tableColumn.column.name) !== -1 || rightColumns.indexOf(tableColumn.type) !== -1) {\n      fixed = FIXED_COLUMN_RIGHT_SIDE;\n    }\n    return fixed ? __assign(__assign({}, tableColumn), {\n      fixed: fixed\n    }) : tableColumn;\n  });\n};\nvar tableHeaderRowsWithFixed = function (tableHeaderRows) {\n  return __spread(tableHeaderRows, [{\n    key: TABLE_FIXED_TYPE.toString(),\n    type: TABLE_FIXED_TYPE,\n    height: 0\n  }]);\n};\nvar tableHeaderColumnChainsWithFixed = function (tableHeaderColumnChains, tableHeaderRows, tableColumns) {\n  var chains = tableHeaderColumnChains || generateSimpleChains(tableHeaderRows, tableColumns);\n  var shouldSplitChain = function (currentGroup, column) {\n    return !currentGroup || currentGroup.fixed !== column.fixed;\n  };\n  var extendChainProps = function (column) {\n    return {\n      fixed: column.fixed\n    };\n  };\n  return splitHeaderColumnChains(chains, tableColumns, shouldSplitChain, extendChainProps);\n};\nvar defaultSummaryCalculators = {\n  count: function (rows) {\n    return rows.length;\n  },\n  sum: function (rows, getValue) {\n    return rows.reduce(function (acc, row) {\n      return acc + getValue(row);\n    }, 0);\n  },\n  max: function (rows, getValue) {\n    return rows.length ? rows.reduce(function (acc, row) {\n      return Math.max(acc, getValue(row));\n    }, -Infinity) : null;\n  },\n  min: function (rows, getValue) {\n    return rows.length ? rows.reduce(function (acc, row) {\n      return Math.min(acc, getValue(row));\n    }, Infinity) : null;\n  },\n  avg: function (rows, getValue) {\n    return rows.length ? rows.reduce(function (acc, row) {\n      return acc + getValue(row);\n    }, 0) / rows.length : null;\n  }\n};\nvar defaultSummaryCalculator = function (type, rows, getValue) {\n  var summaryCalculator = defaultSummaryCalculators[type];\n  if (!summaryCalculator) {\n    throw new Error(\"The summary type '\" + type + \"' is not defined\");\n  }\n  return summaryCalculator(rows, getValue);\n};\nvar rowsSummary = function (rows, summaryItems, getCellValue, calculator) {\n  return summaryItems.reduce(function (acc, _a) {\n    var type = _a.type,\n      columnName = _a.columnName;\n    var getValue = function (row) {\n      return getCellValue(row, columnName);\n    };\n    acc.push(calculator(type, rows, getValue));\n    return acc;\n  }, []);\n};\nvar expandRows = function (rows, getRowLevelKey, getCollapsedRows, isGroupRow, includeGroupRow) {\n  if (includeGroupRow === void 0) {\n    includeGroupRow = false;\n  }\n  var shouldIncludeRow = includeGroupRow || !isGroupRow ? function () {\n    return true;\n  } : function (row) {\n    return !isGroupRow(row);\n  };\n  return rows.reduce(function (acc, row) {\n    if (getRowLevelKey && getRowLevelKey(row)) {\n      if (shouldIncludeRow(row)) {\n        acc.push(row);\n      }\n      var collapsedRows = getCollapsedRows && getCollapsedRows(row);\n      if (collapsedRows) {\n        acc.push.apply(acc, __spread(collapsedRows));\n      }\n      return acc;\n    }\n    acc.push(row);\n    return acc;\n  }, []);\n};\nvar totalSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows, calculator) {\n  if (calculator === void 0) {\n    calculator = defaultSummaryCalculator;\n  }\n  var plainRows = expandRows(rows, getRowLevelKey, getCollapsedRows, isGroupRow);\n  return rowsSummary(plainRows, summaryItems, getCellValue, calculator);\n};\nvar groupSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows, calculator) {\n  if (calculator === void 0) {\n    calculator = defaultSummaryCalculator;\n  }\n  var levels = [];\n  var getLevelIndex = function (levelKey) {\n    return levels.findIndex(function (level) {\n      return level.levelKey === levelKey;\n    });\n  };\n  var summaries = {};\n  var anyRowLevelSummaryExist = summaryItems.some(function (item) {\n    return !item.showInGroupFooter;\n  });\n  var expandedRows = anyRowLevelSummaryExist ? expandRows(rows, getRowLevelKey, getCollapsedRows, isGroupRow, true) : rows;\n  expandedRows.forEach(function (row) {\n    var levelKey = getRowLevelKey(row);\n    var collapsedRows = getCollapsedRows && getCollapsedRows(row);\n    var levelIndex = getLevelIndex(levelKey);\n    if (levelIndex > -1) {\n      levels.forEach(function (level) {\n        summaries[level.row.compoundKey] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);\n      });\n      levels = levels.slice(0, levelIndex);\n    }\n    if (isGroupRow(row)) {\n      levels.push({\n        levelKey: levelKey,\n        row: row,\n        rows: []\n      });\n      levelIndex = getLevelIndex(levelKey);\n    }\n    // when row level summary exists, these rows had already been expanded earlier\n    var isCollapsedNestedGroupRow = collapsedRows && levelIndex > 0 && !anyRowLevelSummaryExist;\n    var rowsToAppend = !levelKey ? [row] : collapsedRows;\n    if (!levelKey || isCollapsedNestedGroupRow) {\n      levels.forEach(function (level) {\n        var _a;\n        (_a = level.rows).push.apply(_a, __spread(rowsToAppend));\n      });\n    }\n  }, {});\n  levels.forEach(function (level) {\n    summaries[level.row.compoundKey] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);\n  });\n  return summaries;\n};\nvar treeSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getRowId, calculator) {\n  if (calculator === void 0) {\n    calculator = defaultSummaryCalculator;\n  }\n  var levels = [];\n  var summaries = {};\n  rows.forEach(function (row) {\n    var levelKey = getRowLevelKey(row);\n    if (!levelKey) {\n      levels[levels.length - 1].rows.push(row);\n      return;\n    }\n    var levelIndex = levels.findIndex(function (level) {\n      return level.levelKey === levelKey;\n    });\n    if (levelIndex > -1) {\n      levels.slice(levelIndex).forEach(function (level) {\n        if (level.rows.length) {\n          summaries[getRowId(level.row)] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);\n        }\n      });\n      levels = levels.slice(0, levelIndex);\n    }\n    if (!isGroupRow || !isGroupRow(row)) {\n      if (levels.length) {\n        levels[levels.length - 1].rows.push(row);\n      }\n      levels.push({\n        levelKey: levelKey,\n        row: row,\n        rows: []\n      });\n    }\n  }, {});\n  levels.forEach(function (level) {\n    if (level.rows.length) {\n      summaries[getRowId(level.row)] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);\n    }\n  });\n  return summaries;\n};\nvar TABLE_TOTAL_SUMMARY_TYPE = Symbol('totalSummary');\nvar TABLE_GROUP_SUMMARY_TYPE = Symbol('groupSummary');\nvar TABLE_TREE_SUMMARY_TYPE = Symbol('treeSummary');\nvar defaultFormatlessSummaries = ['count'];\nvar isTotalSummaryTableCell = function (tableRow, tableColumn) {\n  return tableRow.type === TABLE_TOTAL_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n};\nvar isGroupSummaryTableCell = function (tableRow, tableColumn) {\n  return tableRow.type === TABLE_GROUP_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n};\nvar isTreeSummaryTableCell = function (tableRow, tableColumn) {\n  return tableRow.type === TABLE_TREE_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n};\nvar isTotalSummaryTableRow = function (tableRow) {\n  return tableRow.type === TABLE_TOTAL_SUMMARY_TYPE;\n};\nvar isGroupSummaryTableRow = function (tableRow) {\n  return tableRow.type === TABLE_GROUP_SUMMARY_TYPE;\n};\nvar isTreeSummaryTableRow = function (tableRow) {\n  return tableRow.type === TABLE_TREE_SUMMARY_TYPE;\n};\nvar getColumnSummaries = function (summaryItems, columnName, summaryValues, predicate) {\n  if (predicate === void 0) {\n    predicate = function () {\n      return true;\n    };\n  }\n  return summaryItems.map(function (item, index) {\n    return [item, index];\n  }).filter(function (_a) {\n    var _b = __read(_a, 1),\n      item = _b[0];\n    return item.columnName === columnName && predicate(item);\n  }).map(function (_a) {\n    var _b = __read(_a, 2),\n      item = _b[0],\n      index = _b[1];\n    return {\n      type: item.type,\n      value: summaryValues[index]\n    };\n  });\n};\nvar isFooterSummary = function (summaryItem) {\n  return summaryItem.showInGroupFooter;\n};\nvar isInlineGroupCaptionSummary = function (summaryItem) {\n  return !(summaryItem.showInGroupFooter || summaryItem.alignByColumn);\n};\nvar groupFooterSummaryExists = function (groupSummaryItems) {\n  return groupSummaryItems === null || groupSummaryItems === void 0 ? void 0 : groupSummaryItems.some(isFooterSummary);\n};\nvar getGroupInlineSummaries = function (summaryItems, columns, summaryValues) {\n  if (!summaryItems.some(isInlineGroupCaptionSummary)) {\n    return [];\n  }\n  return columns.reduce(function (acc, column) {\n    var colName = column.name;\n    var summaries = getColumnSummaries(summaryItems, colName, summaryValues, isInlineGroupCaptionSummary);\n    if (summaries.length) {\n      acc.push({\n        column: column,\n        summaries: summaries\n      });\n    }\n    return acc;\n  }, []);\n};\nvar tableRowsWithTotalSummaries = function (footerRows) {\n  return __spread([{\n    key: TABLE_TOTAL_SUMMARY_TYPE.toString(),\n    type: TABLE_TOTAL_SUMMARY_TYPE\n  }], footerRows);\n};\nvar tableRowsWithSummaries = function (tableRows, groupSummaryItems, treeSummaryItems, getRowLevelKey, isGroupRow, getRowId) {\n  var hasGroupFooterSummary = groupFooterSummaryExists(groupSummaryItems);\n  if (!getRowLevelKey || !(hasGroupFooterSummary || treeSummaryItems.length)) return tableRows;\n  var result = [];\n  var closeLevel = function (level) {\n    if (!level.opened) return;\n    if (hasGroupFooterSummary && isGroupRow && isGroupRow(level.row)) {\n      var compoundKey = level.row.compoundKey;\n      result.push({\n        key: TABLE_GROUP_SUMMARY_TYPE.toString() + \"_\" + compoundKey,\n        type: TABLE_GROUP_SUMMARY_TYPE,\n        row: level.row\n      });\n    } else if (treeSummaryItems.length) {\n      var rowId = getRowId(level.row);\n      result.push({\n        key: TABLE_TREE_SUMMARY_TYPE.toString() + \"_\" + rowId,\n        type: TABLE_TREE_SUMMARY_TYPE,\n        row: level.row\n      });\n    }\n  };\n  var levels = [];\n  tableRows.forEach(function (tableRow) {\n    var row = tableRow.row;\n    var levelKey = getRowLevelKey(row);\n    if (levelKey) {\n      var levelIndex = levels.findIndex(function (level) {\n        return level.levelKey === levelKey;\n      });\n      if (levelIndex > -1) {\n        levels.slice(levelIndex).reverse().forEach(closeLevel);\n        levels = levels.slice(0, levelIndex);\n      }\n      if (!isGroupRow || !isGroupRow(row)) {\n        levels = levels.map(function (level) {\n          return __assign(__assign({}, level), {\n            opened: true\n          });\n        });\n      }\n      levels.push({\n        levelKey: levelKey,\n        row: row,\n        opened: false\n      });\n    } else {\n      levels = levels.map(function (level) {\n        return __assign(__assign({}, level), {\n          opened: true\n        });\n      });\n    }\n    result.push(tableRow);\n  });\n  levels.slice().reverse().forEach(closeLevel);\n  return result;\n};\nvar prepareGroupSummaryItems = function (items) {\n  return !!items ? items.map(function (item) {\n    return __assign(__assign({}, item), {\n      showInGroupFooter: item.showInGroupFooter === undefined && !item.alignByColumn ? true : item.showInGroupFooter\n    });\n  }) : items;\n};\nvar HEADING_TYPE = TABLE_HEADING_TYPE.toString();\nvar FILTER_TYPE = TABLE_FILTER_TYPE.toString();\nvar DATA_TYPE = TABLE_DATA_TYPE.toString();\nvar BAND_TYPE = TABLE_BAND_TYPE.toString();\nvar TOTAL_SUMMARY_TYPE = TABLE_TOTAL_SUMMARY_TYPE.toString();\nvar STUB_TYPE = TABLE_STUB_TYPE.toString();\nvar GROUP_TYPE = TABLE_GROUP_TYPE.toString();\nvar tableParts = [HEADING_TYPE, FILTER_TYPE, DATA_TYPE, TOTAL_SUMMARY_TYPE];\nvar getIndex = function (arr, key) {\n  return arr.findIndex(function (el) {\n    return el.key === key;\n  });\n};\nvar isSpanInput = function (innerElements) {\n  return innerElements[0].tagName === 'SPAN' || innerElements[0].tagName === 'INPUT' && innerElements[0].type === 'text';\n};\nvar isDefined = function (value) {\n  return value !== undefined;\n};\nvar hasInsideElements = function (innerElements, focusedElementIndex) {\n  if (innerElements.length && focusedElementIndex === undefined || isDefined(focusedElementIndex) && focusedElementIndex < innerElements.length - 1) {\n    if (innerElements.length === 1 && focusedElementIndex === undefined) {\n      return !isSpanInput(innerElements);\n    }\n    return true;\n  }\n  return false;\n};\nvar getIndexInnerElement = function (elements, rowKey, columnKey, direction) {\n  var innerElements = getInnerElements(elements, rowKey, columnKey);\n  var index = direction > 0 ? 0 : innerElements.length - 1;\n  return cellEmptyOrHasSpanAndInput(elements, rowKey, columnKey) ? undefined : index;\n};\nvar getNextPrevClosestColumnKey = function (tableColumns, columnIndex, rowKey, elements, direction) {\n  var columnKey;\n  if (direction > 0) {\n    for (var i = columnIndex; i <= tableColumns.length - 1; i += 1) {\n      if (elements[rowKey][tableColumns[i].key]) {\n        columnKey = tableColumns[i].key;\n        break;\n      }\n    }\n  } else {\n    for (var i = columnIndex; i >= 0; i -= 1) {\n      if (elements[rowKey][tableColumns[i].key]) {\n        columnKey = tableColumns[i].key;\n        break;\n      }\n    }\n  }\n  return columnKey;\n};\nvar shouldBeScrolled = function (elements, key1, key2, scrollToColumn) {\n  if (scrollToColumn && !elements[key1][key2]) {\n    return Object.keys(elements[key1]).some(function (column) {\n      return column.includes(STUB_TYPE);\n    });\n  }\n  return false;\n};\nvar convertPart = function (part, elements, tableBodyRows) {\n  if (part === DATA_TYPE && elements[tableBodyRows[0].key]) {\n    return DATA_TYPE;\n  }\n  if (elements[part]) {\n    return part;\n  }\n  return;\n};\nvar getLastPart = function (elements, tableBodyRows, partIndex) {\n  var index = partIndex || tableParts.length;\n  var part;\n  do {\n    index = index - 1;\n    part = convertPart(tableParts[index], elements, tableBodyRows);\n  } while (index > 0 && !part);\n  return part;\n};\nvar getRowKey = function (part, key, headerRowKey) {\n  if (headerRowKey && part === HEADING_TYPE) {\n    return headerRowKey;\n  }\n  return part === DATA_TYPE ? key : part;\n};\nvar getPrevPart = function (focusedElement, elements, tableBodyRows) {\n  var index = tableParts.findIndex(function (p) {\n    return p === focusedElement.part;\n  });\n  if (index === 0) {\n    return;\n  }\n  return getLastPart(elements, tableBodyRows, index);\n};\nvar getNextPart = function (focusedElement, elements, tableBodyRows) {\n  var index = tableParts.findIndex(function (p) {\n    return p === focusedElement.part;\n  });\n  if (index === tableParts.length - 1) {\n    return;\n  }\n  var part = tableParts.find(function (p, i) {\n    if (i > index) {\n      return convertPart(p, elements, tableBodyRows);\n    }\n    return false;\n  });\n  return part;\n};\nvar getCellNextPart = function (focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn) {\n  var part = getNextPart(focusedElement, elements, tableBodyRows);\n  if (!part) {\n    return {};\n  }\n  var rowKey = getRowKey(part, tableBodyRows[0].key);\n  var columnKey = tableColumns[0].key;\n  if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {\n    return {\n      element: {\n        rowKey: rowKey,\n        columnKey: columnKey,\n        part: part\n      },\n      scrolling: 'left'\n    };\n  }\n  return {\n    element: {\n      rowKey: rowKey,\n      columnKey: columnKey,\n      index: getIndexInnerElement(elements, rowKey, columnKey, 1),\n      part: part\n    }\n  };\n};\nvar getCellPrevPart = function (focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn) {\n  var part = getPrevPart(focusedElement, elements, tableBodyRows);\n  if (!part) {\n    return {};\n  }\n  var rowKey = getRowKey(part, tableBodyRows[tableBodyRows.length - 1].key);\n  var columnKeyIndex = tableColumns.length - 1;\n  var columnKey = tableColumns[columnKeyIndex].key;\n  if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {\n    return {\n      element: {\n        rowKey: rowKey,\n        columnKey: columnKey,\n        part: part\n      },\n      scrolling: 'right'\n    };\n  }\n  var nextColumnKey = getNextPrevClosestColumnKey(tableColumns, columnKeyIndex, rowKey, elements, -1);\n  return {\n    element: nextColumnKey ? {\n      rowKey: rowKey,\n      columnKey: nextColumnKey,\n      index: getIndexInnerElement(elements, rowKey, nextColumnKey, -1),\n      part: part\n    } : undefined\n  };\n};\nvar getPrevCellFromBody = function (columnIndex, rowIndex, tableColumns, tableBodyRows, focusedElement, elements, scrollToColumn) {\n  var prevRowKey = focusedElement.rowKey;\n  var prevColumnKey;\n  if (columnIndex === 0 && rowIndex === 0) {\n    return getCellPrevPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n  }\n  if (columnIndex === 0) {\n    prevRowKey = tableBodyRows[rowIndex - 1].key;\n    if (prevRowKey.includes(GROUP_TYPE)) {\n      prevColumnKey = getNextPrevClosestColumnKey(tableColumns, tableColumns.length - 1, prevRowKey, elements, -1);\n    } else {\n      prevColumnKey = tableColumns[tableColumns.length - 1].key;\n    }\n    if (prevColumnKey && shouldBeScrolled(elements, prevRowKey, prevColumnKey, scrollToColumn)) {\n      return {\n        element: {\n          rowKey: prevRowKey,\n          columnKey: prevColumnKey,\n          part: focusedElement.part\n        },\n        scrolling: 'right'\n      };\n    }\n  } else {\n    prevColumnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex - 1, prevRowKey, elements, -1);\n  }\n  return {\n    element: prevColumnKey ? {\n      rowKey: prevRowKey,\n      columnKey: prevColumnKey,\n      index: getIndexInnerElement(elements, prevRowKey, prevColumnKey, -1),\n      part: focusedElement.part\n    } : undefined\n  };\n};\nvar getPrevCellFromHeading = function (tableHeaderRows, tableColumns, columnIndex, _a, elements) {\n  var rowKey = _a.rowKey,\n    part = _a.part;\n  var prevColumnKey;\n  var prevRowKey;\n  var headIndex = getIndex(tableHeaderRows, rowKey);\n  prevColumnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex - 1, rowKey, elements, -1);\n  if (prevColumnKey) {\n    return {\n      element: {\n        columnKey: prevColumnKey,\n        rowKey: rowKey,\n        part: part,\n        index: getIndexInnerElement(elements, rowKey, prevColumnKey, -1)\n      }\n    };\n  }\n  if (headIndex > 0) {\n    var abort = false;\n    for (var i = headIndex - 1; i >= 0 && !abort; i -= 1) {\n      for (var j = tableColumns.length - 1; j >= 0; j -= 1) {\n        if (elements[tableHeaderRows[i].key][tableColumns[j].key]) {\n          prevColumnKey = tableColumns[j].key;\n          prevRowKey = tableHeaderRows[i].key;\n          abort = true;\n          break;\n        }\n      }\n    }\n    if (prevColumnKey && prevRowKey) {\n      return {\n        element: {\n          columnKey: prevColumnKey,\n          rowKey: prevRowKey,\n          part: part,\n          index: getIndexInnerElement(elements, prevRowKey, prevColumnKey, -1)\n        }\n      };\n    }\n  }\n  return {};\n};\nvar getPrevElement = function (focusedElement, tableBodyRows, tableColumns, tableHeaderRows, elements, scrollToColumn) {\n  var columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  var rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);\n  if (isDefined(focusedElement.index) && focusedElement.index > 0) {\n    return {\n      element: __assign(__assign({}, focusedElement), {\n        index: focusedElement.index - 1\n      })\n    };\n  }\n  if (focusedElement.part === DATA_TYPE) {\n    return getPrevCellFromBody(columnIndex, rowIndex, tableColumns, tableBodyRows, focusedElement, elements, scrollToColumn);\n  }\n  if (focusedElement.part === HEADING_TYPE) {\n    var cell = getPrevCellFromHeading(tableHeaderRows, tableColumns, columnIndex, focusedElement, elements);\n    if (cell.element) {\n      return {\n        element: __assign(__assign({}, cell.element), {\n          index: getIndexInnerElement(elements, cell.element.rowKey, cell.element.columnKey, -1)\n        })\n      };\n    }\n    return {\n      element: cell.element\n    };\n  }\n  if (columnIndex === 0) {\n    return getCellPrevPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n  }\n  var rowKey = focusedElement.part;\n  var columnKey = tableColumns[columnIndex - 1].key;\n  return {\n    element: {\n      rowKey: rowKey,\n      columnKey: columnKey,\n      index: getIndexInnerElement(elements, rowKey, columnKey, -1),\n      part: focusedElement.part\n    }\n  };\n};\nvar getNextCellFromBody = function (columnIndex, rowIndex, tableColumns, tableBodyRows, focusedElement, elements, scrollToColumn) {\n  var nextRowKey = focusedElement.rowKey;\n  var nextColumnKey;\n  if (columnIndex === tableColumns.length - 1 && rowIndex === tableBodyRows.length - 1) {\n    return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n  }\n  if (columnIndex === tableColumns.length - 1) {\n    nextRowKey = tableBodyRows[rowIndex + 1].key;\n    nextColumnKey = tableColumns[0].key;\n    if (shouldBeScrolled(elements, nextRowKey, nextColumnKey, scrollToColumn)) {\n      return {\n        element: {\n          rowKey: nextRowKey,\n          columnKey: nextColumnKey,\n          part: focusedElement.part\n        },\n        scrolling: 'left'\n      };\n    }\n  } else {\n    nextColumnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex + 1, nextRowKey, elements, 1);\n    if (!nextColumnKey) {\n      if (rowIndex === tableBodyRows.length - 1) {\n        return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n      }\n      nextRowKey = tableBodyRows[rowIndex + 1].key;\n      nextColumnKey = tableColumns[0].key;\n    }\n  }\n  return {\n    element: {\n      rowKey: nextRowKey,\n      columnKey: nextColumnKey,\n      index: getIndexInnerElement(elements, nextRowKey, nextColumnKey, 1),\n      part: focusedElement.part\n    }\n  };\n};\nvar getNextCellFromHeading = function (tableHeaderRows, tableBodyRows, tableColumns, columnIndex, focusedElement, elements, scrollToColumn) {\n  var headIndex = getIndex(tableHeaderRows, focusedElement.rowKey);\n  var nextRowKey;\n  var nextColumnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex + 1, focusedElement.rowKey, elements, 1);\n  if (nextColumnKey) {\n    return {\n      element: {\n        columnKey: nextColumnKey,\n        rowKey: focusedElement.rowKey,\n        part: focusedElement.part,\n        index: getIndexInnerElement(elements, focusedElement.rowKey, nextColumnKey, 1)\n      }\n    };\n  }\n  if (headIndex !== tableHeaderRows.length - 1) {\n    var abort = false;\n    for (var i = headIndex + 1; i <= tableHeaderRows.length - 1 && !abort; i += 1) {\n      for (var j = 0; j <= tableColumns.length - 1; j += 1) {\n        if (elements[tableHeaderRows[i].key][tableColumns[j].key]) {\n          nextColumnKey = tableColumns[j].key;\n          nextRowKey = tableHeaderRows[i].key;\n          abort = true;\n          break;\n        }\n      }\n    }\n    if (nextColumnKey && nextRowKey) {\n      return {\n        element: {\n          columnKey: nextColumnKey,\n          rowKey: nextRowKey,\n          part: focusedElement.part,\n          index: getIndexInnerElement(elements, nextRowKey, nextColumnKey, 1)\n        }\n      };\n    }\n  }\n  return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n};\nvar getNextElement = function (focusedElement, tableBodyRows, tableColumns, tableHeaderRows, elements, scrollToColumn) {\n  var innerElements = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey);\n  var columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  var rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);\n  if (hasInsideElements(innerElements, focusedElement.index)) {\n    return {\n      element: __assign(__assign({}, focusedElement), {\n        index: !isDefined(focusedElement.index) ? 0 : focusedElement.index + 1\n      })\n    };\n  }\n  if (focusedElement.part === DATA_TYPE) {\n    return getNextCellFromBody(columnIndex, rowIndex, tableColumns, tableBodyRows, focusedElement, elements, scrollToColumn);\n  }\n  if (focusedElement.part === HEADING_TYPE) {\n    return getNextCellFromHeading(tableHeaderRows, tableBodyRows, tableColumns, columnIndex, focusedElement, elements, scrollToColumn);\n  }\n  if (columnIndex === tableColumns.length - 1) {\n    return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n  }\n  var rowKey = focusedElement.rowKey;\n  var columnKey = tableColumns[columnIndex + 1].key;\n  return {\n    element: {\n      rowKey: rowKey,\n      columnKey: columnKey,\n      part: focusedElement.part,\n      index: getIndexInnerElement(elements, rowKey, columnKey, 1)\n    }\n  };\n};\nvar hasCellInput = function (innerElements) {\n  return innerElements.length ? innerElements[0].tagName === 'INPUT' : false;\n};\nvar cellEmptyOrHasSpanAndInput = function (elements, key1, key2) {\n  var innerElements = getInnerElements(elements, key1, key2);\n  if (innerElements.length) {\n    return isSpanInput(innerElements);\n  }\n  return true;\n};\nvar getCellRightLeft = function (direction, focusedElement, tableColumns, elements) {\n  if (focusedElement.part !== DATA_TYPE) {\n    return;\n  }\n  var columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  if (tableColumns[columnIndex + direction]) {\n    var columnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex + direction, focusedElement.rowKey, elements, direction);\n    if (columnKey) {\n      return {\n        rowKey: focusedElement.rowKey,\n        columnKey: columnKey,\n        part: focusedElement.part\n      };\n    }\n  }\n  return;\n};\nvar getFirstCell = function (elements, tableBodyRows, tableColumns, tableHeaderRows, scrollToColumn, withInnerElements) {\n  var part = tableParts.find(function (p) {\n    return convertPart(p, elements, tableBodyRows);\n  });\n  if (!part) {\n    return {};\n  }\n  var rowKey = getRowKey(part, tableBodyRows[0].key, tableHeaderRows[0].key);\n  var columnKey = tableColumns[0].key;\n  if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {\n    return {\n      element: {\n        rowKey: rowKey,\n        columnKey: columnKey,\n        part: part\n      },\n      scrolling: 'left'\n    };\n  }\n  return {\n    element: {\n      rowKey: rowKey,\n      columnKey: columnKey,\n      index: withInnerElements ? getIndexInnerElement(elements, rowKey, columnKey, 1) : undefined,\n      part: part\n    }\n  };\n};\nvar getLastCell = function (elements, tableBodyRows, tableColumns) {\n  var part = getLastPart(elements, tableBodyRows);\n  if (!part) {\n    return {};\n  }\n  var rowKey = getRowKey(part, tableBodyRows[tableBodyRows.length - 1].key);\n  var columnKey = getNextPrevClosestColumnKey(tableColumns, tableColumns.length - 1, rowKey, elements, -1);\n  return {\n    element: columnKey ? {\n      rowKey: rowKey,\n      columnKey: columnKey,\n      index: getIndexInnerElement(elements, rowKey, columnKey, 1),\n      part: part\n    } : undefined\n  };\n};\nvar getToolbarPagingElements = function (elements) {\n  return {\n    toolbarElements: elements.toolbar && getInnerElements(elements, 'toolbar', 'none'),\n    pagingElements: elements.paging && getInnerElements(elements, 'paging', 'none').filter(function (el) {\n      return !el.hasAttribute('disabled') && el.getAttribute('tabindex') !== '-1';\n    })\n  };\n};\nvar getFirstCellInLastPart = function (elements, tableBodyRows, tableColumns, scrollToColumn, withInnerElements) {\n  var lastPart = getLastPart(elements, tableBodyRows);\n  if (lastPart) {\n    var columnKey = tableColumns[0].key;\n    var rowKey = getRowKey(lastPart, tableBodyRows[0].key);\n    if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {\n      return {\n        element: {\n          rowKey: rowKey,\n          columnKey: columnKey,\n          part: lastPart\n        },\n        scrolling: 'left'\n      };\n    }\n    return {\n      element: {\n        columnKey: columnKey,\n        rowKey: rowKey,\n        index: withInnerElements ? getIndexInnerElement(elements, rowKey, columnKey, 1) : undefined,\n        part: lastPart\n      }\n    };\n  }\n  return {};\n};\nvar applyEnterAction = function (elements, _a, tableColumns, tableBodyRows, focusedElement) {\n  var commitChangedRows = _a.commitChangedRows,\n    stopEditCells = _a.stopEditCells,\n    startEditCells = _a.startEditCells;\n  if (!focusedElement) {\n    return;\n  }\n  var innerElements = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey);\n  var columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  var rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);\n  if (focusedElement.part === DATA_TYPE && commitChangedRows) {\n    if (focusedElement.index === 0) {\n      commitChangedRows({\n        rowIds: [tableBodyRows[rowIndex].rowId]\n      });\n      stopEditCells({\n        editingCells: [{\n          rowId: tableBodyRows[rowIndex].rowId,\n          columnName: tableColumns[columnIndex].column.name\n        }]\n      });\n      return {\n        part: focusedElement.part,\n        columnKey: focusedElement.columnKey,\n        rowKey: focusedElement.rowKey\n      };\n    }\n    startEditCells({\n      editingCells: [{\n        rowId: tableBodyRows[rowIndex].rowId,\n        columnName: tableColumns[columnIndex].column.name\n      }]\n    });\n    return {\n      part: focusedElement.part,\n      columnKey: focusedElement.columnKey,\n      rowKey: focusedElement.rowKey,\n      index: 0\n    };\n  }\n  if (!isDefined(focusedElement.index) && innerElements.length && isSpanInput(innerElements)) {\n    if (innerElements[0].tagName === 'SPAN') {\n      innerElements[0].click();\n    }\n    return {\n      part: focusedElement.part,\n      columnKey: focusedElement.columnKey,\n      rowKey: focusedElement.rowKey,\n      index: 0\n    };\n  }\n  if (focusedElement.index === 0 && hasCellInput(innerElements)) {\n    return {\n      part: focusedElement.part,\n      columnKey: focusedElement.columnKey,\n      rowKey: focusedElement.rowKey\n    };\n  }\n  return;\n};\nvar applyEscapeAction = function (elements, _a, tableColumns, tableBodyRows, focusedElement) {\n  var cancelChangedRows = _a.cancelChangedRows,\n    stopEditCells = _a.stopEditCells;\n  if (!focusedElement) {\n    return;\n  }\n  var innerElements = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey);\n  var columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  var rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);\n  if (focusedElement.index === 0 && hasCellInput(innerElements)) {\n    if (focusedElement.part === DATA_TYPE && cancelChangedRows) {\n      cancelChangedRows({\n        rowIds: [tableBodyRows[rowIndex].rowId]\n      });\n      stopEditCells({\n        editingCells: [{\n          rowId: tableBodyRows[rowIndex].rowId,\n          columnName: tableColumns[columnIndex].column.name\n        }]\n      });\n    }\n    return {\n      part: focusedElement.part,\n      columnKey: focusedElement.columnKey,\n      rowKey: focusedElement.rowKey\n    };\n  }\n  return;\n};\nvar actionOnCheckbox = function (elements, focusedElement) {\n  if (!focusedElement || isDefined(focusedElement.index)) {\n    return;\n  }\n  var el = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey, 'input').filter(function (element) {\n    return element.type === 'checkbox';\n  });\n  if (el[0]) {\n    el[0].click();\n  }\n};\nvar actionOnTreeMode = function (elements, expandedRowIds, direction, focusedElement) {\n  if (!focusedElement || isDefined(focusedElement.index) || !expandedRowIds) {\n    return;\n  }\n  var el = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey, 'button, i');\n  var index = getIndexFromKey(focusedElement.rowKey);\n  if (direction > 0 && expandedRowIds.indexOf(index) === -1 || direction < 0 && expandedRowIds.indexOf(index) > -1) {\n    if (el[0]) {\n      el[0].click();\n    }\n  }\n};\nvar getInnerElements = function (elements, key1, key2, query) {\n  if (query === void 0) {\n    query = '[tabIndex], input, button, a';\n  }\n  return Array.from(elements[key1][key2][0].current.querySelectorAll(query)).filter(function (el) {\n    return !el.hasAttribute('disabled') && el.getAttribute('tabindex') !== '-1';\n  });\n};\nvar getCellTopBottom = function (direction, focusedElement, tableBodyRows, tableColumns, elements) {\n  if (focusedElement.part !== DATA_TYPE) {\n    return;\n  }\n  var columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  var rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);\n  if (tableBodyRows[rowIndex + direction]) {\n    var columnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex, tableBodyRows[rowIndex + direction].key, elements, -1);\n    if (columnKey) {\n      return {\n        rowKey: tableBodyRows[rowIndex + direction].key,\n        columnKey: columnKey,\n        part: focusedElement.part\n      };\n    }\n  }\n  return;\n};\nvar isCtrlMetaKey = function (event) {\n  return event.ctrlKey || event.metaKey;\n};\nvar getIndexFromKey = function (key) {\n  var array = key.split('_');\n  return Number(array[array.length - 1]);\n};\nvar getCellNextPrevPart = function (focusedElement, elements, tableBodyRows, tableColumns, direction, scrollToColumn) {\n  var part = direction > 0 ? getNextPart(focusedElement, elements, tableBodyRows) : getPrevPart(focusedElement, elements, tableBodyRows);\n  if (part) {\n    var rowKey = getRowKey(part, tableBodyRows[0].key);\n    var columnKey = tableColumns[0].key;\n    return {\n      element: {\n        part: part,\n        rowKey: rowKey,\n        columnKey: columnKey\n      },\n      scrolling: shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn) ? 'left' : undefined\n    };\n  }\n  return {};\n};\nvar applyFocusOnToolbarPaging = function (elements, direction) {\n  if (direction > 0 && elements.paging) {\n    getInnerElements(elements, 'paging', 'none')[0].focus();\n  }\n  if (direction < 0 && elements.toolbar) {\n    getInnerElements(elements, 'toolbar', 'none')[0].focus();\n  }\n};\nvar getClosestCellByRow = function (tableBodyRows, focusedElement, elements) {\n  var currentIndex = getIndexFromKey(focusedElement.rowKey);\n  var bodyRow = tableBodyRows.find(function (row) {\n    return getIndexFromKey(row.key) > currentIndex;\n  });\n  var rowKey = bodyRow ? bodyRow.key : tableBodyRows[tableBodyRows.length - 1].key;\n  var columnKey = focusedElement.columnKey;\n  return {\n    rowKey: rowKey,\n    columnKey: columnKey,\n    part: focusedElement.part,\n    index: getIndexInnerElement(elements, rowKey, columnKey, 1)\n  };\n};\nvar getNextFocusedCell = function (tableColumns, tableBodyRows, tableHeaderRows, expandedRowIds, elements, event, inlineEditing, focusedElement, scrollToColumn) {\n  if (!focusedElement) {\n    var _a = getToolbarPagingElements(elements),\n      toolbarElements = _a.toolbarElements,\n      pagingElements = _a.pagingElements;\n    var hasFocus = function (innerElements) {\n      return innerElements.some(function (el) {\n        return event.target === el;\n      });\n    };\n    if (isCtrlMetaKey(event)) {\n      if (event.key === 'ArrowDown' && (toolbarElements && hasFocus(toolbarElements) || !toolbarElements)) {\n        return getFirstCell(elements, tableBodyRows, tableColumns, tableHeaderRows, scrollToColumn);\n      }\n      if (event.key === 'ArrowUp' && (pagingElements && hasFocus(pagingElements) || !pagingElements)) {\n        return getFirstCellInLastPart(elements, tableBodyRows, tableColumns, scrollToColumn);\n      }\n    } else if (event.key === 'Tab') {\n      if (toolbarElements && event.target === toolbarElements[toolbarElements.length - 1] && !event.shiftKey) {\n        return getFirstCell(elements, tableBodyRows, tableColumns, tableHeaderRows, scrollToColumn, true);\n      }\n      if (pagingElements && event.target === pagingElements[0] && event.shiftKey) {\n        if (scrollToColumn) {\n          return getFirstCellInLastPart(elements, tableBodyRows, tableColumns, scrollToColumn, true);\n        }\n        return getLastCell(elements, tableBodyRows, tableColumns);\n      }\n      var element = (!event.shiftKey ? getFirstCell(elements, tableBodyRows, tableColumns, tableHeaderRows, undefined, true) : getLastCell(elements, tableBodyRows, tableColumns)).element;\n      if (element && event.target === elements[element.rowKey][element.columnKey][0].current) {\n        return {\n          element: element\n        };\n      }\n    }\n    return {};\n  }\n  var cell;\n  switch (event.key) {\n    case 'Enter':\n      cell = {\n        element: applyEnterAction(elements, inlineEditing, tableColumns, tableBodyRows, focusedElement)\n      };\n      break;\n    case 'Escape':\n      cell = {\n        element: applyEscapeAction(elements, inlineEditing, tableColumns, tableBodyRows, focusedElement)\n      };\n      break;\n    case ' ':\n      actionOnCheckbox(elements, focusedElement);\n      break;\n    case 'Tab':\n      if (event.shiftKey) {\n        cell = getPrevElement(focusedElement, tableBodyRows, tableColumns, tableHeaderRows, elements, scrollToColumn);\n      } else {\n        cell = getNextElement(focusedElement, tableBodyRows, tableColumns, tableHeaderRows, elements, scrollToColumn);\n      }\n      break;\n    case 'ArrowUp':\n      if (isCtrlMetaKey(event)) {\n        cell = getCellNextPrevPart(focusedElement, elements, tableBodyRows, tableColumns, -1, scrollToColumn);\n        if (!cell.element) {\n          applyFocusOnToolbarPaging(elements, -1);\n        }\n      } else {\n        cell = {\n          element: getCellTopBottom(-1, focusedElement, tableBodyRows, tableColumns, elements)\n        };\n      }\n      break;\n    case 'ArrowDown':\n      if (isCtrlMetaKey(event)) {\n        cell = getCellNextPrevPart(focusedElement, elements, tableBodyRows, tableColumns, 1, scrollToColumn);\n        if (!cell.element) {\n          applyFocusOnToolbarPaging(elements, 1);\n        }\n      } else {\n        cell = {\n          element: getCellTopBottom(1, focusedElement, tableBodyRows, tableColumns, elements)\n        };\n      }\n      break;\n    case 'ArrowLeft':\n      if (isCtrlMetaKey(event)) {\n        actionOnTreeMode(elements, expandedRowIds, -1, focusedElement);\n      } else {\n        cell = {\n          element: getCellRightLeft(-1, focusedElement, tableColumns, elements)\n        };\n      }\n      break;\n    case 'ArrowRight':\n      if (isCtrlMetaKey(event)) {\n        actionOnTreeMode(elements, expandedRowIds, 1, focusedElement);\n      } else {\n        cell = {\n          element: getCellRightLeft(1, focusedElement, tableColumns, elements)\n        };\n      }\n      break;\n  }\n  return cell || {};\n};\nvar getPart = function (key) {\n  if (tableParts.find(function (t) {\n    return t === key;\n  })) {\n    return key;\n  }\n  if (key.includes(BAND_TYPE)) {\n    return HEADING_TYPE;\n  }\n  return DATA_TYPE;\n};\nvar getIndexToFocus = function (key1, key2, elements, event, _a, part) {\n  var startEditCells = _a.startEditCells;\n  if (startEditCells && part === DATA_TYPE) {\n    return 0;\n  }\n  var innerElements = getInnerElements(elements, key1, key2);\n  var index = innerElements.findIndex(function (el) {\n    return event.target === el;\n  });\n  return index !== -1 ? index : undefined;\n};\nvar filterHeaderRows = function (tableHeaderRows) {\n  return tableHeaderRows.filter(function (row) {\n    return row.key.includes(BAND_TYPE) || row.key.includes(HEADING_TYPE);\n  });\n};\nvar isRowFocused = function (tableRow, focusedRowKey) {\n  if (focusedRowKey) {\n    return tableRow.key === focusedRowKey;\n  }\n  return false;\n};\nvar isCellExist = function (elements, focusedElement) {\n  return !!(elements[focusedElement.rowKey] && elements[focusedElement.rowKey][focusedElement.columnKey]);\n};\nvar isTabArrowUpDown = function (event) {\n  return event.key === 'Tab' || isCtrlMetaKey(event) && (event.key === 'ArrowDown' || event.key === 'ArrowUp');\n};\nvar focus = function (elements, focusedElement, prevFocusedElement, onFocusedCellChange) {\n  if (!focusedElement || !elements[focusedElement.rowKey] || !elements[focusedElement.rowKey][focusedElement.columnKey]) {\n    return;\n  }\n  var el = focusedElement.index === undefined ? elements[focusedElement.rowKey][focusedElement.columnKey][0] : getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey)[focusedElement.index];\n  if (el) {\n    el.focus ? el.focus() : el.current.focus();\n    if (onFocusedCellChange && ((prevFocusedElement === null || prevFocusedElement === void 0 ? void 0 : prevFocusedElement.rowKey) !== focusedElement.rowKey || (prevFocusedElement === null || prevFocusedElement === void 0 ? void 0 : prevFocusedElement.columnKey) !== focusedElement.columnKey)) {\n      onFocusedCellChange({\n        rowKey: focusedElement.rowKey,\n        columnKey: focusedElement.columnKey\n      });\n    }\n  }\n};\nvar isCellFocused = function (row, column, focusedElement) {\n  if (!focusedElement || isDefined(focusedElement.index)) {\n    return false;\n  }\n  return focusedElement.rowKey === row.key && focusedElement.columnKey === column.key;\n};\nvar getFocusing = function (tableBodyRows, focusedElement) {\n  if (!focusedElement) {\n    return [];\n  }\n  var focusedRow = tableBodyRows.find(function (row) {\n    return row.key === focusedElement.rowKey;\n  });\n  return focusedRow ? [focusedRow.rowId] : [];\n};\nvar getTargetColumnGeometries = function (columnGeometries, sourceIndex) {\n  var sourceWidth = columnGeometries[sourceIndex].right - columnGeometries[sourceIndex].left;\n  var getWidthDifference = function (index) {\n    return columnGeometries[index].right - columnGeometries[index].left - sourceWidth;\n  };\n  return columnGeometries.map(function (_a, targetIndex) {\n    var top = _a.top,\n      right = _a.right,\n      bottom = _a.bottom,\n      left = _a.left;\n    var leftBorder = left;\n    if (targetIndex > 0 && targetIndex <= sourceIndex) {\n      leftBorder = Math.min(leftBorder, leftBorder - getWidthDifference(targetIndex - 1));\n    }\n    if (targetIndex > sourceIndex) {\n      leftBorder = Math.max(leftBorder, leftBorder + getWidthDifference(targetIndex));\n    }\n    var rightBorder = right;\n    if (targetIndex < columnGeometries.length - 1 && targetIndex >= sourceIndex) {\n      rightBorder = Math.max(rightBorder, rightBorder + getWidthDifference(targetIndex + 1));\n    }\n    if (targetIndex < sourceIndex) {\n      rightBorder = Math.min(rightBorder, rightBorder - getWidthDifference(targetIndex));\n    }\n    return {\n      top: top,\n      bottom: bottom,\n      right: rightBorder,\n      left: leftBorder\n    };\n  });\n};\nvar getCellGeometries = function (node) {\n  var _a, _b;\n  var _c = node.getBoundingClientRect(),\n    left = _c.left,\n    right = _c.right,\n    width = _c.width;\n  var styleLeft = parseInt((_a = node.style.left) === null || _a === void 0 ? void 0 : _a.toString().replace('px', ''), 10);\n  var styleRight = parseInt((_b = node.style.right) === null || _b === void 0 ? void 0 : _b.toString().replace('px', ''), 10);\n  if (!isNaN(styleLeft)) {\n    var calculatedLeft = Math.max(styleLeft, left);\n    return {\n      left: calculatedLeft,\n      right: calculatedLeft + width,\n      isFixed: true\n    };\n  }\n  if (!isNaN(styleRight)) {\n    // NOTE: get tableContainer (parent of first DIV element) to calculate 'right' value\n    var tableContainer = node;\n    while (tableContainer && tableContainer.nodeName !== 'DIV') {\n      tableContainer = tableContainer.parentNode;\n    }\n    tableContainer = tableContainer === null || tableContainer === void 0 ? void 0 : tableContainer.parentNode;\n    if (tableContainer) {\n      var tableWidth = tableContainer.getBoundingClientRect().width;\n      var calculatedRight = Math.min(tableWidth - styleRight, right);\n      return {\n        left: calculatedRight - width,\n        right: calculatedRight,\n        isFixed: true\n      };\n    }\n  }\n  return {\n    left: left,\n    right: right\n  };\n};\nvar getTableColumnGeometries = function (columns, tableWidth) {\n  var columnWidths = columns.map(function (column) {\n    return column.width;\n  });\n  var freeSpace = tableWidth;\n  var restrictedSpace = columnWidths.reduce(function (accum, width) {\n    return accum + (typeof width === 'number' ? width : 0);\n  }, 0);\n  var freeSpacePortions = columnWidths.reduce(function (accum, width) {\n    return accum + (typeof width !== 'number' ? 1 : 0);\n  }, 0);\n  var freeSpacePortion = (freeSpace - restrictedSpace) / freeSpacePortions;\n  var lastRightPosition = 0;\n  return columnWidths.map(function (width) {\n    return typeof width !== 'number' ? freeSpacePortion : width;\n  }).map(function (width) {\n    lastRightPosition += width;\n    return {\n      left: lastRightPosition - width,\n      right: lastRightPosition\n    };\n  });\n};\nvar getTableTargetColumnIndex = function (columnGeometries, offset) {\n  var indexes = columnGeometries.reduce(function (acc, _a, index) {\n    var left = _a.left,\n      right = _a.right;\n    if (offset >= left && offset < right) {\n      acc.push(index);\n    }\n    return acc;\n  }, []);\n  if (columnGeometries.some(function (_a) {\n    var left = _a.left,\n      right = _a.right;\n    return left <= 0 && right <= 0;\n  })) {\n    if (indexes.some(function (index) {\n      return columnGeometries[index].isFixed || columnGeometries[index].left <= 0 && columnGeometries[index].right <= 0;\n    })) {\n      return -1;\n    }\n  }\n  if (indexes.length === 2) {\n    return indexes.find(function (index) {\n      return columnGeometries[index].isFixed;\n    });\n  }\n  if (indexes.length === 1) {\n    return indexes[0];\n  }\n  return -1;\n};\nvar ANIMATION_DURATION = 200;\nvar getAnimationProgress = function (animation) {\n  return (new Date().getTime() - animation.startTime) / ANIMATION_DURATION;\n};\nvar getAnimations = function (prevColumns, nextColumns, tableWidth, prevAnimations) {\n  var resizing = prevColumns.map(function (column) {\n    return column.key;\n  }).join() === nextColumns.map(function (column) {\n    return column.key;\n  }).join();\n  var prevColumnGeometries = new Map(getTableColumnGeometries(prevColumns, tableWidth).map(function (geometry, index) {\n    return [prevColumns[index].key, geometry];\n  }).map(function (_a) {\n    var _b = __read(_a, 2),\n      key = _b[0],\n      geometry = _b[1];\n    var animation = prevAnimations.get(key);\n    if (!animation) return [key, geometry];\n    var progress = easeOutCubic(getAnimationProgress(animation));\n    var _c = animation.left,\n      to = _c.to,\n      from = _c.from;\n    var left = (to - from) * progress + from;\n    return [key, {\n      left: left,\n      right: geometry.right - (geometry.left - left)\n    }];\n    // tslint:disable-next-line:array-type\n  }));\n\n  var nextColumnGeometries = new Map(getTableColumnGeometries(nextColumns, tableWidth)\n  // tslint:disable-next-line:array-type\n  .map(function (geometry, index) {\n    return [nextColumns[index].key, geometry];\n  }));\n  return new Map(__spread(nextColumnGeometries.keys()).map(function (key) {\n    var prev = prevColumnGeometries.get(key);\n    var next = nextColumnGeometries.get(key);\n    var result = {\n      startTime: new Date().getTime(),\n      style: {}\n    };\n    var takePrevColumnIntoAccount = !!prevAnimations.get(key) || prev && !resizing;\n    if (Math.abs((takePrevColumnIntoAccount ? prev.left : next.left) - next.left) > 1) {\n      result.left = {\n        from: prev.left,\n        to: next.left\n      };\n    }\n    return [key, result];\n  }).filter(function (animation) {\n    return animation[1].left;\n  }));\n};\nvar filterActiveAnimations = function (animations) {\n  return new Map(__spread(animations.entries()).filter(function (_a) {\n    var _b = __read(_a, 2),\n      animation = _b[1];\n    return getAnimationProgress(animation) < 1;\n  }));\n};\nvar evalAnimations = function (animations) {\n  return new Map(__spread(animations.entries()).map(function (_a) {\n    var _b = __read(_a, 2),\n      key = _b[0],\n      animation = _b[1];\n    var progress = easeOutCubic(getAnimationProgress(animation));\n    var result = __assign({}, animation.style);\n    if (animation.left) {\n      var offset = (animation.left.to - animation.left.from) * (progress - 1);\n      result.transform = \"translateX(\" + offset + \"px)\";\n    }\n    return [key, result];\n  }));\n};\nvar isOnTheSameLine = function (geometry, y) {\n  return y >= geometry.top && y <= geometry.bottom;\n};\nvar rectToObject = function (_a) {\n  var top = _a.top,\n    right = _a.right,\n    bottom = _a.bottom,\n    left = _a.left;\n  return {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left\n  };\n};\nvar collapseGapsBetweenItems = function (geometries) {\n  return geometries.map(function (geometry, index) {\n    if (index !== geometries.length - 1 && geometry.top === geometries[index + 1].top) {\n      return __assign(__assign({}, geometry), {\n        right: geometries[index + 1].left\n      });\n    }\n    return geometry;\n  });\n};\nvar getGroupCellTargetIndex = function (geometries, sourceIndex, _a) {\n  var x = _a.x,\n    y = _a.y;\n  if (geometries.length === 0) return 0;\n  var targetGeometries = sourceIndex !== -1 ? getTargetColumnGeometries(geometries, sourceIndex) : geometries.map(rectToObject);\n  var targetIndex = collapseGapsBetweenItems(targetGeometries).findIndex(function (geometry, index) {\n    var inVerticalBounds = isOnTheSameLine(geometry, y);\n    var inHorizontalBounds = x >= geometry.left && x <= geometry.right;\n    var shouldGoFirst = index === 0 && x < geometry.left;\n    var shouldGoOnLineBreak = !inVerticalBounds && !!geometries[index - 1] && isOnTheSameLine(geometries[index - 1], y);\n    return inVerticalBounds && inHorizontalBounds || shouldGoFirst || shouldGoOnLineBreak;\n  });\n  return targetIndex === -1 ? geometries.length : targetIndex;\n};\n\n/** @internal */\nvar arraysEqual = function (arrA, arrB, comparator) {\n  if (comparator === void 0) {\n    comparator = function (a, b) {\n      return a === b;\n    };\n  }\n  if (arrA.length !== arrB.length) {\n    return false;\n  }\n  for (var i = 0; i < arrA.length; i += 1) {\n    if (!comparator(arrA[i], arrB[i])) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/** @internal */\nvar emptyViewport = {\n  columns: [[0, 0]],\n  rows: [0, 0],\n  headerRows: [0, 0],\n  footerRows: [0, 0],\n  top: 0,\n  left: 0,\n  width: 800,\n  height: 600\n};\nvar TOP_POSITION = Symbol('top');\nvar BOTTOM_POSITION = Symbol('bottom');\nvar LEFT_POSITION = Symbol('left');\nvar RIGHT_POSITION = Symbol('right');\nvar VALID_UNITS$2 = ['px', ''];\n/* tslint:disable max-line-length */\nvar VIRTUAL_TABLE_ERROR = 'The columnExtension property of the VirtualTable plugin is given an invalid value.';\nvar getViewport = function (state, getters, getRowHeight, getColumnWidth) {\n  var viewportTop = state.viewportTop,\n    skipItems = state.skipItems,\n    viewportLeft = state.viewportLeft,\n    containerWidth = state.containerWidth,\n    containerHeight = state.containerHeight;\n  var loadedRowsStart = getters.loadedRowsStart,\n    tableBodyRows = getters.bodyRows,\n    tableColumns = getters.columns,\n    _a = getters.headerRows,\n    tableHeaderRows = _a === void 0 ? [] : _a,\n    _b = getters.footerRows,\n    tableFooterRows = _b === void 0 ? [] : _b,\n    isDataRemote = getters.isDataRemote,\n    viewport = getters.viewport;\n  var rows = getRowsVisibleBoundary(tableBodyRows, viewportTop, containerHeight, getRowHeight, skipItems, loadedRowsStart, isDataRemote);\n  var headerRows = [0, tableHeaderRows.length ? tableHeaderRows.length - 1 : 0];\n  var footerRows = [0, tableFooterRows.length ? tableFooterRows.length - 1 : 0];\n  var columns = getColumnBoundaries(tableColumns, viewportLeft, containerWidth, getColumnWidth);\n  // NOTE: prevent unnecessary updates\n  // e.g. when rows changed but bounds remain the same.\n  var result = viewport;\n  if (viewportTop !== viewport.top) {\n    result = __assign(__assign({}, result), {\n      top: viewportTop\n    });\n  }\n  if (viewportLeft !== viewport.left) {\n    result = __assign(__assign({}, result), {\n      left: viewportLeft\n    });\n  }\n  if (containerWidth !== viewport.width) {\n    result = __assign(__assign({}, result), {\n      width: containerWidth\n    });\n  }\n  if (containerHeight !== viewport.height) {\n    result = __assign(__assign({}, result), {\n      height: containerHeight\n    });\n  }\n  if (!arraysEqual(rows, viewport.rows)) {\n    result = __assign(__assign({}, result), {\n      rows: rows\n    });\n  }\n  if (!arraysEqual(headerRows, viewport.headerRows)) {\n    result = __assign(__assign({}, result), {\n      headerRows: headerRows\n    });\n  }\n  if (!arraysEqual(footerRows, viewport.footerRows)) {\n    result = __assign(__assign({}, result), {\n      footerRows: footerRows\n    });\n  }\n  if (!arraysEqual(columns, viewport.columns, arraysEqual)) {\n    result = __assign(__assign({}, result), {\n      columns: columns\n    });\n  }\n  return result;\n};\nvar checkColumnWidths = function (tableColumns) {\n  return tableColumns.reduce(function (acc, tableColumn) {\n    var width = tableColumn.width;\n    if (typeof width === 'string') {\n      var numb = parseInt(width, 10);\n      var unit_1 = numb ? width.substr(numb.toString().length) : width;\n      var isValidUnit = VALID_UNITS$2.some(function (validUnit) {\n        return validUnit === unit_1;\n      });\n      if (!isValidUnit) {\n        throw new Error(VIRTUAL_TABLE_ERROR);\n      }\n      acc.push(__assign(__assign({}, tableColumn), {\n        width: numb\n      }));\n    } else {\n      acc.push(tableColumn);\n    }\n    return acc;\n  }, []);\n};\nvar calculateScrollHeight = function (rowHeight, index) {\n  return index > -1 ? rowHeight * index : undefined;\n};\nvar getScrollTop = function (rows, rowsCount, rowId, rowHeight, isDataRemote) {\n  if (rowId === TOP_POSITION) {\n    return 0;\n  }\n  if (rowId === BOTTOM_POSITION) {\n    return rowsCount * rowHeight;\n  }\n  var searchIndexRequired = !isDataRemote && rowId !== undefined;\n  var indexById = searchIndexRequired ? rows.findIndex(function (row) {\n    return row.rowId === rowId;\n  }) : undefined;\n  return calculateScrollHeight(rowHeight, indexById);\n};\nvar getScrollLeft = function (columnCount, columnWidth, columnId) {\n  if (!columnId) {\n    return;\n  }\n  if (columnId === LEFT_POSITION) {\n    return 0;\n  }\n  return columnCount * columnWidth;\n};\nvar getTopRowId = function (viewport, tableBodyRows, isDataRemote) {\n  var hasViewportRows = viewport && viewport.rows;\n  var hasBodyRows = tableBodyRows && tableBodyRows.length;\n  if (hasViewportRows && hasBodyRows && !isDataRemote) {\n    var index = viewport.rows[0];\n    return index < tableBodyRows.length ? tableBodyRows[index].rowId : undefined;\n  }\n  return undefined;\n};\nvar isColumnsWidthDifferent = function (prevColumns, columns) {\n  return prevColumns.some(function (column) {\n    var currentColumn = columns.find(function (c) {\n      return c.key === column.key;\n    });\n    return currentColumn ? currentColumn.width !== column.width : true;\n  });\n};\nvar virtualRowsWithCache = function (skip, rows, cache) {\n  var rowsInterval = intervalUtil.getRowsInterval({\n    skip: skip,\n    rows: rows\n  });\n  var cacheInterval = intervalUtil.getRowsInterval(cache);\n  return mergeRows(rowsInterval, cacheInterval, rows, cache.rows, skip, cache.skip);\n};\nvar plainRows = function (virtualRows, availableRowCount) {\n  return virtualRows.rows.length > availableRowCount ? virtualRows.rows.slice(0, availableRowCount) : virtualRows.rows;\n};\nvar loadedRowsStart = function (virtualRows) {\n  return virtualRows.skip;\n};\nvar ROOT_GROUP = '__root__';\nvar DEFAULT_COLUMN_WIDTH = 150;\nvar exportHeader = function (worksheet, columns) {\n  var cols = columns.map(function (_a) {\n    var column = _a.column,\n      width = _a.width;\n    return {\n      width: (width || DEFAULT_COLUMN_WIDTH) / 8,\n      key: column === null || column === void 0 ? void 0 : column.name\n    };\n  });\n  worksheet.columns = cols;\n  var headerRow = columns.reduce(function (acc, _a) {\n    var _b;\n    var _c = _a.column,\n      _d = _c === void 0 ? {} : _c,\n      name = _d.name,\n      title = _d.title;\n    return __assign(__assign({}, acc), (_b = {}, _b[name] = title, _b));\n  }, {});\n  worksheet.addRow(headerRow);\n  worksheet.views.push({\n    state: 'frozen',\n    ySplit: worksheet.lastRow.number\n  });\n};\nvar findRanges = function (groupTree, compoundKey, level, maxLevel, result) {\n  if (result === void 0) {\n    result = [];\n  }\n  if (level !== maxLevel) {\n    var ranges = groupTree[compoundKey].reduce(function (acc, groupKey) {\n      return __spread(acc, findRanges(groupTree, groupKey, level + 1, maxLevel, result));\n    }, []);\n    return __spread(result, ranges);\n  }\n  return __spread(result, [groupTree[compoundKey]]);\n};\nvar exportRows = function (worksheet, allRows, dataColumns, columns, isGroupRow, outlineLevels, rowsOffset, getCellValue, getCloseGroup, customizeCell) {\n  var currentLevel = 0;\n  var openGroups = [];\n  var closeGroup = getCloseGroup(rowsOffset);\n  allRows.forEach(function (row) {\n    var _a;\n    var _b;\n    var excelRow;\n    if (isGroupRow && isGroupRow(row)) {\n      currentLevel = outlineLevels[row.groupedBy];\n      // close nested groups first\n      openGroups.slice(currentLevel).reverse().forEach(closeGroup);\n      openGroups = openGroups.slice(0, currentLevel);\n      openGroups[currentLevel] = {\n        groupedBy: row.groupedBy,\n        compoundKey: row.compoundKey\n      };\n      // add group row\n      var title = (_b = dataColumns.find(function (_a) {\n        var name = _a.name;\n        return name === row.groupedBy;\n      })) === null || _b === void 0 ? void 0 : _b.title;\n      excelRow = (_a = {}, _a[columns[0].column.name] = title + \": \" + row.value, _a);\n      worksheet.addRow(excelRow);\n      var lastIndex = worksheet.lastRow.number;\n      // merge into single cell\n      worksheet.mergeCells(lastIndex, 1, lastIndex, columns.length);\n      worksheet.lastRow.getCell(1).font = {\n        bold: true\n      };\n      if (currentLevel > 0) {\n        worksheet.lastRow.outlineLevel = currentLevel;\n      }\n      currentLevel += 1;\n    } else {\n      excelRow = columns.reduce(function (acc, _a) {\n        var _b;\n        var column = _a.column;\n        return __assign(__assign({}, acc), column ? (_b = {}, _b[column.name] = getCellValue(row, column.name), _b) : null);\n      }, {});\n      worksheet.addRow(excelRow);\n      worksheet.lastRow.outlineLevel = currentLevel;\n    }\n    worksheet.lastRow.eachCell(function (cell, colNumber) {\n      customizeCell(cell, row, columns[colNumber - 1].column);\n    });\n  });\n  openGroups.reverse().forEach(closeGroup);\n};\nvar closeSheet = function (worksheet, groupTree, maxGroupLevel, rowsOffset, totalSummaryItems, exportSummary) {\n  exportSummaryItems(worksheet, groupTree, totalSummaryItems, ROOT_GROUP, -1, rowsOffset, maxGroupLevel, exportSummary);\n};\nvar normalizeRanges = function (ranges, offset) {\n  return ranges.map(function (range) {\n    return range.map(function (index) {\n      return +index + offset;\n    });\n  });\n};\nvar exportSummaryItems = function (worksheet, groupTree, summaryItems, groupKey, groupLevel, rowsOffset, maxGroupLevel, exportSummary) {\n  if (!summaryItems) return;\n  worksheet.addRow({});\n  var ranges = normalizeRanges(findRanges(groupTree, groupKey, groupLevel, maxGroupLevel), rowsOffset);\n  summaryItems.forEach(function (s) {\n    exportSummary(s, ranges);\n  });\n};\nvar removeEmptyGroups = function (rows, grouping, isGroupRow) {\n  if (!grouping) return rows;\n  var groupingColumns = grouping.map(function (_a) {\n    var columnName = _a.columnName;\n    return columnName;\n  });\n  var result = [];\n  var groupChain = [];\n  rows.forEach(function (row) {\n    if (isGroupRow(row)) {\n      var level = groupingColumns.indexOf(row.groupedBy);\n      if (level === groupChain.length) {\n        groupChain.push(row);\n      } else {\n        groupChain = __spread(groupChain.slice(0, level), [row]);\n      }\n    } else {\n      if (groupChain.length > 0) {\n        result.push.apply(result, __spread(groupChain));\n        groupChain = Array.from({\n          length: groupChain.length\n        });\n      }\n      result.push(row);\n    }\n  });\n  return result.filter(function (row) {\n    return !!row;\n  });\n};\nvar groupOutlineLevels = function (grouping) {\n  return (grouping === null || grouping === void 0 ? void 0 : grouping.reduce(function (acc, _a, index) {\n    var _b;\n    var columnName = _a.columnName;\n    return __assign(__assign({}, acc), (_b = {}, _b[columnName] = index, _b));\n  }, {})) || {};\n};\nvar filterSelectedRows = function (rows, selection, getRowId, isGroupRow) {\n  var selectionSet = new Set(selection);\n  return rows.filter(function (row) {\n    return isGroupRow && isGroupRow(row) || selectionSet.has(getRowId(row));\n  });\n};\nvar rowsToExport = function (rows, selection, grouping, getCollapsedRows, getRowId, isGroupRow) {\n  var expandRows = function (collapsedRows) {\n    return collapsedRows.reduce(function (acc, row) {\n      return __spread(acc, [row], expandRows(getCollapsedRows(row) || []));\n    }, []);\n  };\n  var expandedRows = getCollapsedRows ? expandRows(rows) : rows;\n  if (!selection) {\n    return expandedRows;\n  }\n  var filteredRows = filterSelectedRows(expandedRows, selection, getRowId, isGroupRow);\n  return removeEmptyGroups(filteredRows, grouping, isGroupRow);\n};\nvar buildGroupTree = function (rows, outlineLevels, grouping, isGroupRow, groupSummaryItems) {\n  var _a;\n  var groupTree = (_a = {}, _a[ROOT_GROUP] = [], _a);\n  if (!(grouping === null || grouping === void 0 ? void 0 : grouping.length)) {\n    groupTree[ROOT_GROUP] = [0, rows.length - 1];\n    return groupTree;\n  }\n  var maxLevel = Object.keys(outlineLevels).length - 1;\n  var groupSummaryExists = !!groupSummaryItems;\n  var parentChain = {\n    '-1': ROOT_GROUP\n  };\n  var lastDataIndex = 0;\n  var openGroup = '';\n  var index = 0;\n  var level = 0;\n  var prevLevel = 0;\n  rows.forEach(function (row) {\n    var groupedBy = row.groupedBy,\n      compoundKey = row.compoundKey;\n    if (isGroupRow(row)) {\n      level = outlineLevels[groupedBy];\n      groupTree[compoundKey] = [];\n      parentChain[level] = compoundKey;\n      if (level <= maxLevel) {\n        groupTree[parentChain[level - 1]].push(compoundKey);\n      }\n      if (level === maxLevel) {\n        if (openGroup) {\n          // close previous group\n          groupTree[openGroup].push(lastDataIndex);\n        }\n        openGroup = compoundKey;\n        if (groupSummaryExists && lastDataIndex > 0) {\n          index += 1;\n        }\n        groupTree[compoundKey].push(index + 1); // first row index\n      } else if (groupSummaryExists && level < prevLevel) {\n        // jump over summary rows\n        index += maxLevel - level;\n      }\n      prevLevel = level;\n    } else {\n      lastDataIndex = index;\n    }\n    index += 1;\n  });\n  if (openGroup) {\n    groupTree[openGroup].push(lastDataIndex);\n  }\n  return groupTree;\n};\nvar operations = {\n  count: 'COUNTA'\n};\nvar exportSummaryGetter = function (worksheet, tableColumns, customizeSummaryCell, defaultSummaryMessages) {\n  return function (_a, ranges) {\n    var columnName = _a.columnName,\n      type = _a.type;\n    var column = (tableColumns.find(function (_a) {\n      var dataColumn = _a.column,\n        columnType = _a.type;\n      return columnType === TABLE_DATA_TYPE && dataColumn && dataColumn.name === columnName;\n    }) || {}).column;\n    // NOTE: column is hidden or the grid grouped by this column\n    if (!column) {\n      return;\n    }\n    var row = worksheet.lastRow;\n    var letter = worksheet.getColumn(columnName).letter;\n    var operation = operations[type] || type.toUpperCase();\n    var rangesStr = ranges.map(function (range) {\n      return range.map(function (r) {\n        return \"\" + letter + r;\n      }).filter(function (val, index, arr) {\n        return arr.indexOf(val) === index;\n      }).join(':');\n    }).join(',');\n    var cell = row.getCell(columnName);\n    cell.value = {\n      formula: operation + \"(\" + rangesStr + \")\",\n      date1904: false\n    };\n    cell.numFmt = \"\\\"\" + defaultSummaryMessages[type] + \":\\\" 0\";\n    var summary = {\n      type: type,\n      ranges: ranges\n    };\n    customizeSummaryCell(cell, column, summary);\n  };\n};\nvar closeGroupGetter = function (worksheet, groupTree, outlineLevels, maxGroupLevel, groupSummaryItems, exportSummary) {\n  return function (rowsOffset) {\n    return function (group) {\n      var groupedBy = group.groupedBy,\n        compoundKey = group.compoundKey;\n      exportSummaryItems(worksheet, groupTree, groupSummaryItems, compoundKey, outlineLevels[groupedBy], rowsOffset, maxGroupLevel, exportSummary);\n    };\n  };\n};\nvar maximumGroupLevel = function (grouping) {\n  return (grouping || []).length - 1;\n};\nexport { BAND_DUPLICATE_RENDER, BAND_EMPTY_CELL, BAND_FILL_LEVEL_CELL, BAND_GROUP_CELL, BAND_HEADER_CELL, BOTTOM_POSITION, DEFAULT_COLUMN_WIDTH, DEFAULT_FILTER_OPERATIONS, FIXED_COLUMN_LEFT_SIDE, FIXED_COLUMN_RIGHT_SIDE, GROUP_KEY_SEPARATOR, LEFT_POSITION, RIGHT_POSITION, ROOT_GROUP, TABLE_ADDED_TYPE, TABLE_BAND_TYPE, TABLE_DATA_TYPE, TABLE_DETAIL_TYPE, TABLE_EDIT_COMMAND_TYPE, TABLE_EDIT_TYPE, TABLE_FILTER_TYPE, TABLE_FIXED_TYPE, TABLE_FLEX_TYPE, TABLE_GROUP_SUMMARY_TYPE, TABLE_GROUP_TYPE, TABLE_HEADING_TYPE, TABLE_NODATA_TYPE, TABLE_REORDERING_TYPE, TABLE_SELECT_TYPE, TABLE_STUB_TYPE, TABLE_TOTAL_SUMMARY_TYPE, TABLE_TREE_SUMMARY_TYPE, TOP_POSITION, addRow, addedRowsByIds, adjustSortIndex, allSelected, bandLevelsVisibility, buildGroupTree, calculateBand, calculateFixedColumnProps, calculateGroupCellIndent, calculateKeepOther, calculateRequestedRange, calculateScrollHeight, calculateStartPage, cancelAddedRows, cancelChanges, cancelColumnGroupingDraft, cancelDeletedRows, cancelTableColumnWidthDraft, cellValueGetter, changeAddedRow, changeColumnFilter, changeColumnGrouping, changeColumnOrder, changeColumnSorting, changeRow, changeSearchValue, changeTableColumnWidth, changedRowsByIds, checkColumnWidths, checkTableColumnExtensions, clamp, closeGroupGetter, closeSheet, collapsedTreeRowsGetter, columnBandLevels, columnChooserItems, columnVisibleIntervals, columnsWithEditingCells, convertWidth, createRowChangeGetter, currentPage, customGroupedRows, customGroupingRowIdGetter, customTreeRowIdGetter, customTreeRowLevelKeyGetter, customTreeRowsWithMeta, defaultFilterPredicate, defaultFormatlessSummaries, defaultSummaryCalculator, deleteRows, draftColumnGrouping, draftOrder, draftTableColumnWidth, emptyViewport, emptyVirtualRows, evalAnimations, expandedGroupRows, expandedTreeRows, exportHeader, exportRows, exportSummaryGetter, exportSummaryItems, filterActiveAnimations, filterExpression, filterHeaderRows, filteredCollapsedRowsGetter, filteredRows, findChainByColumnIndex, findRanges, firstRowOnPage, focus, generateSimpleChains, getAnimations, getAvailableFilterOperationsGetter, getAvailableRowCount, getBandComponent, getCellGeometries, getClosestCellByRow, getCollapsedGrid, getCollapsedGrids, getColumnBoundaries, getColumnExtension, getColumnExtensionValueGetter, getColumnFilterConfig, getColumnFilterOperations, getColumnMeta, getColumnSizes, getColumnSortingDirection, getColumnSummaries, getColumnWidthGetter, getColumnsRenderBoundary, getFixedColumnKeys, getFocusing, getForceReloadInterval, getGroupCellTargetIndex, getGroupInlineSummaries, getIndexToFocus, getInnerElements, getNextColumnName, getNextFocusedCell, getPart, getPersistentSortedColumns, getReferenceIndex, getRequestMeta, getRowChange, getRowsRenderBoundary, getRowsVisibleBoundary, getScrollLeft, getScrollTop, getSelectedFilterOperation, getTableColumnGeometries, getTableTargetColumnIndex, getTopRowId, getTreeRowLevelGetter, getViewport, groupCollapsedRowsGetter, groupFooterSummaryExists, groupOutlineLevels, groupRowChecker, groupRowLevelKeyGetter, groupSummaryValues, groupedRows, groupingPanelItems, intervalUtil, isAddedTableRow, isBandedOrHeaderRow, isBandedTableRow, isCellExist, isCellFocused, isColumnsWidthDifferent, isDataTableCell, isDataTableRow, isDetailRowExpanded, isDetailTableCell, isDetailTableRow, isDetailToggleTableCell, isEditCommandsTableCell, isEditTableCell, isEditTableRow, isFilterTableCell, isFilterTableRow, isFilterValueEmpty, isFixedTableRow, isFooterSummary, isGroupIndentStubTableCell, isGroupIndentTableCell, isGroupRowOrdinaryCell, isGroupSummaryTableCell, isGroupSummaryTableRow, isGroupTableCell, isGroupTableRow, isHeaderStubTableCell, isHeadingEditCommandsTableCell, isHeadingTableCell, isHeadingTableRow, isInlineGroupCaptionSummary, isNoDataColumn, isNoDataTableCell, isNoDataTableRow, isPreviousCellContainSummary, isRowFocused, isRowHighlighted, isRowSummaryCell, isSelectAllTableCell, isSelectTableCell, isStubTableCell, isTabArrowUpDown, isTotalSummaryTableCell, isTotalSummaryTableRow, isTreeRowLeafGetter, isTreeSummaryTableCell, isTreeSummaryTableRow, isTreeTableCell, isValidValue, lastRowOnPage, loadedRowsStart, maximumGroupLevel, mergeRows, needFetchMorePages, normalizeRanges, orderedColumns, pageCount, paginatedRows, plainRows, prepareGroupSummaryItems, recalculateBounds, removeEmptyGroups, rowCount, rowIdGetter, rowToPageIndex, rowsToExport, rowsWithAvailableToSelect, rowsWithEditingCells, rowsWithPageHeaders, searchFilterExpression, setCurrentPage, setPageSize, shouldSendRequest, someSelected, sortAndSpliceColumns, sortedRows, splitHeaderColumnChains, startEditCells, startEditRows, stopEditCells, stopEditRows, tableCellColSpanGetter, tableColumnsWithDataRows, tableColumnsWithDetail, tableColumnsWithDraftWidths, tableColumnsWithEditing, tableColumnsWithFixed, tableColumnsWithGrouping, tableColumnsWithSelection, tableColumnsWithWidths, tableDataColumnsExist, tableDetailCellColSpanGetter, tableGroupCellColSpanGetter, tableHeaderColumnChainsWithBands, tableHeaderColumnChainsWithFixed, tableHeaderRowsWithFilter, tableHeaderRowsWithFixed, tableHeaderRowsWithReordering, tableRowsWithBands, tableRowsWithDataRows, tableRowsWithEditing, tableRowsWithExpandedDetail, tableRowsWithGrouping, tableRowsWithHeading, tableRowsWithSummaries, tableRowsWithTotalSummaries, toggleColumn, toggleDetailRowExpanded, toggleExpandedGroups, toggleRowExpanded, toggleSelection, totalSummaryValues, treeSummaryValues, trimRowsToInterval, unwrapSelectedRows, unwrappedCustomTreeRows, unwrappedFilteredRows, virtualRowsWithCache, visibleTableColumns };","map":{"version":3,"sources":["../src/plugins/integrated-grouping/constants.ts","../src/plugins/grid-core/computeds.ts","../src/plugins/sorting-state/reducers.ts","../src/plugins/sorting-state/helpers.ts","../src/utils/merge-sort.ts","../src/utils/hierarchical-data.ts","../src/plugins/integrated-sorting/computeds.ts","../src/plugins/filtering-state/reducers.ts","../src/plugins/filtering-state/helpers.ts","../src/plugins/filtering-state/computeds.ts","../src/plugins/integrated-filtering/computeds.ts","../src/plugins/grouping-state/constants.ts","../src/plugins/grouping-state/reducers.ts","../src/plugins/grouping-state/helpers.ts","../src/plugins/integrated-grouping/helpers.ts","../src/plugins/integrated-grouping/computeds.ts","../src/plugins/custom-grouping/helpers.ts","../src/plugins/custom-grouping/computeds.ts","../src/plugins/grouping-panel/helpers.ts","../src/plugins/paging-state/reducers.ts","../src/plugins/integrated-paging/helpers.ts","../src/plugins/integrated-paging/computeds.ts","../src/plugins/paging-panel/helpers.ts","../src/utils/common-reducers.ts","../src/plugins/selection-state/reducers.ts","../src/plugins/integrated-selection/computeds.ts","../src/plugins/editing-state/reducers.ts","../src/plugins/editing-state/computeds.ts","../src/plugins/editing-state/helpers.ts","../src/plugins/table-column-reordering/constants.ts","../src/plugins/table-column-reordering/reducers.ts","../src/plugins/table/constants.ts","../src/plugins/table-column-reordering/computeds.ts","../src/plugins/table-column-resizing/helpers.ts","../src/plugins/table-column-resizing/computeds.ts","../src/plugins/table-column-resizing/reducers.ts","../src/plugins/table-edit-column/constants.ts","../src/plugins/table-edit-row/constants.ts","../src/plugins/table-header-row/constants.ts","../src/plugins/table-edit-column/helpers.ts","../src/plugins/table-edit-column/computeds.ts","../src/plugins/table-edit-row/helpers.ts","../src/plugins/table-edit-row/computeds.ts","../src/plugins/table-inline-cell-editing/computeds.ts","../src/plugins/table-filter-row/constants.ts","../src/plugins/table-filter-row/helpers.ts","../src/plugins/table-filter-row/computeds.ts","../src/plugins/table-group-row/constants.ts","../src/utils/virtual-table.ts","../src/plugins/table-group-row/helpers.ts","../src/plugins/table-group-row/computeds.ts","../src/plugins/table-header-row/helpers.ts","../src/plugins/table-header-row/computeds.ts","../src/plugins/table-band-header/constants.ts","../src/plugins/table-band-header/helpers.ts","../src/plugins/virtual-table-state/helpers.ts","../src/plugins/virtual-table-state/utils.ts","../src/plugins/table-band-header/computeds.ts","../src/plugins/row-detail-state/reducers.ts","../src/plugins/table-row-detail/constants.ts","../src/plugins/table-row-detail/helpers.ts","../src/plugins/table-row-detail/computeds.ts","../src/plugins/table-selection/constants.ts","../src/plugins/table-selection/helpers.ts","../src/plugins/table-selection/computeds.ts","../src/plugins/table/helpers.ts","../src/utils/column-extension.ts","../src/plugins/table/computeds.ts","../src/plugins/table-column-visibility/computeds.ts","../src/plugins/table-column-visibility/helpers.ts","../src/plugins/column-chooser/computeds.ts","../src/plugins/column-chooser/reducers.ts","../src/plugins/tree-data-state/reducers.ts","../src/plugins/custom-tree-data/constants.ts","../src/plugins/custom-tree-data/computeds.ts","../src/plugins/table-tree-column/helpers.ts","../src/plugins/search-state/reducers.ts","../src/plugins/search-state/computeds.ts","../src/plugins/data-type-provider/computeds.ts","../src/plugins/table-fixed-columns/constants.ts","../src/plugins/table-fixed-columns/helpers.ts","../src/plugins/table-fixed-columns/computeds.ts","../src/plugins/integrated-summary/computeds.ts","../src/plugins/table-summary-row/constants.ts","../src/plugins/table-summary-row/helpers.ts","../src/plugins/table-summary-row/computeds.ts","../src/plugins/summary-state/helpers.ts","../src/plugins/table-keyboard-navigation/helpers.ts","../src/plugins/table-keyboard-navigation/computeds.ts","../src/utils/column-geometries.ts","../src/utils/table.ts","../src/utils/group-panel.ts","../src/plugins/virtual-table/utils.ts","../src/plugins/virtual-table/constants.ts","../src/plugins/virtual-table/helpers.ts","../src/plugins/virtual-table-state/computeds.ts","../src/plugins/grid-exporter/constants.ts","../src/plugins/grid-exporter/helpers.ts","../src/plugins/grid-exporter/computeds.ts"],"names":["VALID_UNITS"],"mappings":"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","sourcesContent":["export const GRID_GROUP_TYPE = Symbol('group');\nexport const GRID_GROUP_CHECK = Symbol(`${GRID_GROUP_TYPE.toString()}_check`);\nexport const GRID_GROUP_LEVEL_KEY = Symbol(`${GRID_GROUP_TYPE.toString()}_levelKey`);\nexport const GRID_GROUP_COLLAPSED_ROWS = Symbol(`${GRID_GROUP_TYPE.toString()}_collapsedRows`);\n","import { GRID_GROUP_CHECK } from '../integrated-grouping/constants';\nimport { GetRowIdFn, Row, RowId, GetCellValueFn, Column } from '../../types';\nimport { PureComputed } from '@devexpress/dx-core';\n\nconst warnIfRowIdUndefined: PureComputed<[GetRowIdFn]> = getRowId => (row) => {\n  const result = getRowId(row);\n  if (!row[GRID_GROUP_CHECK] && result === undefined) {\n    // tslint:disable-next-line: no-console\n    console.warn('The row id is undefined. Check the getRowId function. The row is', row);\n  }\n  return result;\n};\n\nexport const rowIdGetter: PureComputed<[GetRowIdFn, Row[]]> = (getRowId, rows) => {\n  if (!getRowId) {\n    const map = new Map(rows.map((row, rowIndex) => [row, rowIndex]) as [any, number]);\n    return (row: Row) => map.get(row) as RowId;\n  }\n  return warnIfRowIdUndefined(getRowId);\n};\n\nconst defaultGetCellValue: GetCellValueFn = (row, columnName) => row[columnName];\n\nexport const cellValueGetter: PureComputed<[GetCellValueFn, Column[]]> = (\n  getCellValue = defaultGetCellValue, columns,\n) => {\n  let useFastAccessor = true;\n  const map = columns.reduce((acc, column) => {\n    if (column.getCellValue) {\n      useFastAccessor = false;\n      acc[column.name] = column.getCellValue;\n    }\n    return acc;\n  }, {});\n\n  if (useFastAccessor) {\n    return getCellValue;\n  }\n\n  return (row, columnName) => (map[columnName]\n    ? map[columnName](row, columnName)\n    : getCellValue(row, columnName));\n};\n","import { ColumnSortingState, ChangeSortingPayload, Sorting } from '../../types';\nimport { PureReducer, slice } from '@devexpress/dx-core';\n\nexport const changeColumnSorting: PureReducer<ColumnSortingState, ChangeSortingPayload> = (\n  state, {\n  columnName, direction, keepOther, sortIndex,\n}) => {\n  const { sorting } = state;\n\n  let nextSorting: any[] = [];\n  if (keepOther === true) {\n    nextSorting = sorting as Sorting[];\n  }\n  if (Array.isArray(keepOther)) {\n    nextSorting = slice(sorting)\n      .filter(s =>\n        keepOther.indexOf(s.columnName) > -1);\n  }\n\n  const columnSortingIndex = sorting.findIndex(s => s.columnName === columnName);\n  const columnSorting = sorting[columnSortingIndex];\n  const newColumnSorting = {\n    columnName,\n    direction: direction\n      || (!columnSorting || columnSorting.direction === 'desc' ? 'asc' : 'desc'),\n  };\n\n  if (columnSortingIndex > -1) {\n    nextSorting = slice(nextSorting);\n    nextSorting.splice(columnSortingIndex, 1);\n  }\n\n  if (direction !== null) {\n    const newIndexFallback = columnSortingIndex > -1 ? columnSortingIndex : nextSorting.length;\n    const newIndex = sortIndex !== undefined ? sortIndex : newIndexFallback;\n    nextSorting = slice(nextSorting);\n    nextSorting.splice(newIndex, 0, newColumnSorting);\n  }\n\n  return {\n    sorting: nextSorting,\n  };\n};\n","import {\n  KeepOtherSorting, GetColumnSortingDirectionFn, GetPersistentSortedColumnsFn,\n  CalculateKeepOtherFn,\n} from '../../types';\n\nconst unique = (arr: any[]) => [...Array.from(new Set(arr))];\n\nexport const getColumnSortingDirection: GetColumnSortingDirectionFn = (\n  sorting, columnName,\n) => {\n  const columnSorting = sorting.filter(s => s.columnName === columnName)[0];\n  return columnSorting ? columnSorting.direction : null;\n};\n\nexport const getPersistentSortedColumns: GetPersistentSortedColumnsFn = (\n  sorting, columnExtensions = [],\n) => columnExtensions.reduce((acc, { columnName, sortingEnabled }) => {\n  if (!sortingEnabled) {\n    if (sorting.findIndex(sortItem => sortItem.columnName === columnName) > -1) {\n      acc.push(columnName);\n    }\n  }\n  return acc;\n}, [] as string[]);\n\nexport const calculateKeepOther: CalculateKeepOtherFn = (\n  sorting, keepOther, persistentSortedColumns = [],\n) => {\n  if (!persistentSortedColumns.length) return keepOther as KeepOtherSorting;\n  if (!keepOther) return persistentSortedColumns as KeepOtherSorting;\n\n  return Array.isArray(keepOther)\n    ? unique([...keepOther, ...persistentSortedColumns])\n    : unique([...sorting.map(item => item.columnName), ...persistentSortedColumns]);\n};\n","import { slice } from '@devexpress/dx-core';\nimport { MergeFn, SortArrayToAuxiliaryFn, CompareFn } from '../types';\n\n/* eslint-disable no-plusplus, no-param-reassign, no-use-before-define, no-constant-condition */\n/* tslint:disable no-increment-decrement */\n\nconst merge: MergeFn = (array, auxiliary, lo, mid, hi, compare) => {\n  let i = lo;\n  let j = mid + 1;\n  let k = lo;\n  while (true) {\n    const cmp = compare(array[i], array[j]);\n    if (cmp <= 0) {\n      auxiliary[k++] = array[i++];\n      if (i > mid) {\n        do {\n          auxiliary[k++] = array[j++];\n        } while (j <= hi);\n        break;\n      }\n    } else {\n      auxiliary[k++] = array[j++];\n      if (j > hi) {\n        do {\n          auxiliary[k++] = array[i++];\n        } while (i <= mid);\n        break;\n      }\n    }\n  }\n};\n\nconst sortArrayToAuxiliary: SortArrayToAuxiliaryFn = (array, auxiliary, lo, hi, compare) => {\n  if (hi < lo) return;\n  if (hi === lo) {\n    auxiliary[lo] = array[lo];\n    return;\n  }\n  const mid = Math.floor(lo + ((hi - lo) / 2));\n  sortAuxiliaryToArray(array, auxiliary, lo, mid, compare);\n  sortAuxiliaryToArray(array, auxiliary, mid + 1, hi, compare);\n  merge(array, auxiliary, lo, mid, hi, compare);\n};\n\nconst sortAuxiliaryToArray: SortArrayToAuxiliaryFn = (array, auxiliary, lo, hi, compare) => {\n  if (hi <= lo) return;\n  const mid = Math.floor(lo + ((hi - lo) / 2));\n  sortArrayToAuxiliary(array, auxiliary, lo, mid, compare);\n  sortArrayToAuxiliary(array, auxiliary, mid + 1, hi, compare);\n  merge(auxiliary, array, lo, mid, hi, compare);\n};\n\nexport default (\n  array: any[] | ReadonlyArray<any>,\n  compare: CompareFn = (a, b): number => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  },\n) => {\n  const result = slice(array);\n  const auxiliary = slice(array);\n  sortAuxiliaryToArray(result, auxiliary, 0, result.length - 1, compare);\n  return result;\n};\n","import { RowsToTreeFn, TreeToRowsFn, TreeNode } from '../types';\n\nexport const NODE_CHECK = Symbol('node');\n\nexport const rowsToTree: RowsToTreeFn = (rows, getRowLevelKey) => {\n  if (!rows.length) return rows;\n\n  const levels: any[] = [{ children: [] }];\n\n  rows.forEach((row) => {\n    const levelKey = getRowLevelKey(row);\n    if (levelKey) {\n      const levelIndex = levels.slice(1)\n        .findIndex(level => getRowLevelKey(level.root) === levelKey) + 1;\n      if (levelIndex > 0) {\n        levels.splice(levelIndex, levels.length - levelIndex);\n      }\n      const node = { [NODE_CHECK]: true, root: row, children: [] };\n      levels[levels.length - 1].children.push(node);\n      levels.push(node);\n    } else {\n      levels[levels.length - 1].children.push(row);\n    }\n  });\n\n  return levels[0].children;\n};\n\nexport const treeToRows: TreeToRowsFn = (tree, rows = []) => {\n  if (!tree.length) return tree;\n  return tree.reduce(\n    (acc, node) => {\n      if (node[NODE_CHECK]) {\n        acc.push(node.root);\n        treeToRows(node.children, rows);\n      } else {\n        acc.push(node);\n      }\n      return acc;\n    },\n    rows as TreeNode[],\n  );\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport mergeSort from '../../utils/merge-sort';\nimport { NODE_CHECK, rowsToTree, treeToRows } from '../../utils/hierarchical-data';\nimport {\n  Row, GetRowLevelKeyFn, CompareFn, CreateCompareFn, SortedRowsFn, TreeNode,\n} from '../../types';\n\nconst defaultCompare = (a: any, b: any) => {\n  if (a === b) return 0;\n\n  if (a === null) {\n    return b === undefined ? -1 : 1;\n  }\n  if (a === undefined) {\n    return 1;\n  }\n  if (b === null || b === undefined) {\n    return -1;\n  }\n  return a < b ? -1 : 1;\n};\n\nconst createCompare: CreateCompareFn = (\n  sorting, getColumnCompare, getComparableValue,\n) => sorting.reduceRight((prevCompare, columnSorting) => {\n  const { columnName } = columnSorting;\n  const inverse = columnSorting.direction === 'desc';\n  const columnCompare = (getColumnCompare && getColumnCompare(columnName)) || defaultCompare;\n\n  return (aRow: Row, bRow: Row) => {\n    const a = getComparableValue(aRow, columnName);\n    const b = getComparableValue(bRow, columnName);\n    const result = columnCompare(a, b);\n\n    if (result !== 0) {\n      return inverse ? -result : result;\n    }\n    return prevCompare(aRow, bRow);\n  };\n}, (...args: any[]) => 0);\n\nconst sortTree: PureComputed<[TreeNode[], CompareFn]> = (tree, compare) => {\n  const sortedTree = tree.map((node) => {\n    if (node[NODE_CHECK]) {\n      return {\n        ...node,\n        children: sortTree(node.children, compare),\n      };\n    }\n    return node;\n  });\n\n  return mergeSort(\n    sortedTree, (a, b) => compare(a[NODE_CHECK] ? a.root : a, b[NODE_CHECK] ? b.root : b),\n  );\n};\n\nconst sortHierarchicalRows: PureComputed<[Row[], CompareFn, GetRowLevelKeyFn]> = (\n  rows, compare, getRowLevelKey,\n) => {\n  const tree = rowsToTree(rows, getRowLevelKey);\n\n  const sortedTree = sortTree(tree, compare);\n\n  return treeToRows(sortedTree);\n};\n\nexport const sortedRows: SortedRowsFn = (\n  rows, sorting, getCellValue, getColumnCompare, isGroupRow, getRowLevelKey,\n) => {\n  if (!sorting.length || !rows.length) return rows;\n\n  let compare;\n  if (!getRowLevelKey) {\n    compare = createCompare(sorting, getColumnCompare, getCellValue);\n    return mergeSort(rows.slice(), compare);\n  }\n\n  compare = createCompare(sorting, getColumnCompare, (row, columnName) => {\n    if (isGroupRow && isGroupRow(row)) {\n      if (row.groupedBy === columnName) {\n        return row.value;\n      }\n      return undefined;\n    }\n    return getCellValue(row, columnName);\n  });\n  return sortHierarchicalRows(\n    rows,\n    compare,\n    getRowLevelKey,\n  );\n};\n","import { Filter, ChangeFilterPayload } from '../../types';\nimport { PureReducer, slice } from '@devexpress/dx-core';\n\nexport const changeColumnFilter: PureReducer<Filter[], ChangeFilterPayload> = (\n  filters, { columnName, config },\n) => {\n  const filterIndex = filters.findIndex(f => f.columnName === columnName);\n  const nextState = slice(filters);\n\n  if (config) {\n    const filter = { columnName, ...config };\n    if (filterIndex > -1) {\n      nextState.splice(filterIndex, 1, filter);\n    } else {\n      nextState.push(filter);\n    }\n  } else if (filterIndex > -1) {\n    nextState.splice(filterIndex, 1);\n  }\n\n  return nextState;\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { Filter } from '../../types';\n\nexport const getColumnFilterConfig: PureComputed<\n  [Filter[], string], Filter | null\n> = (filters, columnName) => (\n  filters.length && filters.filter(s => s.columnName === columnName)[0] || null\n);\n","import { FilterExpression, Filter } from '../../types';\nimport { PureComputed } from '@devexpress/dx-core';\n\nexport const filterExpression: PureComputed<\n  [Filter[], FilterExpression?], FilterExpression\n> = (filters, expression) => {\n  // tslint:disable-next-line: no-object-literal-type-assertion\n  const selfFilterExpr = { filters, operator: 'and' as 'and' } as FilterExpression;\n  if (!expression) {\n    return selfFilterExpr;\n  }\n  return {\n    operator: 'and' as 'and',\n    filters: [expression, selfFilterExpr] as FilterExpression[],\n  };\n};\n","import { NODE_CHECK, rowsToTree, treeToRows } from '../../utils/hierarchical-data';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  Row, Filter, FilterPredicate,\n  FilterExpression, GetCellValueFn, RowsWithCollapsedRowsMetaMap,\n  UnwrapRowsComputed, FilteredRowsFn, FilterHierarchicalRowsFn,\n  CompiledPredicate, GetColumnPredicateFn, FilteredCollapsedRowsGetterFn, TreeNode,\n} from '../../types';\n\nconst operators = {\n  or: (predicates: CompiledPredicate[]) => (row: Row) => (\n    predicates.reduce((acc, predicate) => acc || predicate(row), false)\n  ),\n  and: (predicates: CompiledPredicate[]) => (row: Row) => (\n    predicates.reduce((acc, predicate) => acc && predicate(row), true)\n  ),\n};\n\nconst toLowerCase = (value: any) => String(value).toLowerCase();\n\nconst operationPredicates: { [key: string]: FilterPredicate } = {\n  contains: (value, filter) => toLowerCase(value)\n    .indexOf(toLowerCase(filter.value)) > -1,\n\n  notContains: (value, filter) => toLowerCase(value)\n    .indexOf(toLowerCase(filter.value)) === -1,\n\n  startsWith: (value, filter) => toLowerCase(value)\n    .startsWith(toLowerCase(filter.value)),\n\n  endsWith: (value, filter) => toLowerCase(value)\n    .endsWith(toLowerCase(filter.value)),\n\n  equal: (value, filter) => String(value) === String(filter.value),\n  notEqual: (value, filter) => String(value) !== String(filter.value),\n\n  greaterThan: (value, filter) => value > filter.value!,\n  greaterThanOrEqual: (value, filter) => value >= filter.value!,\n  lessThan: (value, filter) => value < filter.value!,\n  lessThanOrEqual: (value, filter) => value <= filter.value!,\n};\n\nexport const defaultFilterPredicate: FilterPredicate = (value, filter) => {\n  const operation = filter.operation || 'contains';\n  return operationPredicates[operation](value, filter);\n};\n\nconst filterTree: PureComputed<[TreeNode[], CompiledPredicate]> = (tree, predicate) => tree.reduce(\n  (acc, node) => {\n    if (node[NODE_CHECK]) {\n      const filteredChildren = filterTree(node.children, predicate) as TreeNode[];\n      if (filteredChildren.length > 0) {\n        acc.push({\n          ...node,\n          children: filteredChildren,\n        });\n        return acc;\n      }\n      if (predicate(node.root, true)) {\n        acc.push(node.root);\n        return acc;\n      }\n      return acc;\n    }\n\n    if (predicate(node)) {\n      acc.push(node);\n      return acc;\n    }\n\n    return acc;\n  },\n  [] as TreeNode[],\n);\n\nconst filterHierarchicalRows: FilterHierarchicalRowsFn = (\n  rows, predicate, getRowLevelKey, getCollapsedRows,\n) => {\n  const tree = rowsToTree(rows, getRowLevelKey);\n  const collapsedRowsMeta: any[] = [];\n\n  const filteredTree = filterTree(tree, (row, isNode) => {\n    if (isNode) {\n      const collapsedRows = getCollapsedRows && getCollapsedRows(row);\n      if (collapsedRows && collapsedRows.length) {\n        const filteredCollapsedRows = collapsedRows.filter(predicate);\n        collapsedRowsMeta.push([row, filteredCollapsedRows]);\n        return !!filteredCollapsedRows.length || predicate(row);\n      }\n      if (predicate(row)) {\n        collapsedRowsMeta.push([row, []]);\n        return true;\n      }\n      return false;\n    }\n    return predicate(row);\n  });\n\n  return { rows: treeToRows(filteredTree), collapsedRowsMeta: new Map(collapsedRowsMeta) };\n};\n\nconst buildPredicate: PureComputed<\n  [FilterExpression, GetCellValueFn, GetColumnPredicateFn],\n  CompiledPredicate\n> = (\n  initialFilterExpression, getCellValue, getColumnPredicate,\n) => {\n  const getSimplePredicate = (filter: Filter) => {\n    const { columnName } = filter;\n    const customPredicate = getColumnPredicate && getColumnPredicate(columnName);\n    const predicate = customPredicate || defaultFilterPredicate;\n    return (row: Row) => predicate(getCellValue(row, columnName), filter, row);\n  };\n\n  const getOperatorPredicate: any = (filterExpression: FilterExpression) => {\n    const build = operators[toLowerCase(filterExpression.operator)];\n    return build && build(filterExpression.filters.map(getPredicate));\n  };\n\n  const getPredicate = (filterExpression: any) => (\n    getOperatorPredicate(filterExpression)\n    || getSimplePredicate(filterExpression)\n  );\n\n  return getPredicate(initialFilterExpression);\n};\n\nexport const filteredRows: FilteredRowsFn = (\n  rows, filterExpression, getCellValue, getColumnPredicate, getRowLevelKey, getCollapsedRows,\n) => {\n  if (!(filterExpression && Object.keys(filterExpression).length && rows.length)) {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    return { rows } as Partial<RowsWithCollapsedRowsMetaMap>;\n  }\n\n  const predicate = buildPredicate(\n    filterExpression,\n    getCellValue,\n    getColumnPredicate,\n  );\n\n  return getRowLevelKey\n    ? filterHierarchicalRows(rows, predicate, getRowLevelKey, getCollapsedRows)\n    : { rows: rows.filter(predicate) };\n};\n\nexport const filteredCollapsedRowsGetter: FilteredCollapsedRowsGetterFn = (\n  { collapsedRowsMeta },\n) => row => collapsedRowsMeta && collapsedRowsMeta.get(row);\n\nexport const unwrappedFilteredRows: UnwrapRowsComputed = ({ rows }) => rows;\n","export const GROUP_KEY_SEPARATOR = '|';\n","import { PureReducer, slice } from '@devexpress/dx-core';\nimport { Getters } from '@devexpress/dx-react-core';\nimport { GROUP_KEY_SEPARATOR } from './constants';\nimport {\n  Grouping, ColumnGroupingState, ChangeGroupingPayload, ToggleGroupPayload, DraftGroupingState,\n} from '../../types';\n\nconst applyColumnGrouping: PureReducer<Grouping[], ChangeGroupingPayload> = (\n  grouping, { columnName, groupIndex },\n) => {\n  let nextGrouping = grouping;\n  const groupingIndex = nextGrouping.findIndex(g => g.columnName === columnName);\n  let targetIndex = groupIndex;\n\n  if (groupingIndex > -1) {\n    nextGrouping = slice(grouping);\n    (nextGrouping as Grouping[]).splice(groupingIndex, 1);\n  } else if (groupIndex === undefined) {\n    targetIndex = nextGrouping.length;\n  }\n\n  if (targetIndex > -1) {\n    nextGrouping = slice(nextGrouping);\n    (nextGrouping as Grouping[]).splice(targetIndex, 0, {\n      columnName,\n    });\n  }\n\n  return nextGrouping;\n};\n\nexport const changeColumnGrouping: PureReducer<ColumnGroupingState, ChangeGroupingPayload> = (\n  { grouping, expandedGroups }, { columnName, groupIndex },\n) => {\n  const nextGrouping = applyColumnGrouping(grouping!, { columnName, groupIndex });\n\n  const ungroupedColumnIndex = grouping!.findIndex(\n    (group, index) => !nextGrouping[index] || group.columnName !== nextGrouping[index].columnName,\n  );\n  if (ungroupedColumnIndex === -1) {\n    return {\n      grouping: nextGrouping,\n    };\n  }\n\n  const filteredExpandedGroups = expandedGroups!.filter(\n    group => group.split(GROUP_KEY_SEPARATOR).length <= ungroupedColumnIndex,\n  );\n  if (filteredExpandedGroups.length === expandedGroups!.length) {\n    return {\n      grouping: nextGrouping,\n    };\n  }\n\n  return {\n    grouping: nextGrouping,\n    expandedGroups: filteredExpandedGroups,\n  };\n};\n\nexport const toggleExpandedGroups: PureReducer<ColumnGroupingState, ToggleGroupPayload> = (\n  state, { groupKey },\n) => {\n  const expandedGroups = slice(state.expandedGroups);\n  const groupKeyIndex = expandedGroups.indexOf(groupKey);\n\n  if (groupKeyIndex > -1) {\n    expandedGroups.splice(groupKeyIndex, 1);\n  } else {\n    expandedGroups.push(groupKey);\n  }\n\n  return {\n    expandedGroups,\n  };\n};\n\nexport const draftColumnGrouping: PureReducer<\n  Getters, ChangeGroupingPayload, DraftGroupingState\n> = (\n  { grouping, draftGrouping },\n  { columnName, groupIndex },\n) => ({\n  draftGrouping: applyColumnGrouping(draftGrouping || grouping, { columnName, groupIndex }),\n});\n\nexport const cancelColumnGroupingDraft = () => ({\n  draftGrouping: null,\n});\n","import { PureComputed } from '@devexpress/dx-core';\nimport { Grouping, Sorting, GroupIndex } from '../../types';\n\nexport const adjustSortIndex: PureComputed<[GroupIndex, Grouping[], Sorting[]]> = (\n  groupingIndex, grouping, sorting,\n) => Math.max(\n  grouping.slice(0, groupingIndex).reduce(\n    (acc, columnGrouping) => {\n      const columnSortingIndex = sorting.findIndex(\n        columnSorting => columnSorting.columnName === columnGrouping.columnName,\n      );\n      return (columnSortingIndex === -1 ? acc - 1 : acc);\n    },\n    groupingIndex,\n  ),\n  0,\n);\n","import { GetIntegratedGroupsFn, GetGroupRowsFn, Row } from '../../types';\nimport { GROUP_KEY_SEPARATOR } from '../grouping-state/constants';\nimport { GRID_GROUP_CHECK, GRID_GROUP_LEVEL_KEY, GRID_GROUP_TYPE } from './constants';\n\nconst defaultColumnCriteria = (value: any) => ({\n  value,\n  key: String(value),\n});\n\nexport const getGroupRows: GetGroupRowsFn = (\n  rows, grouping, groupsGetter,\n) => {\n  if (grouping.length === 0) {\n    return rows;\n  }\n\n  const keyPrefixes = [{ prefix: '', level: 0, rows }];\n  const resultRows = [] as Row[];\n  const compoundKeys = {};\n\n  while (keyPrefixes.length) {\n    const { prefix: keyPrefix, level, rows: currentRows } = keyPrefixes.pop()!;\n\n    const currentCompoundKey = keyPrefix.slice(0, keyPrefix.length - 1);\n    const groupIndex = compoundKeys[currentCompoundKey] ?? -1;\n\n    const groupRows: readonly Row[] = grouping[level] && currentRows.length\n      ? groupsGetter(currentRows, grouping[level], keyPrefix)\n          .map(({ childRows, ...params }: any, rowIndex) => {\n            const { compoundKey } = params;\n\n            compoundKeys[compoundKey] = groupIndex + rowIndex + 1;\n            keyPrefixes.push({\n              prefix: `${compoundKey}${GROUP_KEY_SEPARATOR}`,\n              level: level + 1,\n              rows: childRows || [],\n            });\n\n            return params;\n          })\n      : currentRows;\n\n    if (groupIndex > -1) {\n      resultRows.splice(groupIndex + 1, 0, ...groupRows);\n    } else {\n      groupRows.forEach(row => resultRows.push(row));\n    }\n  }\n\n  return resultRows;\n};\n\nexport const getIntegratedGroups: GetIntegratedGroupsFn = (\n  rows,\n  grouping,\n  keyPrefix,\n  getCellValue,\n  getColumnCriteria,\n) => {\n  const { columnName } = grouping;\n  const groupCriteria = (getColumnCriteria && getColumnCriteria(columnName))\n        || defaultColumnCriteria;\n\n  const groups = new Map();\n  rows.forEach((row) => {\n    const rawValue = getCellValue(row, columnName);\n    const { key, value } = groupCriteria(rawValue, row);\n    const sameKeyItems = groups.get(key);\n\n    if (!sameKeyItems) {\n      const groupingValue = value === rawValue ? value : value || key;\n      groups.set(key, [groupingValue, key, [row]]);\n    } else {\n      sameKeyItems[2].push(row);\n    }\n  });\n\n  const groupedBy = columnName;\n  return [...groups.values()]\n    .map(([value, key, childRows]) => ({\n      groupedBy,\n      compoundKey: `${keyPrefix}${key}`,\n      key,\n      value,\n      [GRID_GROUP_CHECK]: true,\n      [GRID_GROUP_LEVEL_KEY]: `${GRID_GROUP_TYPE.toString()}_${groupedBy}`,\n      childRows,\n    }));\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  GRID_GROUP_CHECK,\n  GRID_GROUP_LEVEL_KEY,\n  GRID_GROUP_COLLAPSED_ROWS,\n} from './constants';\nimport {\n  Grouping,\n  GroupKey,\n  Row,\n  GetCollapsedRowsFn,\n  IsSpecificRowFn,\n  GroupedRowsFn,\n  GroupsGetterFn,\n} from '../../types';\nimport { getGroupRows, getIntegratedGroups } from './helpers';\n\nexport const groupRowChecker: IsSpecificRowFn = row => row[GRID_GROUP_CHECK];\n\nexport const groupRowLevelKeyGetter = (row: Row) => (row ? row[GRID_GROUP_LEVEL_KEY] : undefined);\n\nexport const groupedRows: GroupedRowsFn = (\n  rows, grouping, getCellValue, getColumnCriteria,\n) => {\n  const groupsGetter: GroupsGetterFn = (currentRows, currentGrouping, prefix) =>\n    getIntegratedGroups(\n      currentRows,\n      currentGrouping,\n      prefix,\n      getCellValue,\n      getColumnCriteria,\n    );\n  return getGroupRows(rows, grouping, groupsGetter);\n};\n\nexport const expandedGroupRows: PureComputed<[Row[], Grouping[], GroupKey[], boolean]> = (\n  rows,\n  grouping,\n  expandedGroups,\n  isExporting,\n) => {\n  if (!grouping.length) return rows;\n\n  const groupingColumnNames = grouping.map(columnGrouping => columnGrouping.columnName);\n  const expandedGroupsSet = new Set(expandedGroups);\n  let currentGroupExpanded = true;\n  let currentGroupLevel = 0;\n\n  return rows.reduce((acc, row) => {\n    if (!row[GRID_GROUP_CHECK]) {\n      if (currentGroupExpanded) {\n        acc.push(row);\n      } else {\n        acc[acc.length - 1][GRID_GROUP_COLLAPSED_ROWS].push(row);\n      }\n      return acc;\n    }\n\n    const groupLevel = groupingColumnNames.indexOf(row.groupedBy);\n    if (groupLevel > currentGroupLevel && !currentGroupExpanded) {\n      return acc;\n    }\n\n    currentGroupExpanded = expandedGroupsSet.has(row.compoundKey) || isExporting;\n    currentGroupLevel = groupLevel;\n\n    if (currentGroupExpanded) {\n      acc.push(row);\n    } else {\n      acc.push({\n        ...row,\n        [GRID_GROUP_COLLAPSED_ROWS]: [],\n      });\n    }\n\n    return acc;\n  }, []);\n};\n\nexport const groupCollapsedRowsGetter: PureComputed<[GetCollapsedRowsFn]> =\n  getCollapsedRows => row => (\n  row[GRID_GROUP_COLLAPSED_ROWS] || (getCollapsedRows && getCollapsedRows(row))\n);\n","import { GetCustomGroupsFn } from '../../types';\nimport {\n  GRID_GROUP_CHECK,\n  GRID_GROUP_LEVEL_KEY,\n  GRID_GROUP_TYPE,\n} from '../integrated-grouping/constants';\n\nexport const getCustomGroups: GetCustomGroupsFn = (\n  rows,\n  grouping,\n  keyPrefix,\n  getChildGroups,\n  rootRows,\n) => {\n  const groupedBy = grouping.columnName;\n  return getChildGroups(rows as any[], grouping, rootRows as any[])\n    .map(({ key, value = key, childRows }) => ({\n      groupedBy,\n      compoundKey: `${keyPrefix}${key}`,\n      key,\n      value,\n      [GRID_GROUP_CHECK]: true,\n      [GRID_GROUP_LEVEL_KEY]: `${GRID_GROUP_TYPE.toString()}_${groupedBy}`,\n      childRows,\n    }));\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { GRID_GROUP_CHECK } from '../integrated-grouping/constants';\nimport { GetRowIdFn, Row, RowId, CustomGroupedRowsFn, GroupsGetterFn } from '../../types';\nimport { getCustomGroups } from './helpers';\nimport { getGroupRows } from '../integrated-grouping/helpers';\n\nexport const customGroupedRows: CustomGroupedRowsFn = (\n  rows, grouping, getChildGroups, rootRows = rows,\n) => {\n  const groupsGetter: GroupsGetterFn = (currentRows, currentGrouping, prefix) =>\n    getCustomGroups(\n      currentRows,\n      currentGrouping,\n      prefix,\n      getChildGroups,\n      rootRows,\n    );\n  return getGroupRows(rows, grouping, groupsGetter);\n};\n\nexport const customGroupingRowIdGetter: PureComputed<[GetRowIdFn, Row[]]> = (getRowId, rows) => {\n  const firstRow = rows.find(row => !row[GRID_GROUP_CHECK]);\n  if (!firstRow || getRowId(firstRow) !== undefined) {\n    return getRowId;\n  }\n\n  const map = new Map<Row, RowId>(rows\n    .filter(row => !row[GRID_GROUP_CHECK])\n    .map((row, rowIndex) => [row, rowIndex]) as [Row, RowId]);\n\n  return row => map.get(row)!;\n};\n","import { GroupingPanelItemsFn } from '../../types/';\n\nexport const groupingPanelItems: GroupingPanelItemsFn = (\n  columns, grouping, draftGrouping,\n) => {\n  const items = draftGrouping.map(({ columnName }) => ({\n    column: columns.find(c => c.name === columnName)!,\n    draft: !grouping.some(columnGrouping => columnGrouping.columnName === columnName),\n  }));\n\n  grouping.forEach(({ columnName }, index) => {\n    if (draftGrouping.some(columnGrouping => columnGrouping.columnName === columnName)) return;\n    items.splice(index, 0, {\n      column: columns.find(c => c.name === columnName)!,\n      draft: true,\n    });\n  });\n\n  return items;\n};\n","export const setCurrentPage = (prevPage: number, page: number) => page;\nexport const setPageSize = (prevPageSize: number, size: number) => size;\n","import { PureComputed } from '@devexpress/dx-core';\n\nexport const clamp: PureComputed<[number, number]> = (value, max) => (\n  Math.max(Math.min(value, max), 0)\n);\n","import { clamp } from './helpers';\nimport { Row, GetRowLevelKeyFn, CurrentPageFn } from '../../types';\nimport { PureComputed } from '@devexpress/dx-core';\n\n// tslint:disable-next-line:max-line-length\nconst PAGE_HEADERS_OVERFLOW_ERROR = 'Max row level exceeds the page size. Consider increasing the page size.';\n\nexport const paginatedRows: PureComputed<[Row[], number, number]> = (rows, pageSize, page) => (\n  pageSize\n    ? rows.slice(pageSize * page, pageSize * (page + 1))\n    : rows as Row[]\n);\n\nexport const rowsWithPageHeaders: PureComputed<[Row[], number, GetRowLevelKeyFn]> = (\n  rows, pageSize, getRowLevelKey,\n) => {\n  if (!pageSize || !getRowLevelKey) return rows as Row[];\n\n  let result = rows.slice();\n\n  let headerRows: any[] = [];\n  let currentIndex = 0;\n  while (result.length > currentIndex) {\n    const row = result[currentIndex];\n    const levelKey = getRowLevelKey(row);\n    if (levelKey) {\n      const headerIndex = headerRows.findIndex(headerRow => getRowLevelKey(headerRow) === levelKey);\n      // tslint:disable-next-line:prefer-conditional-expression\n      if (headerIndex === -1) {\n        headerRows = [...headerRows, row];\n      } else {\n        headerRows = [...headerRows.slice(0, headerIndex), row];\n      }\n      if (headerRows.length >= pageSize) {\n        throw new Error(PAGE_HEADERS_OVERFLOW_ERROR);\n      }\n    }\n    const indexInPage = currentIndex % pageSize;\n    if (indexInPage < headerRows.length && row !== headerRows[indexInPage]) {\n      result = [\n        ...result.slice(0, currentIndex),\n        headerRows[indexInPage],\n        ...result.slice(currentIndex),\n      ];\n    }\n    currentIndex += 1;\n  }\n\n  return result;\n};\n\nexport const rowCount = (rows: Row[]) => rows.length;\n\nexport const pageCount: PureComputed<[number, number]> = (count, pageSize) => (\n  pageSize ? Math.ceil(count / pageSize) : 1\n);\n\nexport const currentPage: CurrentPageFn = (\n  page, totalCount, pageSize, setCurrentPage,\n) => {\n  const totalPages = pageCount(totalCount, pageSize);\n  const adjustedCurrentPage = clamp(page, totalPages - 1);\n  if (page !== adjustedCurrentPage) {\n    setTimeout(() => setCurrentPage(adjustedCurrentPage));\n  }\n  return adjustedCurrentPage;\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { NthRowOnPageFn } from '../../types';\n\nexport const firstRowOnPage: NthRowOnPageFn = (currentPage, pageSize, totalCount) => {\n  if (totalCount === 0) {\n    return 0;\n  }\n  return pageSize ? (currentPage * pageSize) + 1 : 1;\n};\n\nexport const lastRowOnPage: NthRowOnPageFn = (currentPage, pageSize, totalRowCount) => {\n  let result = totalRowCount;\n  if (pageSize) {\n    const index = (currentPage + 1) * pageSize;\n    result = index > totalRowCount ? totalRowCount : index;\n  }\n\n  return result;\n};\n\nexport const calculateStartPage: PureComputed<[number, number, number]> = (\n  currentPage, maxButtonCount, totalPageCount,\n) => (\n  Math.max(\n    Math.min(\n    currentPage - Math.floor(maxButtonCount / 2),\n      (totalPageCount - maxButtonCount) + 1,\n    ),\n    1,\n  )\n);\n","import { PureComputed } from '@devexpress/dx-core';\nimport { RowId } from '../types';\n\nexport const toggle: PureComputed<[RowId[], RowId[], boolean?]> = (\n  source, items, state?,\n) => {\n  const itemsSet = new Set(items);\n\n  let sourceState: any = state;\n  if (sourceState === undefined) {\n    const availableSelection = source.filter(item => itemsSet.has(item));\n    sourceState = availableSelection.length !== itemsSet.size;\n  }\n\n  if (sourceState) {\n    const sourceSet = new Set(source);\n    return [\n      ...source,\n      ...items.filter(item => !sourceSet.has(item)),\n    ];\n  }\n\n  return source.filter(item => !itemsSet.has(item));\n};\n","import { toggle } from '../../utils/common-reducers';\nimport { ToggleRowsFieldReducer } from '../../types';\n\nexport const toggleSelection: ToggleRowsFieldReducer = (\n  selection, { rowIds, state },\n) => toggle(selection, rowIds, state);\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  RowsWithSelection, UnwrapRowsComputed, RowId, RowsWithAvailableToSelectFn,\n} from '../../types';\n\ntype RowsSelectedFn = PureComputed<[RowsWithSelection, RowId[]], boolean>;\n\nexport const rowsWithAvailableToSelect: RowsWithAvailableToSelectFn = (\n  rows, getRowId, isGroupRow,\n) => {\n  let dataRows = rows;\n  if (isGroupRow) {\n    dataRows = dataRows.filter(row => !isGroupRow(row));\n  }\n  return { rows, availableToSelect: dataRows.map(row => getRowId(row)) };\n};\n\nexport const someSelected: RowsSelectedFn = ({ availableToSelect }, selection) => {\n  const selectionSet = new Set(selection);\n\n  return availableToSelect.length !== 0 && selectionSet.size !== 0\n    && availableToSelect.some(elem => selectionSet.has(elem))\n    && availableToSelect.some(elem => !selectionSet.has(elem));\n};\n\nexport const allSelected: RowsSelectedFn = ({ availableToSelect }, selection) => {\n  const selectionSet = new Set(selection);\n\n  return selectionSet.size !== 0 && availableToSelect.length !== 0\n    && !availableToSelect.some(elem => !selectionSet.has(elem));\n};\n\nexport const unwrapSelectedRows: UnwrapRowsComputed = ({ rows }) => rows;\n","import { PureReducer } from '@devexpress/dx-core';\nimport { RowId, Row, RowIdsPayload, RowPayload, RowChangePayload,\n  RowChanges, EditingCell, EditingCellsPayload,\n} from '../../types';\n\nexport const startEditRows: PureReducer<RowId[], RowIdsPayload> = (\n  prevEditingRowIds, { rowIds },\n) => [...prevEditingRowIds, ...rowIds];\n\nexport const stopEditRows: PureReducer<RowId[], RowIdsPayload> = (\n  prevEditingRowIds, { rowIds },\n) => {\n  const rowIdSet = new Set(rowIds);\n  return prevEditingRowIds.filter(id => !rowIdSet.has(id));\n};\n\nexport const startEditCells: PureReducer<EditingCell[], EditingCellsPayload> = (\n  prevEditingCells, { editingCells },\n) => [...prevEditingCells, ...editingCells];\n\nexport const stopEditCells: PureReducer<EditingCell[], EditingCellsPayload> = (\n  prevEditingCells, { editingCells },\n) => {\n  return prevEditingCells.filter(({ rowId, columnName }) => (\n    !editingCells.some(({ rowId: currentRowId, columnName: currentColumnName }) => (\n      currentRowId === rowId && currentColumnName === columnName\n    ))\n  ));\n};\n\nexport const addRow: PureReducer<Row[], RowPayload> = (\n  addedRows, { row } = { row: {} },\n) => [...addedRows, row];\n\nexport const changeAddedRow: PureReducer<Row[], RowChangePayload> = (\n  addedRows, { rowId, change },\n) => {\n  const result = addedRows.slice();\n  result[rowId] = { ...result[rowId], ...change };\n  return result;\n};\n\nexport const cancelAddedRows: PureReducer<Row[], RowIdsPayload> = (addedRows, { rowIds }) => {\n  const result: Row[] = [];\n  const indexSet = new Set(rowIds);\n  addedRows.forEach((row, index) => {\n    if (!indexSet.has(index)) {\n      result.push(row);\n    }\n  });\n  return result;\n};\n\nexport const changeRow: PureReducer<RowChanges, RowChangePayload> = (\n  prevRowChanges, { rowId, change },\n) => {\n  const prevChange = prevRowChanges[rowId] || {};\n  return {\n    ...prevRowChanges,\n    [rowId]: {\n      ...prevChange,\n      ...change,\n    },\n  };\n};\n\nexport const cancelChanges: PureReducer<RowChanges, RowIdsPayload> = (\n  prevRowChanges, { rowIds },\n) => {\n  const result = { ...prevRowChanges };\n  rowIds.forEach((rowId) => {\n    delete result[rowId];\n  });\n  return result;\n};\n\nexport const deleteRows: PureReducer<RowId[], RowIdsPayload> = (deletedRowIds, { rowIds }) => [\n  ...deletedRowIds, ...rowIds,\n];\n\nexport const cancelDeletedRows: PureReducer<RowId[], RowIdsPayload> = (\n  deletedRowIds, { rowIds },\n) => {\n  const rowIdSet = new Set(rowIds);\n  return deletedRowIds.filter(rowId => !rowIdSet.has(rowId));\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  EditingColumnExtension, CreateRowChangeFn, Row, RowId, RowChanges,\n} from '../../types';\n\nexport const changedRowsByIds: PureComputed<\n  [any, RowId[]], RowChanges\n> = (changes, rowIds) => {\n  const result = {};\n  rowIds.forEach((rowId) => {\n    result[rowId] = changes[rowId];\n  });\n  return result;\n};\n\nexport const addedRowsByIds: PureComputed<[Row[], RowId[]]> = (addedRows, rowIds) => {\n  const rowIdSet = new Set(rowIds);\n  const result: Row[] = [];\n  addedRows.forEach((row, index) => {\n    if (rowIdSet.has(index)) {\n      result.push(row);\n    }\n  });\n  return result;\n};\n\nconst defaultCreateRowChange: CreateRowChangeFn = (row, value, columnName) => (\n  { [columnName]: value }\n);\nexport const createRowChangeGetter: PureComputed<\n  [CreateRowChangeFn?, EditingColumnExtension[]?], CreateRowChangeFn\n> = (\n  createRowChange = defaultCreateRowChange,\n  columnExtensions = [],\n) => {\n  const map = columnExtensions.reduce((acc, columnExtension) => {\n    if (columnExtension.createRowChange) {\n      acc[columnExtension.columnName] = columnExtension.createRowChange;\n    }\n    return acc;\n  }, {});\n\n  return (row, value, columnName) => {\n    if (map[columnName]) {\n      return map[columnName](row, value, columnName);\n    }\n    return createRowChange(row, value, columnName);\n  };\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { RowId, RowChanges } from '../../types';\n\nexport const getRowChange: PureComputed<[RowChanges, RowId], any> = (\n  rowChanges, rowId,\n) => rowChanges[rowId] || {};\n","export const TABLE_REORDERING_TYPE = Symbol('reordering');\n","import { PureReducer, slice } from '@devexpress/dx-core';\nimport { ColumnOrder, ChangeColumnOrderPayload } from '../../types';\n\nexport const changeColumnOrder: PureReducer<ColumnOrder, ChangeColumnOrderPayload> = (\n  order, { sourceColumnName, targetColumnName },\n) => {\n  const sourceColumnIndex = order.indexOf(sourceColumnName);\n  const targetColumnIndex = order.indexOf(targetColumnName);\n  const newOrder = slice(order);\n\n  newOrder.splice(sourceColumnIndex, 1);\n  newOrder.splice(targetColumnIndex, 0, sourceColumnName);\n  return newOrder;\n};\n","export const TABLE_DATA_TYPE = Symbol('data');\nexport const TABLE_NODATA_TYPE = Symbol('nodata');\nexport const TABLE_FLEX_TYPE = Symbol('flex');\n","import { PureComputed, slice } from '@devexpress/dx-core';\nimport mergeSort from '../../utils/merge-sort';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { TABLE_REORDERING_TYPE } from './constants';\nimport { OrderedColumnsComputed, DraftOrderComputed, TableRow } from '../../types';\n\nexport const orderedColumns: OrderedColumnsComputed = (\n  tableColumns = [], order,\n) => mergeSort(tableColumns, (a, b) => {\n  if (a.type !== TABLE_DATA_TYPE || b.type !== TABLE_DATA_TYPE) return 0;\n\n  const aPos = order.indexOf(a.column.name);\n  const bPos = order.indexOf(b.column.name);\n  return aPos - bPos;\n});\n\nexport const tableHeaderRowsWithReordering: PureComputed<[TableRow[]]> = tableHeaderRows => [\n  ...tableHeaderRows,\n  {\n    key: TABLE_REORDERING_TYPE.toString(),\n    type: TABLE_REORDERING_TYPE,\n    height: 0,\n  },\n];\n\nexport const draftOrder: DraftOrderComputed = (order, sourceColumnIndex, targetColumnIndex) => {\n  if (sourceColumnIndex === -1\n    || targetColumnIndex === -1\n    || sourceColumnIndex === targetColumnIndex) {\n    return order;\n  }\n\n  const result = slice(order);\n  const sourceColumn = order[sourceColumnIndex];\n  result.splice(sourceColumnIndex, 1);\n  result.splice(targetColumnIndex, 0, sourceColumn);\n\n  return result;\n};\n","import { ColumnSizesFn, ValidValueFn, ConvertWidthFn, ColumnWidthFn } from '../../types';\n\nconst getColumnWidth: ColumnWidthFn = (\n  columnWidths, name, {\n    columnName, cachedWidths, shift, minColumnWidth, maxColumnWidth, columnExtensions = [],\n}) => {\n  const change = name === columnName ? shift : -shift;\n  const column  = columnWidths.find(elem => elem.columnName === name)!;\n  const extension = columnExtensions.find(elem => elem.columnName === name);\n  const width = typeof column.width === 'number'\n    ? column.width\n    : cachedWidths[name];\n  const minWidth = extension && extension.minWidth! >= 0\n    ? extension.minWidth\n    : minColumnWidth;\n  const maxWidth = extension && extension.maxWidth! >= 0\n    ? extension.maxWidth\n    : maxColumnWidth;\n  const size = Math.max(\n    minWidth!,\n    Math.min(width + change, maxWidth!),\n  );\n\n  return ({ width, size });\n};\n\nexport const getColumnSizes: ColumnSizesFn = (\n  columnWidths, payload) => {\n  const { columnName, nextColumnName, resizingMode, shift } = payload;\n  const { width, size } = getColumnWidth(columnWidths, columnName, payload);\n\n  if (resizingMode === 'nextColumn') {\n    const { width: nextWidth, size: nextSize } = getColumnWidth(\n      columnWidths, nextColumnName, payload,\n    );\n\n    if (size + nextSize !== width + nextWidth) {\n      const moreThanLimit = size + nextSize > width + nextWidth;\n      const columnExpand = shift > 0;\n      if (moreThanLimit !== columnExpand) {\n        return { size, nextSize: width + nextWidth - size };\n      }\n      return { size: width + nextWidth - nextSize, nextSize };\n    }\n    return { size, nextSize };\n  }\n\n  return { size };\n};\n\nexport const isValidValue: ValidValueFn = (value, validUnits) => {\n  const numb = parseInt(value, 10);\n  const unit = numb ? value.substr(numb.toString().length) : value;\n  const sizeIsAuto = isNaN(numb) && unit === 'auto';\n  const sizeIsValid = numb >= 0 && validUnits.some(validUnit => validUnit === unit);\n  return sizeIsAuto || sizeIsValid;\n};\n\nexport const convertWidth: ConvertWidthFn = (value) => {\n  if (typeof value === 'string') {\n    const numb = parseInt(value, 10);\n    if (value.substr(numb.toString().length).length > 0) {\n      return value;\n    }\n    return numb;\n  }\n  return value;\n};\n","import { TABLE_DATA_TYPE } from '../table/constants';\nimport { TableColumn, SpecifyWidthsFn, TableColumnsWithWidthFn, ErrorFn } from '../../types';\nimport { isValidValue, convertWidth } from './helpers';\n\nconst VALID_UNITS = ['px', '%', 'em', 'rem', 'vm', 'vh', 'vmin', 'vmax', ''];\nconst NOT_FOR_WIDGET_UNITS = ['%'];\n/* tslint:disable max-line-length */\nconst COLUMN_RESIZING_ERROR = 'The columnWidths property of the TableColumnResizing plugin is given an invalid value.';\n\nconst specifyWidths: SpecifyWidthsFn = (tableColumns, widths, resizingMode, onError) => {\n  if (resizingMode !== 'widget' && resizingMode !== 'nextColumn') {\n    onError();\n  }\n  if (!widths.length) return tableColumns;\n  return tableColumns\n    .reduce((acc, tableColumn) => {\n      if (tableColumn.type === TABLE_DATA_TYPE) {\n        const columnName = tableColumn.column!.name;\n        const column = widths.find(el => el.columnName === columnName);\n        const width = column && column.width;\n        if (typeof width !== 'number') {\n          if (width === undefined) {\n            onError();\n          } else if (!isValidValue(width, VALID_UNITS)) {\n            onError();\n          } else if (resizingMode === 'widget' && isValidValue(width, NOT_FOR_WIDGET_UNITS)) {\n            onError();\n          }\n        } else if (width < 0) {\n          onError();\n        }\n        if (width === undefined) {\n          acc.push(tableColumn);\n        } else {\n          acc.push({ ...tableColumn, width: convertWidth(width) });\n        }\n      } else {\n        acc.push(tableColumn);\n      }\n      return acc;\n    }, [] as TableColumn[]);\n};\n\nexport const tableColumnsWithWidths: TableColumnsWithWidthFn = (\n  tableColumns, columnWidths, resizingMode,\n) => specifyWidths(tableColumns, columnWidths, resizingMode, throwError);\n\nexport const tableColumnsWithDraftWidths: TableColumnsWithWidthFn = (\n  tableColumns, draftColumnWidths, resizingMode,\n) => specifyWidths(tableColumns, draftColumnWidths, resizingMode, () => {});\n\nconst throwError: ErrorFn = () => {\n  throw new Error(COLUMN_RESIZING_ERROR);\n};\n","import { slice } from '@devexpress/dx-core';\nimport { ColumnWidthReducer } from '../../types';\nimport { getColumnSizes } from './helpers';\n\nexport const changeTableColumnWidth: ColumnWidthReducer = (state, payload) => {\n  const { columnWidths } = state;\n  const { columnName, nextColumnName, resizingMode } = payload;\n  const nextColumnWidth = slice(columnWidths);\n  const index = nextColumnWidth.findIndex(elem => elem.columnName === columnName);\n  const nextIndex = nextColumnWidth.findIndex(elem => elem.columnName === nextColumnName);\n  const { size, nextSize } = getColumnSizes(columnWidths, payload);\n\n  nextColumnWidth.splice(index, 1, { columnName, width: size });\n  if (resizingMode === 'nextColumn') {\n    nextColumnWidth.splice(nextIndex, 1, { columnName: nextColumnName, width: nextSize });\n  }\n  return {\n    columnWidths: nextColumnWidth,\n  };\n};\n\nexport const draftTableColumnWidth: ColumnWidthReducer = (state, payload) => {\n  const { columnWidths } = state;\n  const { columnName, nextColumnName, resizingMode } = payload;\n  const { size, nextSize } = getColumnSizes(columnWidths, payload);\n\n  if (resizingMode === 'nextColumn') {\n    return { draftColumnWidths: [\n      { columnName, width: size }, { columnName: nextColumnName, width: nextSize! },\n    ] };\n  }\n  return { draftColumnWidths: [{ columnName, width: size }] };\n};\n\nexport const cancelTableColumnWidthDraft = () => ({\n  draftColumnWidths: [],\n});\n","export const TABLE_EDIT_COMMAND_TYPE = Symbol('editCommand');\n","export const TABLE_ADDED_TYPE = Symbol('added');\nexport const TABLE_EDIT_TYPE = Symbol('edit');\n","export const TABLE_HEADING_TYPE = Symbol('heading');\n","import { TABLE_ADDED_TYPE, TABLE_EDIT_TYPE } from '../table-edit-row/constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { TABLE_HEADING_TYPE } from '../table-header-row/constants';\nimport { TABLE_EDIT_COMMAND_TYPE } from './constants';\nimport { IsSpecificCellFn } from '../../types';\n\nexport const isHeadingEditCommandsTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_EDIT_COMMAND_TYPE;\nexport const isEditCommandsTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => (tableRow.type === TABLE_DATA_TYPE || tableRow.type === TABLE_ADDED_TYPE\n  || tableRow.type === TABLE_EDIT_TYPE) && tableColumn.type === TABLE_EDIT_COMMAND_TYPE;\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_EDIT_COMMAND_TYPE } from './constants';\nimport { TableColumn } from '../../types';\nimport { convertWidth } from '../table-column-resizing/helpers';\n\nexport const tableColumnsWithEditing: PureComputed<[TableColumn[], number | string]> = (\n  tableColumns, width,\n) => [\n  { width: convertWidth(width),\n    key: TABLE_EDIT_COMMAND_TYPE.toString(), type: TABLE_EDIT_COMMAND_TYPE },\n  ...tableColumns];\n","import { TABLE_ADDED_TYPE, TABLE_EDIT_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { IsSpecificRowFn, IsSpecificCellFn } from '../../types';\n\nexport const isEditTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => (tableRow.type === TABLE_ADDED_TYPE || tableRow.type === TABLE_EDIT_TYPE)\n  && tableColumn.type === TABLE_DATA_TYPE;\nexport const isAddedTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_ADDED_TYPE;\nexport const isEditTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_EDIT_TYPE;\n","import { slice } from '@devexpress/dx-core';\nimport { TABLE_ADDED_TYPE, TABLE_EDIT_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { TableRowsWithEditingFn } from '../../types';\n\nexport const tableRowsWithEditing: TableRowsWithEditingFn = (\n  tableRows, editingRowIds, addedRows, rowHeight,\n) => {\n  const rowIds = new Set(editingRowIds);\n  const editedTableRows = tableRows\n    .map(tableRow => (\n      tableRow.type === TABLE_DATA_TYPE && rowIds.has(tableRow.rowId!)\n        ? {\n          ...tableRow,\n          type: TABLE_EDIT_TYPE,\n          height: rowHeight,\n        }\n        : tableRow\n    ));\n\n  const addedTableRows = addedRows\n    .map((row, rowIndex) => ({\n      row,\n      key: `${TABLE_ADDED_TYPE.toString()}_${rowIndex}`,\n      type: TABLE_ADDED_TYPE,\n      rowId: rowIndex,\n      height: rowHeight,\n    }));\n\n  return [\n    ...slice(addedTableRows).reverse(),\n    ...editedTableRows,\n  ];\n};\n","import { TableRowsWithEditingCellsFn, TableColumnsWithEditingCellsFn } from '../../types';\nimport { TABLE_DATA_TYPE } from '../table/constants';\n\nexport const rowsWithEditingCells: TableRowsWithEditingCellsFn = (\n  tableBodyRows, editingCells,\n) => tableBodyRows.map((row) => {\n  const { rowId, type } = row;\n  if (\n    rowId !== undefined &&\n    type === TABLE_DATA_TYPE &&\n    editingCells.some(elem => elem.rowId === rowId)\n  ) {\n    return {\n      ...row,\n      hasEditCell: true,\n    };\n  }\n  return row;\n});\n\nexport const columnsWithEditingCells: TableColumnsWithEditingCellsFn = (\n  tableColumns, editingCells,\n) => tableColumns.map((tableColumn) => {\n  const columnName = tableColumn.column ? tableColumn.column.name : undefined;\n  if (columnName !== undefined && editingCells.some(elem => elem.columnName === columnName)) {\n    return {\n      ...tableColumn,\n      hasEditCell: true,\n    };\n  }\n  return tableColumn;\n});\n","export const TABLE_FILTER_TYPE = Symbol('filter');\nexport const DEFAULT_FILTER_OPERATIONS = [\n  'contains',\n  'notContains',\n  'startsWith',\n  'endsWith',\n  'equal',\n  'notEqual',\n];\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_FILTER_TYPE, DEFAULT_FILTER_OPERATIONS } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport {\n  IsSpecificCellFn, IsSpecificRowFn, FilterOperation, GetAvailableFilterOperationsFn,\n  GetSelectedFilterOperationFn,\n} from '../../types';\n\nexport const isFilterTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_FILTER_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n\nexport const isFilterTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_FILTER_TYPE;\n\nexport const getColumnFilterOperations: PureComputed<\n  [GetAvailableFilterOperationsFn, string],\n  FilterOperation[]\n> = (\n  getAvailableFilterOperations, columnName,\n) => (getAvailableFilterOperations && getAvailableFilterOperations(columnName))\n  || DEFAULT_FILTER_OPERATIONS;\n\nexport const isFilterValueEmpty = (value: any) => value === undefined || !String(value).length;\n\nexport const getSelectedFilterOperation: GetSelectedFilterOperationFn = (\n  filterOperations, columnName, columnFilter, columnFilterOperations,\n) => {\n  if (columnFilter && columnFilter.operation) {\n    return columnFilter.operation;\n  }\n  if (filterOperations[columnName]) {\n    return filterOperations[columnName];\n  }\n  return columnFilterOperations[0];\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_FILTER_TYPE } from './constants';\nimport { TableRow } from '../../types';\n\nexport const tableHeaderRowsWithFilter: PureComputed<[TableRow[], number]> = (\n  headerRows, rowHeight,\n) => [\n  ...headerRows,\n  { key: TABLE_FILTER_TYPE.toString(), type: TABLE_FILTER_TYPE, height: rowHeight }];\n","export const TABLE_GROUP_TYPE = Symbol('group');\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  GetVisibleBoundaryWithFixedFn, VisibleBoundary, GetVisibleBoundaryFn, GetSpanBoundaryFn,\n  CollapseBoundariesFn, GetItemSizeFn, GetCollapsedColumnsFn, CollapsedColumn,\n  GetCollapsedAndStubRowsFn, GetCollapsedCellsFn, GetCollapsedGridFn, GetColumnWidthFn,\n  CalculateRowHeightFn,\n  TableColumn,\n  CollapsedCell,\n  GetColumnWidthGetterFn,\n  GetCollapsedGridsFn,\n  CollapsedRow,\n  GetColSpanFn,\n  GetSpecificRenderBoundaryFn,\n  GetRenderBoundaryFn,\n  GetRowsVisibleBoundaryFn,\n  TableRow,\n} from '../types';\nimport { TABLE_FLEX_TYPE, intervalUtil } from '..';\n\nexport const TABLE_STUB_TYPE = Symbol('stub');\n\nexport const getVisibleBoundaryWithFixed: GetVisibleBoundaryWithFixedFn = (\n  visibleBoundary, items,\n) => items.reduce((acc, item, index) => {\n  if (item.fixed && (index < visibleBoundary[0] || index > visibleBoundary[1])) {\n    acc.push([index, index]);\n  }\n  return acc;\n}, [visibleBoundary] as [VisibleBoundary]);\n\nexport const getVisibleBoundary: GetVisibleBoundaryFn = (\n  items, viewportStart, viewportSize, getItemSize, skipItems, offset = 0,\n) => {\n  let start: number | undefined;\n  let end: number | undefined;\n  let index = items[0] && items[0].rowId >= skipItems[0] ? 0 : skipItems[0];\n  const itemSize = getItemSize();\n  let beforePosition = offset !== 0 ? (offset - skipItems[0]) * itemSize : 0;\n\n  const viewportEnd = viewportStart + viewportSize;\n\n  while (end === undefined && index < items.length) {\n    const item = items[index];\n    const afterPosition = beforePosition + getItemSize(item);\n    const isVisible = (beforePosition >= viewportStart && beforePosition < viewportEnd)\n      || (afterPosition > viewportStart && afterPosition <= viewportEnd)\n      || (beforePosition < viewportStart && afterPosition > viewportEnd);\n    if (isVisible && start === undefined) {\n      start = index;\n    }\n    if (!isVisible && start !== undefined) {\n      end = index - 1;\n      break;\n    }\n    index += 1;\n    beforePosition = afterPosition;\n  }\n  if (start !== undefined && end === undefined) {\n    end = index - 1;\n  }\n  end = end === undefined ? 0 : end;\n  start = start === undefined ? 0 : start;\n\n  return [start + offset, end + offset];\n};\n\nexport const getRenderBoundary: GetRenderBoundaryFn = (itemsCount, visibleBoundary, overscan) => {\n  let [start, end] = visibleBoundary;\n  start = Math.max(0, start - overscan);\n  end = Math.min(itemsCount - 1, end + overscan);\n\n  return [start, end];\n};\n\nexport const getColumnBoundaries: PureComputed<\n  [TableColumn[], number, number, GetColumnWidthFn], VisibleBoundary[]\n> = (columns, left, width, getColumnWidth) => (\n  getVisibleBoundaryWithFixed(\n    getColumnsRenderBoundary(\n      columns.length,\n      getVisibleBoundary(columns, left, width, getColumnWidth, [0, 0], 0),\n    ),\n    columns,\n  )\n);\nexport const getRowsVisibleBoundary: GetRowsVisibleBoundaryFn = (\n  rows, top, height, getRowHeight, skipItems, offset, isDataRemote,\n) => {\n  const rowHeight = getRowHeight();\n  const beforePosition = offset !== 0 ? (offset - skipItems[0]) * rowHeight : 0;\n  const noVisibleRowsLoaded = rowHeight > 0 &&\n    beforePosition + rows.length * rowHeight < top ||\n    top < beforePosition;\n\n  let boundaries;\n  if (isDataRemote && noVisibleRowsLoaded) {\n    const topIndex = Math.round(top / rowHeight) + skipItems[0];\n    boundaries = [topIndex, topIndex];\n  } else {\n    boundaries = getVisibleBoundary(rows, top, height, getRowHeight, skipItems, offset);\n  }\n\n  return boundaries;\n};\n\nexport const getColumnsRenderBoundary: GetSpecificRenderBoundaryFn = (\n  columnCount, visibleBoundary,\n) => getRenderBoundary(columnCount, visibleBoundary, 1);\n\nexport const getRowsRenderBoundary: GetSpecificRenderBoundaryFn = (\n  rowsCount, visibleBoundary,\n) => getRenderBoundary(rowsCount, visibleBoundary, 3);\n\nexport const getSpanBoundary: GetSpanBoundaryFn = (\n  items, visibleBoundaries, getItemSpan,\n) => visibleBoundaries\n  .map((visibleBoundary) => {\n    const endIndex = Math.min(visibleBoundary[1], items.length - 1);\n    let end = endIndex;\n    let start = visibleBoundary[0] <= end ? visibleBoundary[0] : 0;\n\n    for (let index = 0; index <= endIndex; index += 1) {\n      const span = getItemSpan(items[index]);\n      if (index < visibleBoundary[0] && index + span > visibleBoundary[0]) {\n        start = index;\n      }\n      if (index + (span - 1) > visibleBoundary[1]) {\n        end = index + (span - 1);\n      }\n    }\n    return [start, end] as VisibleBoundary;\n  });\n\nexport const collapseBoundaries: CollapseBoundariesFn = (\n  itemsCount, visibleBoundaries, spanBoundaries,\n) => {\n  const breakpoints = new Set([0, itemsCount]);\n  spanBoundaries.forEach(rowBoundaries => rowBoundaries\n    .forEach((boundary) => {\n      breakpoints.add(boundary[0]);\n      // next interval starts after span end point\n      breakpoints.add(Math.min(boundary[1] + 1, itemsCount));\n    }));\n\n  visibleBoundaries\n    .filter(boundary => boundary.every(bound => 0 <= bound && bound < itemsCount))\n    .forEach((boundary) => {\n      for (let point = boundary[0]; point <= boundary[1]; point += 1) {\n        breakpoints.add(point);\n      }\n      if (boundary[1] + 1 < itemsCount) {\n        // close last visible point\n        breakpoints.add(boundary[1] + 1);\n      }\n    });\n\n  const bp = [...breakpoints].sort((a, b) => a - b);\n  const bounds: any[] = [];\n  for (let i = 0; i < bp.length - 1; i += 1) {\n    bounds.push([\n      bp[i],\n      bp[i + 1] - 1,\n    ]);\n  }\n\n  return bounds;\n};\n\nconst getItemsSize: GetItemSizeFn = (items, startIndex, endIndex, getItemSize) => {\n  let size = 0;\n  for (let i = startIndex; i <= endIndex; i += 1) {\n    size += getItemSize(items[i]);\n  }\n  return size;\n};\n\nexport const getCollapsedColumns: GetCollapsedColumnsFn = (\n  columns, visibleBoundaries, boundaries, getColumnWidth,\n) => {\n  const collapsedColumns: CollapsedColumn[] = [];\n  boundaries.forEach((boundary) => {\n    const isVisible = visibleBoundaries.reduce((acc, visibleBoundary) => (\n      acc || (visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1])\n    ), false);\n\n    if (isVisible) {\n      const column = columns[boundary[0]];\n      collapsedColumns.push({\n        ...column,\n        width: column.type === TABLE_FLEX_TYPE ? undefined : getColumnWidth(column),\n      });\n    } else {\n      collapsedColumns.push({\n        key: `${TABLE_STUB_TYPE.toString()}_${boundary[0]}_${boundary[1]}`,\n        type: TABLE_STUB_TYPE,\n        width: getItemsSize(columns, boundary[0], boundary[1], getColumnWidth),\n      });\n    }\n  });\n  return collapsedColumns;\n};\n\nexport const getCollapsedRows: GetCollapsedAndStubRowsFn = (\n  rows, visibleBoundary, boundaries, skipItems, getRowHeight, getCells, offset,\n) => {\n  const collapsedRows: any[] = [];\n  boundaries.forEach((boundary) => {\n    const isVisible = visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1];\n    if (isVisible) {\n      const row = rows[boundary[0] - offset];\n      collapsedRows.push({\n        row,\n        cells: getCells(row),\n      });\n    } else {\n      const row = {} as any;\n      collapsedRows.push({\n        row: {\n          key: `${TABLE_STUB_TYPE.toString()}_${boundary[0]}_${boundary[1]}`,\n          type: TABLE_STUB_TYPE,\n          height: calculateRowHeight(rows, skipItems, getRowHeight, boundary[0], boundary[1]),\n        },\n        cells: getCells(row),\n      });\n    }\n  });\n  return collapsedRows;\n};\n\nconst calculateRowHeight: CalculateRowHeightFn = (\n  rows, skipItems, getRowHeight, bound1, bound2,\n) => {\n  if (bound1 === 0) {\n    let end = bound2;\n    if (rows.length && bound2 > rows[rows.length - 1].rowId!) {\n      end = bound2 - skipItems[1];\n    }\n    return getItemsSize(rows, skipItems[0], end, getRowHeight);\n  }\n  return getItemsSize(rows, bound1, bound2 - skipItems[1], getRowHeight);\n};\n\nexport const getCollapsedCells: GetCollapsedCellsFn = (\n  row, columns, spanBoundaries, boundaries, getColSpan,\n) => {\n  const collapsedCells: CollapsedCell[] = [];\n  let index = 0;\n  while (index < boundaries.length) {\n    const boundary = boundaries[index];\n    const isSpan = spanBoundaries.reduce((acc, spanBoundary) => (\n      acc || (spanBoundary[0] <= boundary[0] && boundary[1] <= spanBoundary[1])), false);\n    if (isSpan) {\n      const column = columns[boundary[0]];\n      const realColSpan = getColSpan(row, column);\n      if (realColSpan + index - 1 !== columns.length) {\n        const realColSpanEnd = (realColSpan + boundary[0]) - 1;\n        const colSpanEnd = boundaries.findIndex(\n          colSpanBoundary => colSpanBoundary[0]\n          <= realColSpanEnd && realColSpanEnd\n          <= colSpanBoundary[1],\n        );\n        collapsedCells.push({\n          column,\n          colSpan: (colSpanEnd - index) + 1,\n        });\n      } else {\n        collapsedCells.push({\n          column,\n          colSpan: realColSpan,\n        });\n      }\n      index += 1;\n    } else {\n      collapsedCells.push({\n        column: {\n          key: `${TABLE_STUB_TYPE.toString()}_${boundary[0]}_${boundary[1]}`,\n          type: TABLE_STUB_TYPE,\n        },\n        colSpan: 1,\n      });\n      index += 1;\n    }\n  }\n  return collapsedCells;\n};\n\nconst getVisibleColumnBoundaries: PureComputed<\n  [TableRow[], VisibleBoundary, TableColumn[], VisibleBoundary[], GetColSpanFn], VisibleBoundary[]\n> = (rows, boundaries, columns, columnsVisibleBoundary, getColSpan) => {\n  const rowSpanBoundaries = rows\n    .slice(boundaries[0], boundaries[1] + 1)\n    .map(row => getSpanBoundaryByRow(row, columns, columnsVisibleBoundary, getColSpan));\n  return collapseBoundaries(\n    columns.length,\n    columnsVisibleBoundary,\n    rowSpanBoundaries,\n  );\n};\n\nexport const getCollapsedGrid: GetCollapsedGridFn = ({\n  rows,\n  columns,\n  rowsVisibleBoundary,\n  columnsVisibleBoundary,\n  getColumnWidth,\n  getRowHeight,\n  getColSpan,\n  totalRowCount,\n  offset,\n}) => {\n  if (!columns.length) {\n    return {\n      columns: [],\n      rows: [],\n    };\n  }\n\n  const boundaries = rowsVisibleBoundary || [0, rows.length - 1 || 1];\n  const columnBoundaries = getVisibleColumnBoundaries(rows, boundaries, columns,\n    columnsVisibleBoundary, getColSpan);\n  const rowBoundaries = collapseBoundaries(totalRowCount!, [boundaries], []);\n\n  return {\n    columns: getCollapsedColumns(\n      columns,\n      columnsVisibleBoundary,\n      columnBoundaries,\n      getColumnWidth,\n    ),\n    rows: getCollapsedRows(\n      rows,\n      boundaries,\n      rowBoundaries,\n      [0, 0],\n      getRowHeight,\n      row => getCollapsedCells(\n        row,\n        columns,\n        getSpanBoundaryByRow(row, columns, columnsVisibleBoundary, getColSpan),\n        columnBoundaries,\n        getColSpan,\n      ),\n      offset,\n    ),\n  };\n};\n\nexport const getColumnWidthGetter: GetColumnWidthGetterFn = (\n  tableColumns, tableWidth, minColumnWidth,\n) => {\n  const colsHavingWidth = tableColumns.filter(col => typeof col.width === 'number');\n  const columnsWidth = colsHavingWidth.reduce((acc, col) => (acc + (col.width as number)!), 0);\n  const autoWidth = (tableWidth - columnsWidth) / (tableColumns.length - colsHavingWidth.length);\n  const autoColWidth = Math.max(autoWidth, minColumnWidth!);\n\n  return (column) => {\n    if (column) {\n      return column.type === TABLE_FLEX_TYPE ? 0 :\n        (typeof column.width === 'number' ? column.width : autoColWidth);\n    }\n    return autoColWidth;\n  };\n};\n\nconst getSpanBoundaryByRow: PureComputed<\n  [TableRow, TableColumn[], VisibleBoundary[], GetColSpanFn], VisibleBoundary[]\n> = (row, columns, visibleColumns, getColSpan) =>\n  getSpanBoundary(columns, visibleColumns, column => getColSpan(row, column));\n\nexport const getCollapsedGrids: GetCollapsedGridsFn = ({\n  headerRows,\n  bodyRows,\n  footerRows,\n  columns,\n  loadedRowsStart,\n  totalRowCount,\n  getCellColSpan,\n  viewport,\n  skipItems,\n  getRowHeight,\n  getColumnWidth,\n}) => {\n  if (!columns.length) {\n    return {\n      headerGrid: { columns: [], rows: [] },\n      bodyGrid: { columns: [], rows: [] },\n      footerGrid: { columns: [], rows: [] },\n    };\n  }\n  const getColSpan: GetColSpanFn =\n    (tableRow, tableColumn) => getCellColSpan!({ tableRow, tableColumn, tableColumns: columns });\n\n  const getCollapsedGridRows: PureComputed<\n    [TableRow[], number[], VisibleBoundary[], number?, number?], CollapsedRow[]\n  > = (rows, rowsBoundary, columnsBoundary, rowCount = rows.length, offset = 0) => {\n    return getCollapsedRows(rows, rowsBoundary,\n      collapseBoundaries(rowCount, [rowsBoundary], []),\n      skipItems,\n      getRowHeight,\n      row => getCollapsedCells(\n        row,\n        columns,\n        getSpanBoundaryByRow(row, columns, viewport.columns, getColSpan),\n        columnsBoundary,\n        getColSpan,\n      ),\n      offset,\n    );\n  };\n\n  const rowsVisibleBoundary = adjustedRenderRowBounds(viewport.rows, bodyRows.length,\n    loadedRowsStart);\n  const columnBoundaries = getVisibleColumnBoundaries(bodyRows, rowsVisibleBoundary,\n    columns, viewport.columns, getColSpan);\n  const commonColumns = getCollapsedColumns(\n    columns,\n    viewport.columns,\n    columnBoundaries,\n    getColumnWidth,\n  );\n\n  return {\n    headerGrid: {\n      columns: commonColumns,\n      rows: getCollapsedGridRows(\n        headerRows, getRowsRenderBoundary(headerRows.length, viewport.headerRows), columnBoundaries,\n      ),\n    },\n    bodyGrid: {\n      columns: commonColumns,\n      rows: getCollapsedGridRows(\n        bodyRows,\n        rowsVisibleBoundary,\n        columnBoundaries,\n        totalRowCount || 1,\n        loadedRowsStart,\n      ),\n    },\n    footerGrid: {\n      columns: commonColumns,\n      rows: getCollapsedGridRows(\n        footerRows, getRowsRenderBoundary(footerRows.length, viewport.footerRows), columnBoundaries,\n      ),\n    },\n  };\n};\n\nconst adjustedRenderRowBounds: PureComputed<[VisibleBoundary, number, number], number[]> = (\n  visibleBounds, rowCount, loadedRowsStart,\n) => {\n  const renderRowBoundaries = getRowsRenderBoundary(\n    loadedRowsStart + rowCount, visibleBounds,\n  );\n  const adjustedInterval = intervalUtil.intersect(\n    { start: renderRowBoundaries[0], end: renderRowBoundaries[1] },\n    { start: loadedRowsStart, end: loadedRowsStart + rowCount },\n  );\n  return [adjustedInterval.start, adjustedInterval.end];\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_GROUP_TYPE } from './constants';\nimport { TableRow, TableColumn, IsSpecificCellFn, Grouping, GroupSummaryItem } from '../../types';\nimport { TABLE_STUB_TYPE } from '../../utils/virtual-table';\nimport { TABLE_DATA_TYPE, TABLE_FLEX_TYPE } from '../table/constants';\n\ntype IsGroupIndentCellFn = PureComputed<[TableRow, TableColumn, Grouping[]], boolean>;\n\nconst getGroupIndexByColumn: PureComputed<[Grouping[], TableColumn], number> = (\n  grouping, tableColumn,\n) => grouping.findIndex(\n  columnGrouping => !!tableColumn.column && columnGrouping.columnName === tableColumn.column.name,\n);\n\nconst isIndentCell: IsGroupIndentCellFn = (\n    tableRow,\n    tableColumn,\n    grouping,\n  ) => {\n  if (tableColumn.column && tableRow.row.groupedBy === tableColumn.column.name) return false;\n  const rowGroupIndex = grouping.findIndex(\n    columnGrouping => columnGrouping.columnName === tableRow.row.groupedBy,\n  );\n  const columnGroupIndex = getGroupIndexByColumn(grouping, tableColumn);\n\n  return columnGroupIndex < rowGroupIndex;\n};\n\nexport const isGroupTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => !!(tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE\n  && tableColumn.column\n  && tableColumn.column.name === tableRow.row.groupedBy);\n\nexport const isGroupIndentTableCell: IsGroupIndentCellFn = (\n  tableRow, tableColumn, grouping,\n) => (\n  tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE &&\n  isIndentCell(tableRow, tableColumn, grouping)\n);\n\nexport const isGroupIndentStubTableCell: IsGroupIndentCellFn = (\n  tableRow, tableColumn, grouping,\n) => (\n  (tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_STUB_TYPE &&\n    isIndentCell(tableRow, tableColumn, grouping))\n);\n\nexport const isGroupTableRow = (tableRow: TableRow) => tableRow.type === TABLE_GROUP_TYPE;\n\nexport const isGroupRowOrdinaryCell: IsSpecificCellFn = (tableRow, tableColumn) => (\n  isGroupTableRow(tableRow) && !isGroupTableCell(tableRow, tableColumn)\n);\n\nconst columnHasGroupRowSummary: PureComputed<[TableColumn, GroupSummaryItem[]], boolean> = (\n  tableColumn, groupSummaryItems,\n) => (\n  !!(groupSummaryItems && groupSummaryItems\n    .some(item => (\n      (!item.showInGroupFooter && item.alignByColumn)\n        && item.columnName === (tableColumn.column && tableColumn.column.name)\n    )))\n);\n\nexport const isRowSummaryCell: PureComputed<\n  [TableRow, TableColumn, Grouping[], GroupSummaryItem[]], boolean\n> = (\n  tableRow, tableColumn, grouping, groupSummaryItems,\n) => (\n  columnHasGroupRowSummary(tableColumn, groupSummaryItems)\n  && !isGroupIndentTableCell(tableRow, tableColumn, grouping)\n);\n\nexport const isPreviousCellContainSummary: PureComputed<\n  [TableRow, TableColumn, TableColumn[], Grouping[], GroupSummaryItem[]], boolean\n> = (\n  tableRow, tableColumn, tableColumns, grouping, groupSummaryItems,\n) => {\n  const columnIndex = tableColumns.indexOf(tableColumn);\n  return columnIndex > 0 && isRowSummaryCell(\n    tableRow, tableColumns[columnIndex - 1], grouping, groupSummaryItems,\n  );\n};\n\nexport const calculateGroupCellIndent: PureComputed<[TableColumn, Grouping[], number], number> = (\n  tableColumn, grouping, indentWidth,\n) => (\n  indentWidth * getGroupIndexByColumn(grouping, tableColumn)\n);\n\nexport const sortAndSpliceColumns: PureComputed<[TableColumn[], number]> = (\n  tableColumns, firstVisibleColumnIndex,\n) => {\n  const groupColumns = tableColumns.filter(col => col.type === TABLE_GROUP_TYPE);\n  const dataColumns = tableColumns.filter(col => col.type === TABLE_DATA_TYPE);\n  const otherColumns = tableColumns.filter(\n    col =>\n      col.type !== TABLE_DATA_TYPE &&\n      col.type !== TABLE_GROUP_TYPE &&\n      col.type !== TABLE_FLEX_TYPE,\n  );\n\n  if (firstVisibleColumnIndex) {\n    const firstGroupIndex = tableColumns.indexOf(groupColumns[0]);\n    otherColumns.splice(0, Math.min(firstVisibleColumnIndex, firstGroupIndex));\n  }\n\n  return [...groupColumns, ...otherColumns, ...dataColumns];\n};\n","import { TABLE_DATA_TYPE } from '../table/constants';\nimport { TABLE_GROUP_TYPE } from './constants';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  TableColumn, TableRow, IsSpecificRowFn,\n  TableColumnsWithDraftGroupingFn,\n  TableColumnsWithGroupingFn,\n  GroupCellColSpanGetter,\n  GroupSummaryChainsFn,\n  SummaryItem,\n} from '../../types';\nimport { sortAndSpliceColumns } from './helpers';\n\nconst tableColumnsWithDraftGrouping: TableColumnsWithDraftGroupingFn = (\n  tableColumns, grouping, draftGrouping, showColumnWhenGrouped,\n) => tableColumns\n  .reduce((acc, tableColumn) => {\n    if (tableColumn.type !== TABLE_DATA_TYPE) {\n      acc.push(tableColumn);\n      return acc;\n    }\n\n    const columnName = tableColumn.column && tableColumn.column.name || '';\n    const columnGroupingExists = grouping\n      .some(columnGrouping => columnGrouping.columnName === columnName);\n    const columnDraftGroupingExists = draftGrouping\n      .some(columnGrouping => columnGrouping.columnName === columnName);\n\n    if ((!columnGroupingExists && !columnDraftGroupingExists)\n        || showColumnWhenGrouped(columnName)) {\n      acc.push(tableColumn);\n    } else if ((!columnGroupingExists && columnDraftGroupingExists)\n        || (columnGroupingExists && !columnDraftGroupingExists)) {\n      acc.push({\n        ...tableColumn,\n        draft: true,\n      });\n    }\n    return acc;\n  // tslint:disable-next-line: prefer-array-literal\n  }, [] as Array<TableColumn & { draft?: boolean }>);\n\nexport const tableColumnsWithGrouping: TableColumnsWithGroupingFn = (\n  columns, tableColumns, grouping, draftGrouping, indentColumnWidth, showColumnWhenGrouped,\n) => [\n  ...grouping.map((columnGrouping) => {\n    const groupedColumn = columns.find(column => column.name === columnGrouping.columnName);\n    return {\n      key: `${TABLE_GROUP_TYPE.toString()}_${groupedColumn!.name}`,\n      type: TABLE_GROUP_TYPE,\n      column: groupedColumn,\n      width: indentColumnWidth,\n    };\n  }),\n  ...tableColumnsWithDraftGrouping(tableColumns, grouping, draftGrouping, showColumnWhenGrouped),\n];\n\nexport const tableRowsWithGrouping: PureComputed<[TableRow[], IsSpecificRowFn]> = (\n  tableRows, isGroupRow,\n) => tableRows.map((tableRow) => {\n  if (tableRow.type !== TABLE_DATA_TYPE || !isGroupRow(tableRow.row)) {\n    return tableRow;\n  }\n  return {\n    ...tableRow,\n    key: `${TABLE_GROUP_TYPE.toString()}_${tableRow.row.compoundKey}`,\n    type: TABLE_GROUP_TYPE,\n  };\n});\n\nconst isRowLevelSummary: PureComputed<[SummaryItem[], string], boolean> = (\n  groupSummaryItems, colName,\n) => (\n  groupSummaryItems.some((item: any) => (\n    !item.showInGroupFooter && item.alignByColumn && item.columnName === colName),\n  )\n);\n\nconst groupSummaryChains: GroupSummaryChainsFn = (\n  tableRow,\n  tableColumns,\n  groupSummaryItems,\n  firstVisibleColumnIndex,\n) => {\n  let captionStarted = false;\n  return sortAndSpliceColumns(tableColumns, firstVisibleColumnIndex)\n    .reduce((acc, col) => {\n      const colName = (col.column && col.column.name) as string;\n      const colKey = col.key;\n      const isStartOfGroupCaption = col.type === TABLE_GROUP_TYPE\n        && tableRow.row.groupedBy === colName;\n      const isIndentColumn = col.type === TABLE_GROUP_TYPE\n        && tableRow.row.groupedBy !== colName && !captionStarted;\n\n      if (isStartOfGroupCaption) {\n        captionStarted = true;\n      }\n\n      if (isStartOfGroupCaption || isIndentColumn) {\n        acc.push([colKey]);\n      } else if (groupSummaryItems && isRowLevelSummary(groupSummaryItems, colName)) {\n        acc.push([colKey]);\n        acc.push([]);\n      } else {\n        acc[acc.length - 1].push(colKey);\n      }\n      return acc;\n    }, [[]] as string[][]);\n};\n\nexport const tableGroupCellColSpanGetter: GroupCellColSpanGetter = (\n  getTableCellColSpan, groupSummaryItems, firstVisibleColumnIndex,\n) => (params) => {\n  const { tableRow, tableColumns, tableColumn } = params;\n\n  if (tableRow.type === TABLE_GROUP_TYPE) {\n    const colKey = tableColumn.key;\n    const chains = groupSummaryChains(\n      tableRow, tableColumns, groupSummaryItems, firstVisibleColumnIndex,\n    );\n    const chain = chains.find(ch => ch[0] === colKey);\n\n    if (chain) {\n      return chain.length;\n    }\n  }\n  return getTableCellColSpan(params);\n};\n","import { TABLE_HEADING_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport {\n  IsSpecificCellFn, IsSpecificRowFn, HeaderColumnChain,\n  SplitHeaderColumnChainsFn, FindChainByColumnIndexFn,\n  GenerateChainsFn,\n  NextColumnNameFn,\n  GetNextColumnNameFn,\n} from '../../types';\n\nexport const isHeadingTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n\nexport const isHeadingTableRow: IsSpecificRowFn = tableRow => (\n  tableRow.type === TABLE_HEADING_TYPE\n);\n\nexport const findChainByColumnIndex: FindChainByColumnIndexFn = (chains, columnIndex) => (\n  chains.find(chain => (\n    chain.start <= columnIndex && columnIndex < chain.start + chain.columns.length\n  ))!\n);\n\nexport const splitHeaderColumnChains: SplitHeaderColumnChainsFn = (\n  tableColumnChains, tableColumns, shouldSplitChain, extendChainProps,\n) => (\n  tableColumnChains.map((row, rowIndex) => row\n    .reduce((acc, chain) => {\n      let currentChain: any = null;\n      chain.columns.forEach((col) => {\n        const column = tableColumns.find(c => c.key === col.key);\n        const isNewGroup = shouldSplitChain(currentChain, column!, rowIndex);\n\n        if (isNewGroup) {\n          const start = currentChain\n            ? (currentChain.start + currentChain.columns.length)\n            : chain.start;\n\n          acc.push({\n            ...chain,\n            ...extendChainProps(column!),\n            start,\n            columns: [],\n          });\n          currentChain = acc[acc.length - 1];\n        }\n\n        currentChain.columns.push(column);\n      });\n\n      return acc;\n    }, [] as HeaderColumnChain[]))\n);\n\nexport const generateSimpleChains: GenerateChainsFn = (rows, columns) => (\n  rows.map(() => ([{\n    columns,\n    start: 0,\n  }]))\n);\n\nconst nextColumnName: NextColumnNameFn = (tableColumns , index) => {\n  const isNextColumnHasName = index < tableColumns.length - 1 && tableColumns[index + 1].column;\n  return isNextColumnHasName\n    ? tableColumns[index + 1].column!.name\n    : undefined;\n};\n\nexport const getNextColumnName: GetNextColumnNameFn = (tableColumns, columnName) => {\n  const index = tableColumns.findIndex(elem =>\n    elem.column && elem.column.name === columnName,\n  );\n  return index >= 0\n    ? nextColumnName(tableColumns, index)\n    : undefined;\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_HEADING_TYPE } from './constants';\nimport { TableRow } from '../../types';\n\nexport const tableRowsWithHeading: PureComputed<[TableRow[]]> = headerRows => [\n  { key: TABLE_HEADING_TYPE.toString(), type: TABLE_HEADING_TYPE },\n  ...headerRows];\n","export const TABLE_BAND_TYPE = Symbol('band');\nexport const BAND_GROUP_CELL = 'bandGroupCell';\nexport const BAND_HEADER_CELL = 'bandHeaderCell';\nexport const BAND_EMPTY_CELL = 'bandEmptyCell';\nexport const BAND_DUPLICATE_RENDER = 'bandDuplicateRender';\nexport const BAND_FILL_LEVEL_CELL = 'bandFillLevelCell';\n","import {\n  TABLE_BAND_TYPE, BAND_GROUP_CELL, BAND_HEADER_CELL, BAND_EMPTY_CELL,\n  BAND_DUPLICATE_RENDER, BAND_FILL_LEVEL_CELL,\n} from './constants';\nimport { TABLE_HEADING_TYPE } from '../table-header-row/constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { findChainByColumnIndex } from '../table-header-row/helpers';\nimport {\n  GetColumnBandMetaFn, GetBandComponentFn, CalculateBandFn, Row,\n} from '../../types';\nimport { TABLE_STUB_TYPE } from '../../utils/virtual-table';\n\nexport const isBandedTableRow = (tableRow: Row) => (tableRow.type === TABLE_BAND_TYPE);\nexport const isBandedOrHeaderRow = (tableRow: Row) => isBandedTableRow(tableRow)\n  || tableRow.type === TABLE_HEADING_TYPE;\nexport const isNoDataColumn = (columnType: symbol) => columnType !== TABLE_DATA_TYPE;\n\nexport const getColumnMeta: GetColumnBandMetaFn = (\n  columnName, bands, tableRowLevel, key = '',\n  level = 0, title = null, result = null,\n) => bands.reduce((acc, band) => {\n  if (band.columnName === columnName) {\n    return { ...acc, title, level, key };\n  }\n  if (band.children !== undefined) {\n    const rowLevelPassed = level > tableRowLevel;\n    const bandTitle = rowLevelPassed ? title : band.title;\n    const bandKey = rowLevelPassed ? key : `${key}_${bandTitle}`;\n\n    return getColumnMeta(\n      columnName,\n      band.children,\n      tableRowLevel,\n      bandKey,\n      level + 1,\n      bandTitle,\n      acc,\n    );\n  }\n  return acc;\n}, result || { level, title, key: title });\n\nexport const calculateBand: CalculateBandFn = (visibleBound, headerChain) => {\n  if (visibleBound) {\n    const bandStart = Math.max(visibleBound[0], headerChain.start);\n\n    const bandEnd = Math.min(\n      visibleBound[1] + 1,\n      headerChain.start + headerChain.columns.length,\n    );\n\n    return [bandStart, bandEnd];\n  }\n\n  return [headerChain.start, headerChain.start + headerChain.columns.length];\n};\n\nexport const getBandComponent: GetBandComponentFn = (\n  { tableColumn: currentTableColumn, tableRow, rowSpan },\n  tableHeaderRows, tableColumns, columnBands, tableHeaderColumnChains,\n  columnVisibleIntervals, bandLevelsVisibility,\n) => {\n  if (rowSpan) return { type: BAND_DUPLICATE_RENDER, payload: null };\n\n  const maxLevel = tableHeaderRows.filter(column => column.type === TABLE_BAND_TYPE).length + 1;\n  const { level } = tableRow;\n  const currentRowLevel = level === undefined\n    ? maxLevel - 1 : level;\n  const currentColumnMeta = currentTableColumn.type === TABLE_DATA_TYPE\n    ? getColumnMeta(currentTableColumn.column!.name, columnBands, currentRowLevel)\n    : { level: 0, title: '' };\n\n  const currentColumnIndex = tableColumns\n    .findIndex(column => column.key === currentTableColumn.key);\n\n  const levelsCount = bandLevelsVisibility.length;\n  const visibleLevelsCount = bandLevelsVisibility.filter(Boolean).length;\n\n  if (currentColumnMeta.level < currentRowLevel) {\n    const shouldFillLevel = currentRowLevel > 0 && visibleLevelsCount < levelsCount\n      && !bandLevelsVisibility[currentRowLevel] && currentTableColumn.type === TABLE_STUB_TYPE;\n\n    if (shouldFillLevel) {\n      return { type: BAND_FILL_LEVEL_CELL, payload: null };\n    }\n    return { type: BAND_EMPTY_CELL, payload: null };\n  }\n\n  const previousTableColumn = tableColumns[currentColumnIndex - 1];\n  let beforeBorder = false;\n  if (currentColumnIndex > 0 && currentTableColumn.type === TABLE_DATA_TYPE\n    && isNoDataColumn(previousTableColumn.type)) {\n    beforeBorder = true;\n  }\n\n  const isStubColumn = currentTableColumn.type === TABLE_STUB_TYPE;\n  const isColumnVisible = currentColumnIndex >= 0;\n\n  if (currentColumnMeta.level === currentRowLevel) {\n    if (isStubColumn) {\n      const cellRowSpan = visibleLevelsCount < levelsCount\n        ? visibleLevelsCount || 1\n        : maxLevel;\n\n      return {\n        type: BAND_FILL_LEVEL_CELL,\n        payload: {\n          rowSpan: cellRowSpan,\n        },\n      };\n    }\n\n    if (isColumnVisible) {\n      return {\n        type: BAND_HEADER_CELL,\n        payload: {\n          tableRow: tableHeaderRows.find(row => row.type === TABLE_HEADING_TYPE),\n          rowSpan: maxLevel - currentRowLevel,\n          ...beforeBorder && { beforeBorder },\n        },\n      };\n    }\n  }\n\n  if (!isColumnVisible) return { type: BAND_EMPTY_CELL, payload: null };\n\n  const currentColumnChain = findChainByColumnIndex(\n    tableHeaderColumnChains[currentRowLevel],\n    currentColumnIndex,\n  );\n  const columnVisibleBoundary = columnVisibleIntervals.find(([start, end]) => (\n    start <= currentColumnIndex && currentColumnIndex <= end\n  ));\n\n  const [bandStart, bandEnd] = calculateBand(columnVisibleBoundary, currentColumnChain);\n\n  if (bandStart < currentColumnIndex) {\n    return { type: null, payload: null };\n  }\n\n  return {\n    type: BAND_GROUP_CELL,\n    payload: {\n      colSpan: bandEnd - bandStart,\n      value: currentColumnMeta.title!,\n      column: currentColumnMeta,\n      ...beforeBorder && { beforeBorder },\n    },\n  };\n};\n","import { intervalUtil } from './utils';\nimport {\n  VirtualRows, Row, MergeRowsFn, CalculateRequestedRangeFn,\n  Interval, GridViewport, GetRequestMeta, CorrectRangeFn,\n} from '../../types';\nimport { PureComputed } from '@devexpress/dx-core';\n\nexport const emptyVirtualRows: VirtualRows = {\n  skip: Number.POSITIVE_INFINITY,\n  rows: [],\n};\n\nconst pluckSubarray: PureComputed<[Row[], ...number[]]> = (source, sourceStart, left, right) => (\n  source.slice(left - sourceStart, right - sourceStart)\n);\n\nexport const mergeRows: MergeRowsFn = (\n  rowsInterval, cacheInterval, rows, cacheRows, rowsStart, cacheStart,\n) => {\n  const breakpoints = [\n    rowsInterval.start, rowsInterval.end,\n    cacheInterval.start, cacheInterval.end,\n  ]\n    .filter(i => 0 <= i && i < Number.POSITIVE_INFINITY)\n    .sort((a, b) => a - b);\n\n  let result: Row[] = [];\n  if (breakpoints.length > 1) {\n    for (let i = 0; i < breakpoints.length - 1; i += 1) {\n      const left = breakpoints[i];\n      const right = breakpoints[i + 1];\n      const chunk = rowsInterval.start <= left && right <= rowsInterval.end\n        ? pluckSubarray(rows, rowsStart, left, right) // rows have higher priority\n        : pluckSubarray(cacheRows, cacheStart, left, right);\n\n      result = result.concat(chunk);\n    }\n  }\n\n  return {\n    skip: breakpoints[0],\n    rows: result,\n  };\n};\n\nconst correctRequestedRange: CorrectRangeFn = (calculatedRange, referenceIndex, pageSize) => {\n  const { start, end } = calculatedRange;\n\n  if (start - referenceIndex > pageSize / 2) {\n    return { start: start - pageSize, end: start };\n  }\n  return { start, end };\n};\n\nexport const calculateRequestedRange: CalculateRequestedRangeFn = (\n  virtualRows, newRange, pageSize, referenceIndex, isInfiniteScroll,\n) => {\n  const loadedInterval = intervalUtil.getRowsInterval(virtualRows);\n  const isAdjacentPage = Math.abs(loadedInterval.start - newRange.start) < 2 * pageSize;\n  if (isAdjacentPage) {\n    const calculatedRange = intervalUtil.difference(newRange, loadedInterval);\n    if (isInfiniteScroll && calculatedRange !== intervalUtil.empty) {\n      return correctRequestedRange(calculatedRange, referenceIndex, pageSize);\n    }\n    return calculatedRange;\n  }\n\n  // load 3 pages at once because a missing page will be loaded anyway\n  return newRange;\n};\n\nexport const rowToPageIndex: PureComputed<[number, number]> = (\n  rowIndex, pageSize,\n) => Math.floor(rowIndex / pageSize);\n\nexport const recalculateBounds: PureComputed<[number, number, number], Interval> = (\n  middleIndex, pageSize, totalCount,\n) => {\n  const currentPageIndex = rowToPageIndex(middleIndex, pageSize);\n\n  const prevPageIndex = currentPageIndex - 1;\n  const nextPageIndex = currentPageIndex + 2;\n  const start = Math.max(0, prevPageIndex * pageSize);\n  const end = Math.min(nextPageIndex * pageSize, totalCount);\n\n  return {\n    start,\n    end,\n  };\n};\n\nexport const trimRowsToInterval: PureComputed<[VirtualRows, Interval]> = (\n  virtualRows, targetInterval,\n) => {\n  const rowsInterval = intervalUtil.getRowsInterval(virtualRows);\n  const intersection = intervalUtil.intersect(rowsInterval, targetInterval);\n  if (intervalUtil.empty === intersection) {\n    return emptyVirtualRows;\n  }\n\n  const rows = pluckSubarray(\n    virtualRows.rows, virtualRows.skip, intersection.start, intersection.end,\n  );\n\n  return {\n    rows,\n    skip: intersection.start,\n  };\n};\n\nexport const getAvailableRowCount: PureComputed<[boolean, number, number, number], number> = (\n  isInfiniteScroll, newRowCount, lastRowCount, totalRowCount,\n) => {\n  return (isInfiniteScroll\n    ? Math.min(\n        Math.max(newRowCount, lastRowCount),\n        totalRowCount)\n    : totalRowCount\n  );\n};\n\nexport const getForceReloadInterval: PureComputed<[VirtualRows, number, number], Interval> = (\n  virtualRows, pageSize, totalRowCount,\n) => {\n  const { start, end: intervalEnd } = intervalUtil.getRowsInterval(virtualRows);\n  const end = Math.min(\n    Math.max(start + pageSize * 2, intervalEnd),\n    Math.max(start + pageSize * 2, totalRowCount),\n  );\n  return {\n    start,\n    end,\n  };\n};\n\nexport const getRequestMeta: GetRequestMeta = (\n  referenceIndex, virtualRows, pageSize, totalRowCount, forceReload, isInfiniteScroll,\n) => {\n  const actualBounds = forceReload\n    ? getForceReloadInterval(virtualRows, pageSize!, totalRowCount)\n    : recalculateBounds(referenceIndex, pageSize!, totalRowCount);\n  const requestedRange = forceReload\n    ? actualBounds\n    : calculateRequestedRange(\n        virtualRows, actualBounds, pageSize!, referenceIndex, isInfiniteScroll,\n      );\n\n  return { requestedRange, actualBounds };\n};\n\nexport const needFetchMorePages: PureComputed<[VirtualRows, number, number], boolean> = (\n  virtualRows, referenceIndex,  pageSize,\n) => {\n  const { start, end } = intervalUtil.getRowsInterval(virtualRows);\n  const loadCount = end - start;\n  const topTriggerIndex = start > 0 ? start + pageSize : 0;\n  const bottomTriggerIndex = Math.max(topTriggerIndex + pageSize, end - pageSize * 1.5);\n\n  if (loadCount <= 0) {\n    return false;\n  }\n\n  return (referenceIndex < topTriggerIndex || bottomTriggerIndex < referenceIndex);\n};\n\nexport const getReferenceIndex: PureComputed<[GridViewport], number> = (\n  { rows: [top, bottom] },\n) => (\n  (top + bottom) / 2\n);\n\nexport const shouldSendRequest: PureComputed<[Interval, number, number], boolean> = (\n  { start, end }, requestedPageIndex, requestedEndIndex,\n) => {\n  const loadCount = (end - start);\n  return (start !== requestedPageIndex || end !== requestedEndIndex) && loadCount > 0;\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { emptyVirtualRows } from './helpers';\nimport { Interval, VirtualRows } from '../../types';\n\nconst empty: Interval = {\n  start: Number.POSITIVE_INFINITY,\n  end: Number.NEGATIVE_INFINITY,\n};\n\nconst getRowsInterval: PureComputed<[VirtualRows], Interval> = r => (\n  r === emptyVirtualRows\n    ? empty\n    : {\n      start: r.skip,\n      end: r.skip + r.rows.length,\n    }\n);\n\nconst getLength = (a: Interval) => a.end - a.start;\n\nconst intersect = (a: Interval, b: Interval) => {\n  if (a.end < b.start || b.end < a.start) {\n    return empty;\n  }\n\n  return {\n    start: Math.max(a.start, b.start),\n    end: Math.min(a.end, b.end),\n  };\n};\n\nconst difference = (a: Interval, b: Interval) => {\n  if (empty === intervalUtil.intersect(a, b)) {\n    return a;\n  }\n\n  if (b.end < a.end) {\n    return {\n      start: b.end,\n      end: a.end,\n    };\n  }\n  if (a.start < b.start) {\n    return {\n      start: a.start,\n      end: b.start,\n    };\n  }\n  return empty;\n};\n\nexport const intervalUtil = {\n  empty,\n\n  getRowsInterval,\n  getLength,\n\n  intersect,\n  difference,\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_BAND_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { TABLE_GROUP_TYPE } from '../table-group-row/constants';\nimport { getColumnMeta } from './helpers';\nimport { splitHeaderColumnChains, generateSimpleChains } from '../table-header-row/helpers';\nimport {\n  ColumnBands, GetHeaderColumnChainsFn, ShouldSplitChainFn,\n  GetMaxNestedLevelFn, TableRow, TableColumn, HeaderColumnChainRows,\n  BandLevels, BandColumnChainExtension, HeaderColumnChain, VisibleBoundary, GridViewport,\n} from '../../types';\nimport { intervalUtil } from '../virtual-table-state/utils';\n\nexport const tableRowsWithBands: PureComputed<\n  [TableRow[], ColumnBands[], TableColumn[]]\n> = (\n  tableHeaderRows, columnBands, tableColumns,\n) => {\n  const tableDataColumns = tableColumns.filter(column => column.type === TABLE_DATA_TYPE);\n  const getMaxNestedLevel: GetMaxNestedLevelFn = (bands, level = 0, result = null) => (\n    bands.reduce((acc, column) => {\n      if (column.children !== undefined) {\n        return getMaxNestedLevel(column.children, level + 1, acc);\n      }\n      const isDataColumn = tableDataColumns.findIndex(\n        dataColumn => !!dataColumn.column && dataColumn.column.name === column.columnName,\n      ) > -1;\n      if (level > acc.level && isDataColumn) {\n        return { ...acc, level };\n      }\n      return acc;\n    }, result || { level: 0 })\n  );\n\n  const tableBandHeaders = Array.from({\n    length: getMaxNestedLevel(columnBands as ColumnBands[], 0).level,\n  })\n    .map((row, index) => ({\n      key: `${TABLE_BAND_TYPE.toString()}_${index}`,\n      type: TABLE_BAND_TYPE,\n      level: index,\n    }));\n  return [...tableBandHeaders, ...tableHeaderRows];\n};\n\nexport const tableHeaderColumnChainsWithBands: GetHeaderColumnChainsFn<\n  TableRow[], TableColumn[], ColumnBands[]\n> = (\n  tableHeaderRows, tableColumns, bands,\n) => {\n  const chains = generateSimpleChains(tableHeaderRows, tableColumns);\n  const maxBandRowIndex = tableHeaderRows\n    .filter(row => row.type === TABLE_BAND_TYPE)\n    .length;\n  const rawBandChains = chains.slice(0, maxBandRowIndex);\n\n  let currentBand: any = null;\n  const shouldSplitChain: ShouldSplitChainFn = (chain, column, rowIndex) => {\n    if (rowIndex > maxBandRowIndex) return false;\n\n    const columnName = column.column && column.column.name || '';\n    currentBand = getColumnMeta(columnName, bands, rowIndex);\n    return !chain\n      || chain.key !== currentBand.key\n      || chain.columns[0].type === TABLE_GROUP_TYPE;\n  };\n  const extendChainProps = () => ({\n    bandTitle: currentBand?.title,\n    key: currentBand?.key,\n  });\n\n  const bandChains = splitHeaderColumnChains(\n    rawBandChains,\n    tableColumns,\n    shouldSplitChain,\n    extendChainProps,\n  );\n\n  return [...bandChains, ...chains.slice(maxBandRowIndex)];\n};\n\nconst getBandLevel: PureComputed<[ColumnBands[], string, number?], number> = (\n  bands, bandTitle, level = 0,\n) => {\n  for (const band of bands) {\n    if (band.title === bandTitle) {\n      return level;\n    }\n    if (band.children !== undefined) {\n      const result = getBandLevel(band.children, bandTitle, level + 1);\n      if (result >= 0) return result;\n    }\n  }\n  return -1;\n};\n\nconst getBandLevels = (columnsBands: readonly ColumnBands[], levels = {}, level = 0) => {\n  columnsBands.forEach((band) => {\n    if (band.title) {\n      levels[band.title] = level;\n    }\n    if (band.children) {\n      getBandLevels(band.children, levels, level + 1);\n    }\n  });\n  return levels;\n};\n\nexport const columnBandLevels: PureComputed<[ColumnBands[]], BandLevels> = columnsBands => (\n  getBandLevels(columnsBands)\n);\n\nexport const bandLevelsVisibility: PureComputed<\n  [VisibleBoundary[], HeaderColumnChainRows<BandColumnChainExtension>, BandLevels],\n  boolean[]\n> = (columnIntervals, tableHeaderColumnChains, bandLevels) => {\n  const rowsWithBands = tableHeaderColumnChains\n    .filter(r => r.filter(ch => !!ch.bandTitle).length);\n\n  const visibleIntervals = columnIntervals.map(([start, end]) => ({ start, end }));\n\n  const isBandChainVisible = (chain: HeaderColumnChain) => (\n    visibleIntervals.some(interval => (\n      intervalUtil.intersect(\n        interval,\n        { start: chain.start, end: chain.start + chain.columns.length - 1 },\n      ) !== intervalUtil.empty\n    ),\n  ));\n\n  const getVisibleBandsByLevel = (level: number) => (\n    // Note: a visible band level always matches with it's row\n    rowsWithBands[level]\n    ? rowsWithBands[level].filter(chain => (\n        bandLevels[chain.bandTitle] === level && isBandChainVisible(chain)\n      ))\n    : []\n  );\n\n  return rowsWithBands.reduce((acc, _, index) => {\n    const rowBands = getVisibleBandsByLevel(index);\n    return [...acc, !!rowBands.length];\n  }, [] as boolean[]);\n};\n\nexport const columnVisibleIntervals: PureComputed<\n  [GridViewport, TableColumn[]],\n  VisibleBoundary[]\n> = (\n  viewport, tableColumns,\n) => (\n  viewport ? viewport.columns : [[0, tableColumns.length]]\n);\n","import { toggle } from '../../utils/common-reducers';\nimport { ToggleRowFieldReducer } from '../../types';\n\nexport const toggleDetailRowExpanded: ToggleRowFieldReducer = (\n  prevExpanded, { rowId, state },\n) => toggle(prevExpanded, [rowId], state);\n","export const TABLE_DETAIL_TYPE = Symbol('detail');\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_DETAIL_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { IsSpecificCellFn, IsSpecificRowFn, TableColumn, RowId } from '../../types';\n\nexport const isDetailRowExpanded: PureComputed<[RowId[], RowId], boolean> = (\n  expandedDetailRowIds, rowId,\n) => expandedDetailRowIds.indexOf(rowId) > -1;\n\nexport const isDetailToggleTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableColumn.type === TABLE_DETAIL_TYPE && tableRow.type === TABLE_DATA_TYPE;\n\nexport const isDetailTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_DETAIL_TYPE;\n\nexport const isDetailTableCell: PureComputed<[TableColumn, TableColumn[]], boolean> = (\n  tableColumn, tableColumns,\n) => tableColumns.indexOf(tableColumn) === 0;\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_DETAIL_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { TableRow, TableColumn, CellColSpanGetter } from '../../types';\n\nexport const tableRowsWithExpandedDetail: PureComputed<[TableRow[], number[], number]> = (\n  tableRows, expandedDetailRowIds, rowHeight,\n) => {\n  let result = tableRows;\n  expandedDetailRowIds\n    .forEach((expandedRowId) => {\n      const rowIndex = result.findIndex(\n        tableRow => tableRow.type === TABLE_DATA_TYPE && tableRow.rowId === expandedRowId,\n      );\n      if (rowIndex === -1) return;\n      const insertIndex = rowIndex + 1;\n      const { row, rowId } = result[rowIndex];\n      result = [\n        ...result.slice(0, insertIndex),\n        {\n          rowId,\n          row,\n          key: `${TABLE_DETAIL_TYPE.toString()}_${rowId}`,\n          type: TABLE_DETAIL_TYPE,\n          height: rowHeight,\n        },\n        ...result.slice(insertIndex),\n      ];\n    });\n  return result;\n};\n\nexport const tableColumnsWithDetail: PureComputed<[TableColumn[], number]> = (\n  tableColumns, toggleColumnWidth,\n) => [\n  { key: TABLE_DETAIL_TYPE.toString(), type: TABLE_DETAIL_TYPE, width: toggleColumnWidth },\n  ...tableColumns,\n];\n\nexport const tableDetailCellColSpanGetter: CellColSpanGetter = getTableCellColSpan => (params) => {\n  const { tableRow, tableColumns, tableColumn } = params;\n  if (tableRow.type === TABLE_DETAIL_TYPE && tableColumns.indexOf(tableColumn) === 0) {\n    return tableColumns.length;\n  }\n  return getTableCellColSpan(params);\n};\n","export const TABLE_SELECT_TYPE = Symbol('select');\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_SELECT_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { TABLE_HEADING_TYPE } from '../table-header-row/constants';\nimport { IsSpecificCellFn, TableRow } from '../../types';\n\nexport const isSelectTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_DATA_TYPE;\nexport const isSelectAllTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_HEADING_TYPE;\n\nexport const isRowHighlighted: PureComputed<[boolean, any[], TableRow, any[]?], boolean> = (\n  highlightRow, selection, tableRow, focused,\n) => {\n  const highlightion = selection ? selection.concat(focused || []) : focused;\n  return !!(highlightRow && highlightion && highlightion.includes(tableRow.rowId));\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_SELECT_TYPE } from './constants';\nimport { TableColumn } from '../../types';\n\nexport const tableColumnsWithSelection: PureComputed<[TableColumn[], number, boolean|undefined]> = (\n  tableColumns, selectionColumnWidth, showSelectionColumn,\n) => {\n  if (showSelectionColumn) {\n    return [\n      { key: TABLE_SELECT_TYPE.toString(), type: TABLE_SELECT_TYPE, width: selectionColumnWidth },\n      ...tableColumns,\n    ];\n  }\n  return tableColumns;\n};\n","import { TABLE_DATA_TYPE, TABLE_NODATA_TYPE } from './constants';\nimport {\n  IsSpecificCellFn, IsSpecificRowFn, TableRow, TableColumn, CheckColumnExtensionsFn,\n} from '../../types';\nimport { TABLE_STUB_TYPE } from '../../utils/virtual-table';\nimport { isValidValue } from '../table-column-resizing/helpers';\n\nconst VALID_UNITS = ['px', '%', 'em', 'rem', 'vm', 'vh', 'vmin', 'vmax', ''];\nconst TABLE_ERROR = 'The columnExtension property of the Table plugin is given an invalid value.';\n\nexport const isDataTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE;\nexport const isHeaderStubTableCell: IsSpecificCellFn<TableRow, TableRow[]> = (\n  tableRow, headerRows,\n) => headerRows.indexOf(tableRow) > -1;\nexport const isDataTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_DATA_TYPE;\nexport const isNoDataTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_NODATA_TYPE;\nexport const isNoDataTableCell: IsSpecificCellFn<TableColumn, TableColumn[]> = (\n  tableColumn, tableColumns,\n) => tableColumns.indexOf(tableColumn as any) === 0;\nexport const isStubTableCell: IsSpecificRowFn = tableRow => (\n  tableRow.type === TABLE_STUB_TYPE\n);\n\nexport const checkTableColumnExtensions: CheckColumnExtensionsFn = (columnExtensions) => {\n  if (columnExtensions) {\n    columnExtensions.map((column) => {\n      const { width } = column;\n      if (typeof width === 'string') {\n        if (!isValidValue(width, VALID_UNITS)) {\n          throw new Error(TABLE_ERROR);\n        }\n      }\n    });\n  }\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  GridColumnExtension, GetColumnExtensionValueGetterFn,\n} from '../types';\n\nexport const getColumnExtension: PureComputed<\n  [GridColumnExtension[] | undefined, string], GridColumnExtension\n> = (columnExtensions, columnName) => {\n  if (!columnExtensions) {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    return {} as GridColumnExtension;\n  }\n  const columnExtension = columnExtensions.find(extension => extension.columnName === columnName);\n  if (!columnExtension) {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    return {} as GridColumnExtension;\n  }\n  return columnExtension;\n};\n\nexport const getColumnExtensionValueGetter: GetColumnExtensionValueGetterFn = (\n  columnExtensions, extensionName, defaultValue,\n) => (columnName) => {\n  if (columnExtensions) {\n    const columnExtension = getColumnExtension(columnExtensions, columnName);\n    const extensionValue = columnExtension[extensionName];\n    return extensionValue !== undefined ? extensionValue : defaultValue;\n  }\n  return defaultValue;\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_DATA_TYPE, TABLE_NODATA_TYPE } from './constants';\nimport { getColumnExtension } from '../../utils/column-extension';\nimport { GridColumnExtension, GetCellColSpanFn } from './../../types/table.types';\nimport { Row, GetRowIdFn } from '../../types';\nimport { convertWidth } from '../table-column-resizing/helpers';\n\nexport const tableColumnsWithDataRows: PureComputed<[any[], GridColumnExtension[]]> = (\n  columns, columnExtensions,\n) => columns.map((column) => {\n  const { name } = column;\n  const columnExtension = getColumnExtension(columnExtensions as GridColumnExtension[], name);\n  const width = convertWidth(columnExtension.width!);\n  return {\n    column,\n    key: `${TABLE_DATA_TYPE.toString()}_${name}`,\n    type: TABLE_DATA_TYPE,\n    width,\n    align: columnExtension.align,\n    wordWrapEnabled: columnExtension.wordWrapEnabled,\n  };\n});\n\nexport const tableRowsWithDataRows: PureComputed<[Row[], GetRowIdFn, number]> = (\n  rows, getRowId, isRemoteRowsLoading,\n) => (\n  !rows.length && !isRemoteRowsLoading\n    ? [{ key: TABLE_NODATA_TYPE.toString(), type: TABLE_NODATA_TYPE }]\n    : rows.map((row, dataIndex) => {\n      const rowId = getRowId(row);\n      return {\n        row,\n        // dataIndex,\n        rowId,\n        type: TABLE_DATA_TYPE,\n        key: `${TABLE_DATA_TYPE.toString()}_${rowId}`,\n      };\n    }));\n\nexport const tableCellColSpanGetter: GetCellColSpanFn = (params) => {\n  const { tableRow, tableColumns, tableColumn } = params;\n  if (tableRow.type === TABLE_NODATA_TYPE && tableColumns.indexOf(tableColumn) === 0) {\n    return tableColumns.length;\n  }\n  return 1;\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { TableColumn } from '../../types';\n\nexport const visibleTableColumns: PureComputed<[TableColumn[], string[]]> = (\n  tableColumns = [], hiddenColumnNames,\n) => tableColumns.filter(tableColumn => tableColumn.type !== TABLE_DATA_TYPE\n    || hiddenColumnNames.indexOf(tableColumn.column!.name) === -1);\n","import { TABLE_DATA_TYPE } from '../table/constants';\nimport { TableColumn } from '../../types';\n\nexport const tableDataColumnsExist = (tableColumns: TableColumn[]) => tableColumns.some(\n  column => column.type === TABLE_DATA_TYPE,\n);\n","import { PureComputed } from '@devexpress/dx-core';\nimport { Column } from '../../types/grid-core.types';\nimport { ColumnChooserItem } from '../../types';\n\nexport const columnChooserItems: PureComputed<[Column[], string[]], ColumnChooserItem[]> = (\n  columns, hiddenColumnNames,\n) => columns.map(column => ({\n  column,\n  hidden: hiddenColumnNames.indexOf(column.name) !== -1,\n}));\n","import { PureReducer } from '@devexpress/dx-core';\n\nexport const toggleColumn: PureReducer<string[], string> = (\n  hiddenColumnNames, columnName,\n) => (\n  hiddenColumnNames.indexOf(columnName) === -1\n    ? [...hiddenColumnNames, columnName]\n    : hiddenColumnNames.filter(hiddenColumn => hiddenColumn !== columnName)\n);\n","import { toggle } from '../../utils/common-reducers';\nimport { ToggleRowFieldReducer } from '../../types';\n\nexport const toggleRowExpanded: ToggleRowFieldReducer = (\n  prevExpanded, { rowId, state },\n) => toggle(prevExpanded, [rowId], state);\n","export const GRID_TREE_NODE_TYPE = Symbol('treeNode');\n","import { PureComputed } from '@devexpress/dx-core';\nimport { GRID_TREE_NODE_TYPE } from './constants';\nimport {\n  RowsWithTreeMetaMap, RowsWithCollapsedRowsMetaMap, IsSpecificTreeRowGetter, GetRowIdFn,\n  GetRowLevelKeyFn, GetCollapsedRowsFn, CustomTreeRowsWithMetaComputed,\n  UnwrapRowsComputed, GetTreeRowLevelGetter, ExpandedTreeRowsFn, Row,\n} from '../../types';\n\nexport const customTreeRowsWithMeta: CustomTreeRowsWithMetaComputed = (\n  rows, getChildRows,\n) => {\n  const rowsToProcess = [{ row: null, level: -1 }] as Row[];\n  const treeRows = [] as { row: Row, level: number, leaf: boolean }[];\n\n  while (rowsToProcess?.length) {\n    const { row: currentRow, level } = rowsToProcess.shift()!;\n    const rowIndex = treeRows.findIndex(({ row }) => row === currentRow);\n    const nestedRows = getChildRows(currentRow, rows as Row[])?.map(\n      (childRow: Row) => ({\n        row: childRow,\n        level: level + 1,\n        leaf: !getChildRows(childRow, rows as Row[]),\n      }),\n    );\n\n    if (nestedRows) {\n      if (rowIndex > -1) {\n        treeRows.splice(rowIndex + 1, 0, ...nestedRows);\n      } else {\n        treeRows.push(...nestedRows);\n      }\n      rowsToProcess.push(...nestedRows);\n    }\n  }\n\n  const result = treeRows.reduce((acc, { row, level, leaf }) => {\n    acc.rows.push(row);\n    acc.treeMeta.push([row, { level, leaf }]);\n\n    return acc;\n  }, { rows: [] as Row[], treeMeta: [] as any[] });\n\n  return {\n    rows: result.rows,\n    treeMeta: new Map(result.treeMeta),\n  };\n};\n\nexport const customTreeRowIdGetter: PureComputed<[GetRowIdFn, RowsWithTreeMetaMap]> = (\n  getRowId, { rows, treeMeta },\n) => {\n  const firstNestedRowIndex = rows.findIndex(row => treeMeta.get(row)!.level > 0);\n  if (firstNestedRowIndex === -1 || getRowId(rows[firstNestedRowIndex]) !== undefined) {\n    return getRowId;\n  }\n  const map = new Map(rows\n    .map((row, rowIndex) => [row, rowIndex] as [any, any]));\n  return row => map.get(row);\n};\n\nexport const customTreeRowLevelKeyGetter: PureComputed<\n  [GetRowLevelKeyFn, RowsWithTreeMetaMap]\n> = (\n  getRowLevelKey, { treeMeta },\n) => (row) => {\n  const rowMeta = treeMeta.get(row);\n  if (rowMeta !== undefined) {\n    return `${GRID_TREE_NODE_TYPE.toString()}_${rowMeta.level}`;\n  }\n  return getRowLevelKey && getRowLevelKey();\n};\n\nexport const expandedTreeRows: ExpandedTreeRowsFn = (\n  { rows, treeMeta }, getRowId, expandedRowIds,\n) => {\n  const expandedRowIdsSet = new Set(expandedRowIds);\n\n  let currentExpanded = true;\n  let currentLevel = 0;\n\n  const collapsedRowsMeta = new Map();\n  const resultRows: object[] = [];\n\n  rows.forEach((row) => {\n    const rowMeta = treeMeta.get(row);\n    const level = rowMeta && rowMeta.level;\n    if (level === undefined && currentExpanded) {\n      resultRows.push(row);\n    } else if (!currentExpanded && (level === undefined || level > currentLevel)) {\n      const lastRow = resultRows[resultRows.length - 1];\n      let collapsedItems = collapsedRowsMeta.get(lastRow);\n      if (!collapsedItems) {\n        collapsedItems = [];\n        collapsedRowsMeta.set(lastRow, collapsedItems);\n      }\n      collapsedItems.push(row);\n    } else {\n      currentExpanded = expandedRowIdsSet.has(getRowId(row));\n      currentLevel = level!;\n\n      resultRows.push(row);\n    }\n  });\n\n  return {\n    treeMeta,\n    collapsedRowsMeta,\n    rows: resultRows,\n  };\n};\n\nexport const collapsedTreeRowsGetter: PureComputed<\n  [GetCollapsedRowsFn, RowsWithCollapsedRowsMetaMap]\n> = (\n  getCollapsedRows, { collapsedRowsMeta },\n) => row => collapsedRowsMeta.get(row) || (getCollapsedRows && getCollapsedRows(row));\n\nexport const isTreeRowLeafGetter: IsSpecificTreeRowGetter = ({ treeMeta }) => (row) => {\n  const rowMeta = treeMeta.get(row);\n  return rowMeta && rowMeta.leaf;\n};\n\nexport const getTreeRowLevelGetter: GetTreeRowLevelGetter = ({ treeMeta }) => (row) => {\n  const rowMeta = treeMeta.get(row);\n  return (rowMeta && rowMeta.level) as number;\n};\n\nexport const unwrappedCustomTreeRows: UnwrapRowsComputed = ({ rows }) => rows;\n","import { TABLE_DATA_TYPE } from '../table/constants';\nimport { IsSpecificCellFn, TableRow, TableColumn } from '../../types';\n\nexport const isTreeTableCell: IsSpecificCellFn<TableRow, TableColumn, string> = (\n  tableRow, tableColumn, forColumnName,\n) => tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE\n  && tableColumn.column!.name === forColumnName;\n","export const changeSearchValue = (\n  prevSearchValue: string, searchValue: string,\n) => searchValue;\n","import { SearchFilterExpressionFn, FilterExpression } from '../../types';\n\nexport const searchFilterExpression: SearchFilterExpressionFn = (\n  searchValue, columns, filterExpression,\n) => {\n  const filters = columns.map(({ name }) => ({ columnName: name, value: searchValue }));\n  const selfFilterExpression: FilterExpression = { filters, operator: 'or' };\n  if (!filterExpression) {\n    return selfFilterExpression;\n  }\n  return {\n    operator: 'and',\n    filters: [filterExpression as FilterExpression, selfFilterExpression],\n  };\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { GetAvailableFilterOperationsFn, FilterOperation } from '../../types';\n\nexport const getAvailableFilterOperationsGetter: PureComputed<\n  [GetAvailableFilterOperationsFn, FilterOperation[], string[]]\n> = (\n  getAvailableFilterOperations,\n  availableFilterOperations,\n  columnNames,\n) => columnName => (columnNames.indexOf(columnName) > -1 && availableFilterOperations)\n// tslint:disable-next-line: max-line-length\n    || (typeof getAvailableFilterOperations === 'function' && getAvailableFilterOperations(columnName))\n    || undefined;\n","export const FIXED_COLUMN_LEFT_SIDE = 'left';\nexport const FIXED_COLUMN_RIGHT_SIDE = 'right';\nexport const TABLE_FIXED_TYPE = Symbol('fixed');\n","import { slice } from '@devexpress/dx-core';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport {\n  FIXED_COLUMN_LEFT_SIDE, TABLE_FIXED_TYPE,\n} from './constants';\nimport { findChainByColumnIndex } from '../table-header-row/helpers';\nimport {\n  GetFixedColumnKeysFn, IsSpecificRowFn, CalculatePositionFn, CalculateFixedColumnPropsFn,\n} from '../../types';\n\nexport const getFixedColumnKeys: GetFixedColumnKeysFn = (tableColumns, fixedNames) => tableColumns\n  .filter(tableColumn => (\n    (tableColumn.type === TABLE_DATA_TYPE && fixedNames.indexOf(tableColumn.column!.name) !== -1)\n    || fixedNames.indexOf(tableColumn.type) !== -1\n  ))\n  .map(({ key }) => key);\n\nexport const isFixedTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_FIXED_TYPE;\n\nconst calculatePosition: CalculatePositionFn = (array, index, tableColumnDimensions) => (\n  index === 0\n    ? 0\n    : array\n      .slice(0, index)\n      .reduce((acc, target) => acc + tableColumnDimensions[target] || 0, 0)\n);\n\nexport const calculateFixedColumnProps: CalculateFixedColumnPropsFn = (\n  { tableColumn },\n  { leftColumns, rightColumns },\n  tableColumns,\n  tableColumnDimensions,\n  tableHeaderColumnChains,\n) => {\n  const side = tableColumn.fixed!;\n  const targetArray = side === FIXED_COLUMN_LEFT_SIDE\n    ? getFixedColumnKeys(tableColumns, leftColumns)\n    : slice(getFixedColumnKeys(tableColumns, rightColumns)).reverse();\n\n  const index = tableColumns.findIndex(({ key }) => key === tableColumn.key);\n  const fixedIndex = targetArray.indexOf(tableColumn.key);\n  const columnChain = findChainByColumnIndex(tableHeaderColumnChains[0], index)!;\n\n  const showLeftDivider = columnChain.start === index && index !== 0;\n  const showRightDivider = columnChain.start + columnChain.columns.length - 1 === index\n    && index < tableColumns.length - 1;\n\n  const position = calculatePosition(targetArray, fixedIndex, tableColumnDimensions);\n\n  return {\n    showRightDivider,\n    showLeftDivider,\n    position,\n    side,\n  };\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { FIXED_COLUMN_LEFT_SIDE, FIXED_COLUMN_RIGHT_SIDE, TABLE_FIXED_TYPE } from './constants';\nimport { splitHeaderColumnChains, generateSimpleChains } from '../table-header-row/helpers';\nimport {\n  FixedColumnName, TableColumn, FixedColumnSide, TableRow, HeaderColumnChainRows,\n  ShouldSplitChainFn,\n} from '../../types';\n\nexport const tableColumnsWithFixed: PureComputed<\n  [TableColumn[], FixedColumnName[], FixedColumnName[]]\n> = (\n  tableColumns, leftColumns, rightColumns,\n) => tableColumns\n  .map((tableColumn) => {\n    let fixed!: FixedColumnSide;\n    if ((tableColumn.type === TABLE_DATA_TYPE\n      && leftColumns.indexOf(tableColumn.column!.name) !== -1)\n      || leftColumns.indexOf(tableColumn.type) !== -1) {\n      fixed = FIXED_COLUMN_LEFT_SIDE;\n    }\n    if ((tableColumn.type === TABLE_DATA_TYPE\n      && rightColumns.indexOf(tableColumn.column!.name) !== -1)\n      || rightColumns.indexOf(tableColumn.type) !== -1) {\n      fixed = FIXED_COLUMN_RIGHT_SIDE;\n    }\n    return fixed ? { ...tableColumn, fixed } : tableColumn;\n  });\n\nexport const tableHeaderRowsWithFixed: PureComputed<[TableRow[]]> = tableHeaderRows => [\n  ...tableHeaderRows,\n  { key: TABLE_FIXED_TYPE.toString(), type: TABLE_FIXED_TYPE, height: 0 },\n];\n\nexport const tableHeaderColumnChainsWithFixed: PureComputed<\n  [HeaderColumnChainRows, TableRow[], TableColumn[]]\n> = (\n  tableHeaderColumnChains, tableHeaderRows, tableColumns,\n) => {\n  const chains = tableHeaderColumnChains\n    || generateSimpleChains(tableHeaderRows, tableColumns);\n\n  const shouldSplitChain: ShouldSplitChainFn = (currentGroup, column) => (\n    !currentGroup || (currentGroup as any).fixed !== column.fixed\n  );\n  const extendChainProps = (column: TableColumn) => ({\n    fixed: column.fixed,\n  });\n  return splitHeaderColumnChains(\n    chains,\n    tableColumns,\n    shouldSplitChain,\n    extendChainProps,\n  );\n};\n","import {\n  SummaryValue, SummaryCalculator,\n  DefaultSummaryCalculators,\n  Row,\n  TotalSummaryValuesFn,\n  GroupSummaryValuesFn,\n  TreeSummaryValuesFn,\n  RowsSummaryValuesFn,\n  ExpandRowsFn,\n  TableRow,\n  GroupLevel,\n} from '../../types';\n\nconst defaultSummaryCalculators: DefaultSummaryCalculators = {\n  count: rows => rows.length,\n  sum: (rows, getValue) => rows.reduce((acc, row) => acc + getValue(row), 0),\n  max: (rows, getValue) => (rows.length\n    ? rows.reduce((acc, row) => Math.max(acc, getValue(row)), -Infinity)\n    : null),\n  min: (rows, getValue) => (rows.length\n    ? rows.reduce((acc, row) => Math.min(acc, getValue(row)), Infinity)\n    : null),\n  avg: (rows, getValue) => (rows.length\n    ? rows.reduce((acc, row) => acc + getValue(row), 0) / rows.length\n    : null),\n};\n\nexport const defaultSummaryCalculator: SummaryCalculator = (type, rows, getValue) => {\n  const summaryCalculator = defaultSummaryCalculators[type];\n  if (!summaryCalculator) {\n    throw new Error(`The summary type '${type}' is not defined`);\n  }\n  return summaryCalculator(rows, getValue);\n};\n\nconst rowsSummary: RowsSummaryValuesFn = (\n  rows, summaryItems, getCellValue, calculator,\n) => summaryItems\n  .reduce((acc, { type, columnName }) => {\n    const getValue = (row: Row) => getCellValue(row, columnName);\n    acc.push(calculator(type, rows as any[], getValue));\n    return acc;\n  }, [] as SummaryValue[]);\n\nconst expandRows: ExpandRowsFn = (\n  rows, getRowLevelKey, getCollapsedRows, isGroupRow, includeGroupRow = false,\n) => {\n  const shouldIncludeRow = includeGroupRow || !isGroupRow\n    ? () => true\n    : (row: TableRow) => !isGroupRow(row);\n\n  return rows\n    .reduce((acc, row) => {\n      if (getRowLevelKey && getRowLevelKey(row)) {\n        if (shouldIncludeRow(row)) {\n          acc.push(row);\n        }\n        const collapsedRows = getCollapsedRows && getCollapsedRows(row);\n        if (collapsedRows) {\n          acc.push(...collapsedRows);\n        }\n        return acc;\n      }\n      acc.push(row);\n      return acc;\n    }, [] as TableRow[]);\n};\n\nexport const totalSummaryValues: TotalSummaryValuesFn = (\n  rows,\n  summaryItems,\n  getCellValue,\n  getRowLevelKey,\n  isGroupRow,\n  getCollapsedRows,\n  calculator = defaultSummaryCalculator,\n) => {\n  const plainRows = expandRows(rows, getRowLevelKey, getCollapsedRows, isGroupRow);\n  return rowsSummary(plainRows, summaryItems, getCellValue, calculator);\n};\n\nexport const groupSummaryValues: GroupSummaryValuesFn = (\n  rows,\n  summaryItems,\n  getCellValue,\n  getRowLevelKey,\n  isGroupRow,\n  getCollapsedRows,\n  calculator = defaultSummaryCalculator,\n) => {\n  let levels: GroupLevel[] = [];\n  const getLevelIndex = (levelKey: string) => (\n    levels.findIndex(level => level.levelKey === levelKey)\n  );\n  const summaries = {};\n\n  const anyRowLevelSummaryExist = summaryItems.some(item => (\n    !(item as any).showInGroupFooter\n  ));\n  const expandedRows = anyRowLevelSummaryExist\n    ? expandRows(rows, getRowLevelKey, getCollapsedRows, isGroupRow, true)\n    : rows;\n\n  expandedRows.forEach((row) => {\n    const levelKey = getRowLevelKey(row);\n    const collapsedRows = getCollapsedRows && getCollapsedRows(row);\n    let levelIndex = getLevelIndex(levelKey);\n    if (levelIndex > -1) {\n      levels.forEach((level) => {\n        summaries[level.row.compoundKey] = rowsSummary(\n          level.rows, summaryItems, getCellValue, calculator,\n        );\n      });\n      levels = levels.slice(0, levelIndex);\n    }\n    if (isGroupRow!(row)) {\n      levels.push({\n        levelKey,\n        row,\n        rows: [],\n      });\n      levelIndex = getLevelIndex(levelKey);\n    }\n    // when row level summary exists, these rows had already been expanded earlier\n    const isCollapsedNestedGroupRow = collapsedRows && levelIndex > 0 && !anyRowLevelSummaryExist;\n    const rowsToAppend = !levelKey ? [row] : collapsedRows;\n    if (!levelKey || isCollapsedNestedGroupRow) {\n      levels.forEach((level) => {\n        level.rows.push(...rowsToAppend);\n      });\n    }\n  }, {});\n  levels.forEach((level) => {\n    summaries[level.row.compoundKey] = rowsSummary(\n      level.rows, summaryItems, getCellValue, calculator,\n    );\n  });\n  return summaries;\n};\n\nexport const treeSummaryValues: TreeSummaryValuesFn = (\n  rows,\n  summaryItems,\n  getCellValue,\n  getRowLevelKey,\n  isGroupRow,\n  getRowId,\n  calculator = defaultSummaryCalculator,\n) => {\n  let levels: any[] = [];\n  const summaries = {};\n  rows.forEach((row) => {\n    const levelKey = getRowLevelKey(row);\n    if (!levelKey) {\n      levels[levels.length - 1].rows.push(row);\n      return;\n    }\n    const levelIndex = levels.findIndex(level => level.levelKey === levelKey);\n    if (levelIndex > -1) {\n      levels.slice(levelIndex).forEach((level) => {\n        if (level.rows.length) {\n          summaries[getRowId(level.row)] = rowsSummary(\n            level.rows, summaryItems, getCellValue, calculator,\n          );\n        }\n      });\n      levels = levels.slice(0, levelIndex);\n    }\n    if (!isGroupRow || !isGroupRow(row)) {\n      if (levels.length) {\n        levels[levels.length - 1].rows.push(row);\n      }\n      levels.push({\n        levelKey,\n        row,\n        rows: [],\n      });\n    }\n  }, {});\n  levels.forEach((level) => {\n    if (level.rows.length) {\n      summaries[getRowId(level.row)] = rowsSummary(\n        level.rows, summaryItems, getCellValue, calculator,\n      );\n    }\n  });\n  return summaries;\n};\n","export const TABLE_TOTAL_SUMMARY_TYPE = Symbol('totalSummary');\nexport const TABLE_GROUP_SUMMARY_TYPE = Symbol('groupSummary');\nexport const TABLE_TREE_SUMMARY_TYPE = Symbol('treeSummary');\n\nexport const defaultFormatlessSummaries = ['count'];\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  TABLE_TOTAL_SUMMARY_TYPE, TABLE_GROUP_SUMMARY_TYPE, TABLE_TREE_SUMMARY_TYPE,\n} from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport {\n  GetColumnSummariesFn, IsSpecificCellFn, IsSpecificRowFn, SummaryItem,\n  GetGroupInlineSummariesFn, ColumnInlineSummaries, GroupSummaryItem,\n} from '../../types';\n\nexport const isTotalSummaryTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_TOTAL_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;\nexport const isGroupSummaryTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_GROUP_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;\nexport const isTreeSummaryTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_TREE_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;\nexport const isTotalSummaryTableRow: IsSpecificRowFn = tableRow => (\n  tableRow.type === TABLE_TOTAL_SUMMARY_TYPE\n);\nexport const isGroupSummaryTableRow: IsSpecificRowFn = tableRow => (\n  tableRow.type === TABLE_GROUP_SUMMARY_TYPE\n);\nexport const isTreeSummaryTableRow: IsSpecificRowFn = tableRow => (\n  tableRow.type === TABLE_TREE_SUMMARY_TYPE\n);\n\nexport const getColumnSummaries: GetColumnSummariesFn = (\n  summaryItems, columnName, summaryValues, predicate = () => true,\n) => summaryItems\n  .map((item, index) => [item, index] as [SummaryItem, number])\n  .filter(([item]) => item.columnName === columnName && predicate(item))\n  .map(([item, index]) => ({\n    type: item.type,\n    value: summaryValues[index],\n  }));\n\nexport const isFooterSummary: PureComputed<[SummaryItem], boolean> = summaryItem => (\n  (summaryItem as GroupSummaryItem).showInGroupFooter!\n);\nexport const isInlineGroupCaptionSummary: PureComputed<[SummaryItem], boolean> = summaryItem => (\n  !((summaryItem as GroupSummaryItem).showInGroupFooter ||\n  (summaryItem as GroupSummaryItem).alignByColumn)\n);\nexport const groupFooterSummaryExists: PureComputed<[GroupSummaryItem[]], boolean> =\n  groupSummaryItems => groupSummaryItems?.some(isFooterSummary);\n\nexport const getGroupInlineSummaries: GetGroupInlineSummariesFn = (\n  summaryItems, columns, summaryValues,\n) => {\n  if (!summaryItems.some(isInlineGroupCaptionSummary)) {\n    return [];\n  }\n\n  return columns.reduce((acc, column) => {\n    const colName = column.name;\n    const summaries = getColumnSummaries(\n      summaryItems, colName, summaryValues, isInlineGroupCaptionSummary,\n    );\n    if (summaries.length) {\n      acc.push({\n        column,\n        summaries,\n      });\n    }\n\n    return acc;\n  }, [] as ColumnInlineSummaries[]);\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  TABLE_TOTAL_SUMMARY_TYPE,\n  TABLE_GROUP_SUMMARY_TYPE,\n  TABLE_TREE_SUMMARY_TYPE,\n} from './constants';\nimport {\n  TableRow, RowLevel, TableRowsWithSummariesFn,\n} from '../../types';\nimport { groupFooterSummaryExists } from './helpers';\n\nexport const tableRowsWithTotalSummaries: PureComputed<[TableRow[]]> = footerRows => [\n  { key: TABLE_TOTAL_SUMMARY_TYPE.toString(), type: TABLE_TOTAL_SUMMARY_TYPE },\n  ...footerRows,\n];\n\nexport const tableRowsWithSummaries: TableRowsWithSummariesFn = (\n  tableRows, groupSummaryItems, treeSummaryItems, getRowLevelKey, isGroupRow, getRowId,\n) => {\n  const hasGroupFooterSummary = groupFooterSummaryExists(groupSummaryItems);\n  if (!getRowLevelKey || !(hasGroupFooterSummary || treeSummaryItems.length)) return tableRows;\n\n  const result: TableRow[] = [];\n  const closeLevel = (level: RowLevel) => {\n    if (!level.opened) return;\n    if (hasGroupFooterSummary && isGroupRow && isGroupRow(level.row)) {\n      const { compoundKey } = level.row;\n      result.push({\n        key: `${TABLE_GROUP_SUMMARY_TYPE.toString()}_${compoundKey}`,\n        type: TABLE_GROUP_SUMMARY_TYPE,\n        row: level.row,\n      });\n    } else if (treeSummaryItems.length) {\n      const rowId = getRowId(level.row);\n      result.push({\n        key: `${TABLE_TREE_SUMMARY_TYPE.toString()}_${rowId}`,\n        type: TABLE_TREE_SUMMARY_TYPE,\n        row: level.row,\n      });\n    }\n  };\n\n  let levels: RowLevel[] = [];\n  tableRows.forEach((tableRow) => {\n    const { row } = tableRow;\n    const levelKey = getRowLevelKey(row);\n    if (levelKey) {\n      const levelIndex = levels.findIndex(level => level.levelKey === levelKey);\n      if (levelIndex > -1) {\n        levels.slice(levelIndex).reverse().forEach(closeLevel);\n        levels = levels.slice(0, levelIndex);\n      }\n      if (!isGroupRow || !isGroupRow(row)) {\n        levels = levels.map(level => ({\n          ...level,\n          opened: true,\n        }));\n      }\n      levels.push({\n        levelKey,\n        row,\n        opened: false,\n      });\n    } else {\n      levels = levels.map(level => ({\n        ...level,\n        opened: true,\n      }));\n    }\n    result.push(tableRow);\n  });\n  levels.slice().reverse().forEach(closeLevel);\n\n  return result;\n};\n","import { GroupSummaryItem } from '../../types';\n\nexport const prepareGroupSummaryItems = (items: GroupSummaryItem[]) => (\n  !!items\n    ? items.map(item => ({\n      ...item,\n      showInGroupFooter: (\n        item.showInGroupFooter === undefined && !item.alignByColumn\n      )\n        ? true\n        : item.showInGroupFooter,\n    }))\n    : items\n);\n","import { ReadonlyObject, PureComputed } from '@devexpress/dx-core';\nimport {\n  TABLE_FILTER_TYPE, TABLE_HEADING_TYPE, TABLE_DATA_TYPE, TABLE_BAND_TYPE,\n  TABLE_TOTAL_SUMMARY_TYPE, TABLE_STUB_TYPE,\n  TABLE_GROUP_TYPE,\n} from '@devexpress/dx-grid-core';\nimport {\n    GetNextFocusedElementFn, FocusedElement, TableColumn, TableRow,\n    GetElementFn, GetElementPrevNextPartFn, Elements, RowId, GetInnerElementsFn,\n    OnFocusedCellChangeFn, ScrollToColumnFn, GetNextPrevPartFn,\n    GetNextPrevCellFromBodyFn, GetPrevCellFromHeadingFn, GetNextCellFromHeadingFn,\n    GetCellNextPrevPartFn, FocusedElementWScrolling, InlineEditing,\n} from '../../types';\n\nconst HEADING_TYPE = TABLE_HEADING_TYPE.toString();\nconst FILTER_TYPE = TABLE_FILTER_TYPE.toString();\nconst DATA_TYPE = TABLE_DATA_TYPE.toString();\nconst BAND_TYPE = TABLE_BAND_TYPE.toString();\nconst TOTAL_SUMMARY_TYPE = TABLE_TOTAL_SUMMARY_TYPE.toString();\nconst STUB_TYPE = TABLE_STUB_TYPE.toString();\nconst GROUP_TYPE = TABLE_GROUP_TYPE.toString();\n\nconst tableParts = [HEADING_TYPE, FILTER_TYPE, DATA_TYPE, TOTAL_SUMMARY_TYPE];\n\nconst getIndex: PureComputed<[TableColumn[] | TableRow [], string], number> = (arr, key) => {\n  return arr.findIndex((el: TableColumn | TableRow) => {\n    return el.key === key;\n  });\n};\n\nconst isSpanInput: PureComputed<[any[]], boolean> = (innerElements) => {\n  return innerElements[0].tagName === 'SPAN' ||\n  innerElements[0].tagName === 'INPUT' && innerElements[0].type === 'text';\n};\n\nconst isDefined = (value: any): value is boolean => {\n  return value !== undefined;\n};\n\nconst hasInsideElements: PureComputed<[any[], number?], boolean> = (\n  innerElements, focusedElementIndex,\n) => {\n  if ((innerElements.length && focusedElementIndex === undefined) ||\n  (isDefined(focusedElementIndex) && focusedElementIndex < innerElements.length - 1)) {\n    if (innerElements.length === 1 && focusedElementIndex === undefined) {\n      return !isSpanInput(innerElements);\n    }\n    return true;\n  }\n  return false;\n};\n\nconst getIndexInnerElement: PureComputed<[\n  Elements, string, string, number,\n], number | undefined> = (\n  elements, rowKey, columnKey, direction,\n) => {\n  const innerElements = getInnerElements(elements, rowKey, columnKey);\n  const index = direction > 0 ? 0 : innerElements.length - 1;\n\n  return cellEmptyOrHasSpanAndInput(elements, rowKey, columnKey) ? undefined : index;\n};\n\nconst getNextPrevClosestColumnKey: PureComputed<\n  [TableColumn[], number, string, Elements, number], string | undefined\n> = (tableColumns, columnIndex, rowKey, elements, direction) => {\n  let columnKey;\n  if (direction > 0) {\n    for (let i = columnIndex; i <= tableColumns.length - 1; i += 1) {\n      if (elements[rowKey][tableColumns[i].key]) {\n        columnKey = tableColumns[i].key;\n        break;\n      }\n    }\n  } else {\n    for (let i = columnIndex; i >= 0; i -= 1) {\n      if (elements[rowKey][tableColumns[i].key]) {\n        columnKey = tableColumns[i].key;\n        break;\n      }\n    }\n  }\n  return columnKey;\n};\n\nconst shouldBeScrolled = (\n  elements: ReadonlyObject<Elements>, key1: string, key2: string,\n  scrollToColumn?: ScrollToColumnFn,\n): scrollToColumn is ScrollToColumnFn => {\n  if (scrollToColumn && !elements[key1][key2]) {\n    return Object.keys(elements[key1]).some((column) => {\n      return column.includes(STUB_TYPE);\n    });\n  }\n  return false;\n};\n\nconst convertPart: PureComputed<\n  [string, Elements, TableRow[]], string | void\n> = (part, elements, tableBodyRows) => {\n  if (part === DATA_TYPE && elements[tableBodyRows[0].key]) {\n    return DATA_TYPE;\n  }\n  if (elements[part]) {\n    return part;\n  }\n  return;\n};\n\nconst getLastPart: PureComputed<\n  [Elements, TableRow[], number?], string | void\n> = (elements, tableBodyRows, partIndex) => {\n  let index = partIndex || tableParts.length;\n  let part;\n\n  do {\n    index = index - 1;\n    part = convertPart(tableParts[index], elements, tableBodyRows);\n  } while (index > 0 && !part);\n\n  return part;\n};\n\nconst getRowKey: PureComputed<[string, string, string?]> = (part, key, headerRowKey) => {\n  if (headerRowKey && part === HEADING_TYPE) {\n    return headerRowKey;\n  }\n  return part === DATA_TYPE ? key : part;\n};\n\nconst getPrevPart: GetNextPrevPartFn = (\n  focusedElement, elements, tableBodyRows,\n) => {\n  const index = tableParts.findIndex((p) => {\n    return p === focusedElement.part;\n  });\n  if (index === 0) {\n    return;\n  }\n  return getLastPart(elements, tableBodyRows, index);\n};\n\nconst getNextPart: GetNextPrevPartFn = (\n  focusedElement, elements, tableBodyRows,\n) => {\n  const index = tableParts.findIndex((p) => {\n    return p === focusedElement.part;\n  });\n  if (index === tableParts.length - 1) {\n    return;\n  }\n  const part = tableParts.find((p, i) => {\n    if (i > index) {\n      return convertPart(p, elements, tableBodyRows);\n    }\n    return false;\n  });\n  return part;\n};\n\nconst getCellNextPart: GetElementPrevNextPartFn = (\n  focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn,\n) => {\n  const part = getNextPart(focusedElement, elements, tableBodyRows);\n  if (!part) {\n    return {};\n  }\n\n  const rowKey = getRowKey(part, tableBodyRows[0].key);\n  const columnKey = tableColumns[0].key;\n  if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {\n    return {\n      element: {\n        rowKey,\n        columnKey,\n        part,\n      },\n      scrolling: 'left',\n    };\n  }\n  return {\n    element: {\n      rowKey,\n      columnKey,\n      index: getIndexInnerElement(elements, rowKey, columnKey, 1),\n      part,\n    },\n  };\n};\n\nconst getCellPrevPart: GetElementPrevNextPartFn = (\n  focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn,\n) => {\n  const part = getPrevPart(focusedElement, elements, tableBodyRows);\n  if (!part) {\n    return {};\n  }\n\n  const rowKey = getRowKey(part, tableBodyRows[tableBodyRows.length - 1].key);\n  const columnKeyIndex = tableColumns.length - 1;\n  const columnKey = tableColumns[columnKeyIndex].key;\n  if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {\n    return {\n      element: {\n        rowKey,\n        columnKey,\n        part,\n      },\n      scrolling: 'right',\n    };\n  }\n  const nextColumnKey = getNextPrevClosestColumnKey(tableColumns, columnKeyIndex,\n    rowKey, elements, -1);\n  return {\n    element: nextColumnKey ? {\n      rowKey,\n      columnKey: nextColumnKey,\n      index: getIndexInnerElement(elements, rowKey, nextColumnKey, -1),\n      part,\n    } : undefined,\n  };\n};\n\nconst getPrevCellFromBody: GetNextPrevCellFromBodyFn = (\n  columnIndex, rowIndex, tableColumns, tableBodyRows, focusedElement, elements,\n  scrollToColumn,\n) => {\n  let prevRowKey = focusedElement.rowKey;\n  let prevColumnKey;\n  if (columnIndex === 0 && rowIndex === 0) {\n    return getCellPrevPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n  }\n  if (columnIndex === 0) {\n    prevRowKey = tableBodyRows[rowIndex - 1].key;\n    if (prevRowKey.includes(GROUP_TYPE)) {\n      prevColumnKey = getNextPrevClosestColumnKey(\n        tableColumns, tableColumns.length - 1, prevRowKey, elements, -1,\n      );\n    } else {\n      prevColumnKey = tableColumns[tableColumns.length - 1].key;\n    }\n    if (prevColumnKey && shouldBeScrolled(elements, prevRowKey, prevColumnKey, scrollToColumn)) {\n      return {\n        element: {\n          rowKey: prevRowKey,\n          columnKey: prevColumnKey,\n          part: focusedElement.part,\n        },\n        scrolling: 'right',\n      };\n    }\n  } else {\n    prevColumnKey = getNextPrevClosestColumnKey(\n      tableColumns, columnIndex - 1, prevRowKey, elements, -1,\n    );\n  }\n\n  return {\n    element: prevColumnKey ? {\n      rowKey: prevRowKey,\n      columnKey: prevColumnKey,\n      index: getIndexInnerElement(elements, prevRowKey, prevColumnKey, -1),\n      part: focusedElement.part,\n    } : undefined,\n  };\n};\n\nconst getPrevCellFromHeading: GetPrevCellFromHeadingFn = (\n  tableHeaderRows, tableColumns, columnIndex,\n  { rowKey, part }, elements,\n) => {\n  let prevColumnKey;\n  let prevRowKey;\n  const headIndex = getIndex(tableHeaderRows, rowKey);\n  prevColumnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex - 1, rowKey, elements, -1);\n  if (prevColumnKey) {\n    return {\n      element: {\n        columnKey: prevColumnKey,\n        rowKey,\n        part,\n        index: getIndexInnerElement(elements, rowKey, prevColumnKey, -1),\n      },\n    };\n  }\n  if (headIndex > 0) {\n    let abort = false;\n    for (let i = headIndex - 1; i >= 0 && !abort; i -= 1) {\n      for (let j = tableColumns.length - 1; j >= 0; j -= 1) {\n        if (elements[tableHeaderRows[i].key][tableColumns[j].key]) {\n          prevColumnKey = tableColumns[j].key;\n          prevRowKey = tableHeaderRows[i].key;\n          abort = true;\n          break;\n        }\n      }\n    }\n    if (prevColumnKey && prevRowKey) {\n      return {\n        element: {\n          columnKey: prevColumnKey,\n          rowKey: prevRowKey,\n          part,\n          index: getIndexInnerElement(elements, prevRowKey, prevColumnKey, -1),\n        },\n      };\n    }\n  }\n\n  return {};\n};\n\nconst getPrevElement: GetElementFn = (\n  focusedElement, tableBodyRows, tableColumns, tableHeaderRows, elements, scrollToColumn,\n) => {\n  const columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  const rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);\n\n  if (isDefined(focusedElement.index) && focusedElement.index > 0) {\n    return { element: { ...focusedElement, index: focusedElement.index - 1 } };\n  }\n\n  if (focusedElement.part === DATA_TYPE) {\n    return getPrevCellFromBody(columnIndex, rowIndex, tableColumns,\n      tableBodyRows, focusedElement, elements, scrollToColumn);\n  }\n\n  if (focusedElement.part === HEADING_TYPE) {\n    const cell = getPrevCellFromHeading(tableHeaderRows, tableColumns, columnIndex,\n      focusedElement, elements);\n    if (cell.element) {\n      return {\n        element: {\n          ...cell.element,\n          index: getIndexInnerElement(elements, cell.element.rowKey, cell.element.columnKey, -1),\n        },\n      };\n    }\n    return { element: cell.element };\n  }\n\n  if (columnIndex === 0) {\n    return getCellPrevPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n  }\n  const rowKey = focusedElement.part;\n  const columnKey = tableColumns[columnIndex - 1].key;\n  return {\n    element: {\n      rowKey,\n      columnKey,\n      index: getIndexInnerElement(elements, rowKey, columnKey, -1),\n      part: focusedElement.part,\n    },\n  };\n};\n\nconst getNextCellFromBody: GetNextPrevCellFromBodyFn = (\n  columnIndex, rowIndex, tableColumns,\n  tableBodyRows, focusedElement, elements, scrollToColumn,\n) => {\n  let nextRowKey = focusedElement.rowKey;\n  let nextColumnKey;\n\n  if (columnIndex === tableColumns.length - 1 && rowIndex === tableBodyRows.length - 1) {\n    return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n  }\n  if (columnIndex === tableColumns.length - 1) {\n    nextRowKey = tableBodyRows[rowIndex + 1].key;\n    nextColumnKey = tableColumns[0].key;\n    if (shouldBeScrolled(elements, nextRowKey, nextColumnKey, scrollToColumn)) {\n      return {\n        element: {\n          rowKey: nextRowKey,\n          columnKey: nextColumnKey,\n          part: focusedElement.part,\n        },\n        scrolling: 'left',\n      };\n    }\n  } else {\n    nextColumnKey = getNextPrevClosestColumnKey(\n      tableColumns, columnIndex + 1, nextRowKey, elements, 1,\n    );\n    if (!nextColumnKey) {\n      if (rowIndex === tableBodyRows.length - 1) {\n        return getCellNextPart(\n          focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn,\n        );\n      }\n      nextRowKey = tableBodyRows[rowIndex + 1].key;\n      nextColumnKey = tableColumns[0].key;\n    }\n  }\n\n  return {\n    element: {\n      rowKey: nextRowKey,\n      columnKey: nextColumnKey,\n      index: getIndexInnerElement(elements, nextRowKey, nextColumnKey, 1),\n      part: focusedElement.part,\n    },\n  };\n};\n\nconst getNextCellFromHeading: GetNextCellFromHeadingFn = (\n  tableHeaderRows, tableBodyRows, tableColumns,\n  columnIndex, focusedElement, elements,\n  scrollToColumn,\n) => {\n  const headIndex = getIndex(tableHeaderRows, focusedElement.rowKey);\n  let nextRowKey;\n  let nextColumnKey = getNextPrevClosestColumnKey(\n    tableColumns, columnIndex + 1, focusedElement.rowKey, elements, 1,\n  );\n  if (nextColumnKey) {\n    return {\n      element: {\n        columnKey: nextColumnKey,\n        rowKey: focusedElement.rowKey,\n        part: focusedElement.part,\n        index: getIndexInnerElement(elements, focusedElement.rowKey, nextColumnKey, 1),\n      },\n    };\n  }\n  if (headIndex !== tableHeaderRows.length - 1) {\n    let abort = false;\n    for (let i = headIndex + 1; i <= tableHeaderRows.length - 1 && !abort; i += 1) {\n      for (let j = 0; j <= tableColumns.length - 1; j += 1) {\n        if (elements[tableHeaderRows[i].key][tableColumns[j].key]) {\n          nextColumnKey = tableColumns[j].key;\n          nextRowKey = tableHeaderRows[i].key;\n          abort = true;\n          break;\n        }\n      }\n    }\n    if (nextColumnKey && nextRowKey) {\n      return {\n        element: {\n          columnKey: nextColumnKey,\n          rowKey: nextRowKey,\n          part: focusedElement.part,\n          index: getIndexInnerElement(elements, nextRowKey, nextColumnKey, 1),\n        },\n      };\n    }\n  }\n\n  return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n};\n\nconst getNextElement: GetElementFn = (\n  focusedElement, tableBodyRows, tableColumns, tableHeaderRows, elements, scrollToColumn,\n) => {\n  const innerElements = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey);\n  const columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  const rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);\n\n  if (hasInsideElements(innerElements, focusedElement.index)) {\n    return {\n      element: {\n        ...focusedElement,\n        index: !isDefined(focusedElement.index) ? 0 : focusedElement.index + 1,\n      },\n    };\n  }\n\n  if (focusedElement.part === DATA_TYPE) {\n    return getNextCellFromBody(columnIndex, rowIndex, tableColumns,\n      tableBodyRows, focusedElement, elements, scrollToColumn);\n  }\n\n  if (focusedElement.part === HEADING_TYPE) {\n    return getNextCellFromHeading(tableHeaderRows, tableBodyRows, tableColumns, columnIndex,\n      focusedElement, elements, scrollToColumn);\n  }\n\n  if (columnIndex === tableColumns.length - 1) {\n    return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);\n  }\n\n  const rowKey = focusedElement.rowKey;\n  const columnKey = tableColumns[columnIndex + 1].key;\n  return {\n    element: {\n      rowKey,\n      columnKey,\n      part: focusedElement.part,\n      index: getIndexInnerElement(elements, rowKey, columnKey, 1),\n    },\n  };\n};\n\nconst hasCellInput: PureComputed<[any], boolean> = (innerElements) => {\n  return innerElements.length ? innerElements[0].tagName === 'INPUT' : false;\n};\n\nconst cellEmptyOrHasSpanAndInput: PureComputed<[\n  Elements, string, string\n], boolean> = (elements, key1, key2) => {\n  const innerElements = getInnerElements(elements, key1, key2);\n  if (innerElements.length) {\n    return isSpanInput(innerElements);\n  }\n  return true;\n};\n\nconst getCellRightLeft: PureComputed<[number, FocusedElement, TableColumn[], Elements],\nFocusedElement | undefined> = (\n  direction, focusedElement, tableColumns, elements,\n) => {\n  if (focusedElement.part !== DATA_TYPE) {\n    return;\n  }\n  const columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  if (tableColumns[columnIndex + direction]) {\n    const columnKey = getNextPrevClosestColumnKey(\n      tableColumns, columnIndex + direction, focusedElement.rowKey, elements, direction,\n    );\n    if (columnKey) {\n      return {\n        rowKey: focusedElement.rowKey,\n        columnKey,\n        part: focusedElement.part,\n      };\n    }\n  }\n  return;\n};\n\nconst getFirstCell: PureComputed<\n  [Elements, TableRow[], TableColumn[], TableRow[], ScrollToColumnFn?, boolean?],\n  FocusedElementWScrolling\n> = (\n  elements, tableBodyRows, tableColumns, tableHeaderRows, scrollToColumn, withInnerElements,\n) => {\n  const part = tableParts.find((p) => {\n    return convertPart(p, elements, tableBodyRows);\n  });\n  if (!part) {\n    return {};\n  }\n  const rowKey = getRowKey(part, tableBodyRows[0].key, tableHeaderRows[0].key);\n  const columnKey = tableColumns[0].key;\n  if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {\n    return {\n      element: {\n        rowKey,\n        columnKey,\n        part,\n      },\n      scrolling: 'left',\n    };\n  }\n\n  return {\n    element: {\n      rowKey,\n      columnKey,\n      index: withInnerElements ? getIndexInnerElement(elements, rowKey, columnKey, 1) : undefined,\n      part,\n    },\n  };\n};\n\nconst getLastCell: PureComputed<[Elements, TableRow[], TableColumn[]], FocusedElementWScrolling> = (\n  elements, tableBodyRows, tableColumns,\n) => {\n  const part = getLastPart(elements, tableBodyRows);\n  if (!part) {\n    return {};\n  }\n\n  const rowKey = getRowKey(part, tableBodyRows[tableBodyRows.length - 1].key);\n  const columnKey = getNextPrevClosestColumnKey(\n    tableColumns, tableColumns.length - 1, rowKey, elements, -1,\n  );\n\n  return {\n    element: columnKey ? {\n      rowKey,\n      columnKey,\n      index: getIndexInnerElement(elements, rowKey, columnKey, 1),\n      part,\n    } : undefined,\n  };\n};\n\nconst getToolbarPagingElements: PureComputed<[Elements]> = (elements) => {\n  return {\n    toolbarElements: elements.toolbar && getInnerElements(elements, 'toolbar', 'none'),\n    pagingElements: elements.paging && getInnerElements(elements, 'paging', 'none')\n    .filter((el: any) => {\n      return !el.hasAttribute('disabled') && el.getAttribute('tabindex') !== '-1';\n    }),\n  };\n};\n\nconst getFirstCellInLastPart: PureComputed<[\n  Elements, TableRow[], TableColumn[], ScrollToColumnFn?, boolean?\n], FocusedElementWScrolling> = (\n  elements, tableBodyRows, tableColumns, scrollToColumn, withInnerElements,\n) => {\n  const lastPart = getLastPart(elements, tableBodyRows);\n  if (lastPart) {\n    const columnKey = tableColumns[0].key;\n    const rowKey = getRowKey(lastPart, tableBodyRows[0].key);\n    if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {\n      return {\n        element: {\n          rowKey,\n          columnKey,\n          part: lastPart,\n        },\n        scrolling: 'left',\n      };\n    }\n    return {\n      element: {\n        columnKey,\n        rowKey,\n        index: withInnerElements ? getIndexInnerElement(elements, rowKey, columnKey, 1) : undefined,\n        part: lastPart,\n      },\n    };\n  }\n  return {};\n};\n\nconst applyEnterAction: PureComputed<[\n  Elements, InlineEditing, TableColumn[], TableRow[], FocusedElement?\n], FocusedElement | undefined> = (\n  elements, { commitChangedRows, stopEditCells, startEditCells },\n  tableColumns, tableBodyRows, focusedElement,\n) => {\n  if (!focusedElement) {\n    return;\n  }\n  const innerElements = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey);\n  const columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  const rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);\n\n  if (focusedElement.part === DATA_TYPE && commitChangedRows) {\n    if (focusedElement.index === 0) {\n      commitChangedRows({ rowIds: [tableBodyRows[rowIndex].rowId] });\n      stopEditCells!({\n        editingCells: [{\n          rowId: tableBodyRows[rowIndex].rowId,\n          columnName: tableColumns[columnIndex].column!.name,\n        }],\n      });\n      return {\n        part: focusedElement.part,\n        columnKey: focusedElement.columnKey,\n        rowKey: focusedElement.rowKey,\n      };\n    }\n    startEditCells!({\n      editingCells: [{\n        rowId: tableBodyRows[rowIndex].rowId,\n        columnName: tableColumns[columnIndex].column!.name,\n      }],\n    });\n    return {\n      part: focusedElement.part,\n      columnKey: focusedElement.columnKey,\n      rowKey: focusedElement.rowKey,\n      index: 0,\n    };\n\n  }\n  if (!isDefined(focusedElement.index) && innerElements.length && isSpanInput(innerElements)) {\n    if (innerElements[0].tagName === 'SPAN') {\n      innerElements[0].click();\n    }\n    return {\n      part: focusedElement.part,\n      columnKey: focusedElement.columnKey,\n      rowKey: focusedElement.rowKey,\n      index: 0,\n    };\n  }\n\n  if (focusedElement.index === 0 && hasCellInput(innerElements)) {\n    return {\n      part: focusedElement.part,\n      columnKey: focusedElement.columnKey,\n      rowKey: focusedElement.rowKey,\n    };\n  }\n\n  return;\n};\n\nconst applyEscapeAction: PureComputed<[\n  Elements, InlineEditing, TableColumn[], TableRow[], FocusedElement?\n], FocusedElement | undefined> = (\n  elements, { cancelChangedRows, stopEditCells }, tableColumns, tableBodyRows, focusedElement,\n) => {\n  if (!focusedElement) {\n    return;\n  }\n  const innerElements = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey);\n  const columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  const rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);\n\n  if (focusedElement.index === 0 && hasCellInput(innerElements)) {\n    if (focusedElement.part === DATA_TYPE && cancelChangedRows) {\n      cancelChangedRows({\n        rowIds: [tableBodyRows[rowIndex].rowId],\n      });\n      stopEditCells!({\n        editingCells: [{\n          rowId: tableBodyRows[rowIndex].rowId,\n          columnName: tableColumns[columnIndex].column!.name,\n        }],\n      });\n    }\n    return {\n      part: focusedElement.part,\n      columnKey: focusedElement.columnKey,\n      rowKey: focusedElement.rowKey,\n    };\n  }\n  return;\n};\n\nconst actionOnCheckbox: PureComputed<[Elements, FocusedElement?], void> = (\n  elements, focusedElement,\n) => {\n  if (!focusedElement || isDefined(focusedElement.index)) {\n    return;\n  }\n\n  const el = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey, 'input')\n  .filter((element: any) => {\n    return element.type === 'checkbox';\n  });\n  if (el[0]) {\n    el[0].click();\n  }\n};\n\nconst actionOnTreeMode: PureComputed<[Elements, RowId[], number, FocusedElement], void> = (\n  elements, expandedRowIds, direction, focusedElement,\n) => {\n  if (!focusedElement || isDefined(focusedElement.index) || !expandedRowIds) {\n    return;\n  }\n  const el = getInnerElements(\n    elements, focusedElement.rowKey, focusedElement.columnKey, 'button, i',\n  );\n  const index = getIndexFromKey(focusedElement.rowKey);\n  if (direction > 0 && expandedRowIds.indexOf(index) === -1 ||\n  direction < 0 && expandedRowIds.indexOf(index) > -1) {\n    if (el[0]) {\n      el[0].click();\n    }\n  }\n};\n\nexport const getInnerElements: GetInnerElementsFn = (\n  elements, key1, key2, query = '[tabIndex], input, button, a',\n) => {\n  return Array.from(elements[key1][key2][0].current.querySelectorAll(query)).filter((el: any) => {\n    return !el.hasAttribute('disabled') && el.getAttribute('tabindex') !== '-1';\n  });\n};\n\nconst getCellTopBottom: PureComputed<[number, FocusedElement, TableRow[], TableColumn[], Elements],\nFocusedElement | undefined> = (\n  direction, focusedElement, tableBodyRows, tableColumns, elements,\n) => {\n  if (focusedElement.part !== DATA_TYPE) {\n    return;\n  }\n  const columnIndex = getIndex(tableColumns, focusedElement.columnKey);\n  const rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);\n  if (tableBodyRows[rowIndex + direction]) {\n    const columnKey = getNextPrevClosestColumnKey(\n      tableColumns, columnIndex, tableBodyRows[rowIndex + direction].key, elements, -1,\n    );\n    if (columnKey) {\n      return {\n        rowKey: tableBodyRows[rowIndex + direction].key,\n        columnKey,\n        part: focusedElement.part,\n      };\n    }\n  }\n  return;\n};\n\nconst isCtrlMetaKey = (event: any) => {\n  return event.ctrlKey || event.metaKey;\n};\n\nconst getIndexFromKey = (key: string) => {\n  const array = key.split('_');\n  return Number(array[array.length - 1]);\n};\n\nconst getCellNextPrevPart: GetCellNextPrevPartFn = (focusedElement, elements,\n  tableBodyRows, tableColumns, direction,\n  scrollToColumn) => {\n  const part = direction > 0 ? getNextPart(focusedElement, elements, tableBodyRows) :\n  getPrevPart(focusedElement, elements, tableBodyRows);\n  if (part) {\n    const rowKey = getRowKey(part, tableBodyRows[0].key);\n    const columnKey = tableColumns[0].key;\n    return {\n      element: {\n        part,\n        rowKey,\n        columnKey,\n      },\n      scrolling: shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn) ? 'left' : undefined,\n    };\n  }\n\n  return {};\n};\n\nconst applyFocusOnToolbarPaging: PureComputed<\n  [Elements, number], void\n> = (elements, direction) => {\n  if (direction > 0 && elements.paging) {\n    getInnerElements(elements, 'paging', 'none')[0].focus();\n  }\n  if (direction < 0 && elements.toolbar) {\n    getInnerElements(elements, 'toolbar', 'none')[0].focus();\n  }\n};\n\nexport const getClosestCellByRow: PureComputed<\n  [TableRow[], FocusedElement, Elements], FocusedElement\n> = (\n  tableBodyRows, focusedElement, elements,\n) => {\n  const currentIndex = getIndexFromKey(focusedElement.rowKey);\n  const bodyRow = tableBodyRows.find((row) => {\n    return getIndexFromKey(row.key) > currentIndex;\n  });\n  const rowKey = bodyRow ? bodyRow.key : tableBodyRows[tableBodyRows.length - 1].key;\n  const columnKey = focusedElement.columnKey;\n  return {\n    rowKey,\n    columnKey,\n    part: focusedElement.part,\n    index: getIndexInnerElement(elements, rowKey, columnKey, 1),\n  };\n};\n\nexport const getNextFocusedCell: GetNextFocusedElementFn = (\n  tableColumns, tableBodyRows, tableHeaderRows,\n  expandedRowIds, elements, event, inlineEditing, focusedElement,\n  scrollToColumn,\n) => {\n  if (!focusedElement) {\n    const { toolbarElements, pagingElements } = getToolbarPagingElements(elements);\n    const hasFocus = (innerElements: readonly any[]) => {\n      return innerElements.some((el: any) => {\n        return event.target === el;\n      });\n    };\n    if (isCtrlMetaKey(event)) {\n      if (event.key === 'ArrowDown' &&\n      (toolbarElements && hasFocus(toolbarElements) || !toolbarElements)) {\n        return getFirstCell(elements, tableBodyRows, tableColumns,\n          tableHeaderRows, scrollToColumn);\n      }\n      if (event.key === 'ArrowUp' &&\n      (pagingElements && hasFocus(pagingElements) || !pagingElements)) {\n        return getFirstCellInLastPart(elements, tableBodyRows, tableColumns, scrollToColumn);\n      }\n    } else if (event.key === 'Tab') {\n      if (toolbarElements && event.target === toolbarElements[toolbarElements.length - 1] &&\n         !event.shiftKey) {\n        return getFirstCell(elements, tableBodyRows, tableColumns,\n          tableHeaderRows, scrollToColumn, true);\n      }\n      if (pagingElements && event.target === pagingElements[0] && event.shiftKey) {\n        if (scrollToColumn) {\n          return getFirstCellInLastPart(elements, tableBodyRows,\n            tableColumns, scrollToColumn, true);\n        }\n        return getLastCell(elements, tableBodyRows, tableColumns);\n      }\n      const { element } = !event.shiftKey ? getFirstCell(elements, tableBodyRows, tableColumns,\n        tableHeaderRows, undefined, true) :\n        getLastCell(elements, tableBodyRows, tableColumns);\n\n      if (element &&\n        event.target === elements[element.rowKey][element.columnKey][0].current) {\n        return { element };\n      }\n    }\n    return {};\n  }\n  let cell;\n  switch (event.key) {\n    case 'Enter':\n      cell = {\n        element: applyEnterAction(elements, inlineEditing, tableColumns,\n          tableBodyRows, focusedElement),\n      };\n      break;\n    case 'Escape':\n      cell = {\n        element: applyEscapeAction(elements, inlineEditing, tableColumns,\n          tableBodyRows, focusedElement),\n      };\n      break;\n    case ' ':\n      actionOnCheckbox(elements, focusedElement);\n      break;\n    case 'Tab':\n      if (event.shiftKey) {\n        cell = getPrevElement(focusedElement, tableBodyRows, tableColumns,\n          tableHeaderRows, elements, scrollToColumn);\n      } else {\n        cell = getNextElement(focusedElement, tableBodyRows, tableColumns,\n          tableHeaderRows, elements, scrollToColumn);\n      }\n      break;\n    case 'ArrowUp':\n      if (isCtrlMetaKey(event)) {\n        cell = getCellNextPrevPart(focusedElement, elements, tableBodyRows,\n          tableColumns, -1, scrollToColumn);\n        if (!cell.element) {\n          applyFocusOnToolbarPaging(elements, -1);\n        }\n      } else {\n        cell = {\n          element: getCellTopBottom(-1, focusedElement, tableBodyRows, tableColumns, elements),\n        };\n      }\n      break;\n    case 'ArrowDown':\n      if (isCtrlMetaKey(event)) {\n        cell = getCellNextPrevPart(focusedElement, elements, tableBodyRows,\n          tableColumns, 1, scrollToColumn);\n        if (!cell.element) {\n          applyFocusOnToolbarPaging(elements, 1);\n        }\n      } else {\n        cell = {\n          element: getCellTopBottom(1, focusedElement, tableBodyRows, tableColumns, elements),\n        };\n      }\n      break;\n    case 'ArrowLeft':\n      if (isCtrlMetaKey(event)) {\n        actionOnTreeMode(elements, expandedRowIds, -1, focusedElement);\n      } else {\n        cell = { element: getCellRightLeft(-1, focusedElement, tableColumns, elements) };\n      }\n      break;\n    case 'ArrowRight':\n      if (isCtrlMetaKey(event)) {\n        actionOnTreeMode(elements, expandedRowIds, 1, focusedElement);\n      } else {\n        cell = { element: getCellRightLeft(1, focusedElement, tableColumns, elements) };\n      }\n      break;\n  }\n  return cell || {};\n};\n\nexport const getPart = (key: string): string => {\n  if (tableParts.find(t => t === key)) {\n    return key;\n  }\n  if (key.includes(BAND_TYPE)) {\n    return HEADING_TYPE;\n  }\n  return DATA_TYPE;\n};\n\nexport const getIndexToFocus: PureComputed<[\n  string, string, Elements, any, InlineEditing, string,\n], number | undefined> = (\n  key1, key2, elements, event, { startEditCells }, part,\n) => {\n  if (startEditCells && part === DATA_TYPE) {\n    return 0;\n  }\n  const innerElements = getInnerElements(elements, key1, key2);\n  const index = innerElements.findIndex((el) => {\n    return event.target === el;\n  });\n  return index !== -1 ? index : undefined;\n};\n\nexport const filterHeaderRows = (tableHeaderRows: TableRow[]) => {\n  return tableHeaderRows.filter(row =>\n    row.key.includes(BAND_TYPE) || row.key.includes(HEADING_TYPE));\n};\n\nexport const isRowFocused: PureComputed<[TableRow, string?], boolean> = (\n  tableRow, focusedRowKey,\n) => {\n  if (focusedRowKey) {\n    return tableRow.key === focusedRowKey;\n  }\n  return false;\n};\n\nexport const isCellExist: PureComputed<[Elements, FocusedElement], boolean> = (\n  elements, focusedElement,\n) => {\n  return !!(elements[focusedElement.rowKey] &&\n    elements[focusedElement.rowKey][focusedElement.columnKey]);\n};\n\nexport const isTabArrowUpDown = (event: any): boolean => {\n  return event.key === 'Tab' || isCtrlMetaKey(event) && (event.key === 'ArrowDown' || event.key === 'ArrowUp');\n};\n\nexport const focus: PureComputed<\n  [Elements, FocusedElement?,\n  FocusedElement?, OnFocusedCellChangeFn?], void\n> = (\n  elements, focusedElement, prevFocusedElement, onFocusedCellChange,\n) => {\n  if (!focusedElement || !elements[focusedElement.rowKey] ||\n      !elements[focusedElement.rowKey][focusedElement.columnKey]) {\n    return;\n  }\n  const el = focusedElement.index === undefined ?\n  elements[focusedElement.rowKey][focusedElement.columnKey][0] :\n  getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey)[focusedElement.index];\n\n  if (el) {\n    el.focus ? el.focus() : el.current.focus();\n    if (onFocusedCellChange &&\n        (prevFocusedElement?.rowKey !== focusedElement.rowKey ||\n          prevFocusedElement?.columnKey !== focusedElement.columnKey)) {\n      onFocusedCellChange({\n        rowKey: focusedElement.rowKey, columnKey: focusedElement.columnKey,\n      });\n    }\n  }\n};\n\nexport const isCellFocused: PureComputed<[\n  TableRow, TableColumn, FocusedElement?\n], boolean> = (row, column, focusedElement) => {\n  if (!focusedElement || isDefined(focusedElement.index)) {\n    return false;\n  }\n  return focusedElement.rowKey === row.key && focusedElement.columnKey === column.key;\n};\n","import {\n    FocusedElement, TableRow,\n} from '../../types';\n\nexport const getFocusing = (tableBodyRows: TableRow[], focusedElement?: FocusedElement) => {\n  if (!focusedElement) {\n    return [];\n  }\n  const focusedRow = tableBodyRows.find((row) => {\n    return row.key === focusedElement.rowKey;\n  });\n  return focusedRow ? [focusedRow.rowId] : [];\n};\n","import { GetTargetColumnGeometriesFn, GetNodeGeometriesFn } from '../types';\n\nexport const getTargetColumnGeometries: GetTargetColumnGeometriesFn = (\n  columnGeometries, sourceIndex,\n) => {\n  const sourceWidth = columnGeometries[sourceIndex].right - columnGeometries[sourceIndex].left;\n  const getWidthDifference = (index: number) => columnGeometries[index].right\n                                      - columnGeometries[index].left\n                                      - sourceWidth;\n\n  return columnGeometries\n    .map(({\n      top, right, bottom, left,\n    }, targetIndex) => {\n      let leftBorder = left;\n      if (targetIndex > 0 && targetIndex <= sourceIndex) {\n        leftBorder = Math.min(leftBorder, leftBorder - getWidthDifference(targetIndex - 1));\n      }\n      if (targetIndex > sourceIndex) {\n        leftBorder = Math.max(leftBorder, leftBorder + getWidthDifference(targetIndex));\n      }\n      let rightBorder = right;\n      if (targetIndex < columnGeometries.length - 1 && targetIndex >= sourceIndex) {\n        rightBorder = Math.max(rightBorder, rightBorder + getWidthDifference(targetIndex + 1));\n      }\n      if (targetIndex < sourceIndex) {\n        rightBorder = Math.min(rightBorder, rightBorder - getWidthDifference(targetIndex));\n      }\n\n      return {\n        top,\n        bottom,\n        right: rightBorder,\n        left: leftBorder,\n      };\n    });\n};\n\nexport const getCellGeometries: GetNodeGeometriesFn = (node) => {\n  const { left, right, width } = node.getBoundingClientRect();\n  const styleLeft = parseInt(node.style.left?.toString().replace('px', ''), 10);\n  const styleRight = parseInt(node.style.right?.toString().replace('px', ''), 10);\n\n  if (!isNaN(styleLeft)) {\n    const calculatedLeft = Math.max(styleLeft, left);\n    return {\n      left: calculatedLeft,\n      right: calculatedLeft + width,\n      isFixed: true,\n    };\n  }\n\n  if (!isNaN(styleRight)) {\n    // NOTE: get tableContainer (parent of first DIV element) to calculate 'right' value\n    let tableContainer = node as HTMLElement | null;\n    while (tableContainer && tableContainer.nodeName !== 'DIV') {\n      tableContainer = tableContainer.parentNode as HTMLElement;\n    }\n    tableContainer = tableContainer?.parentNode as HTMLElement;\n\n    if (tableContainer) {\n      const { width: tableWidth } = tableContainer.getBoundingClientRect();\n      const calculatedRight = Math.min(tableWidth - styleRight, right);\n      return {\n        left: calculatedRight - width,\n        right: calculatedRight,\n        isFixed: true,\n      };\n    }\n  }\n\n  return { left, right };\n};\n","import { easeOutCubic } from '@devexpress/dx-core';\nimport {\n  GetTableColumnGeometriesFn, GetTableTargetColumnIndexFn, ColumnAnimation,\n  GetColumnAnimationsFn, ColumnGeometry, FilterActiveAnimationsFn, EvalAnimationsFn,\n} from '../types';\n\nexport const getTableColumnGeometries: GetTableColumnGeometriesFn = (columns, tableWidth) => {\n  const columnWidths = columns\n    .map(column => column.width);\n\n  const freeSpace = tableWidth;\n  const restrictedSpace = columnWidths\n    .reduce(\n      (accum, width) => (accum as number)! + (typeof width === 'number' ? width : 0), 0) as number;\n  const freeSpacePortions = columnWidths\n    .reduce(\n      (accum, width) => (accum as number)! + (typeof width !== 'number' ? 1 : 0), 0) as number;\n  const freeSpacePortion = (freeSpace - restrictedSpace!) / freeSpacePortions!;\n\n  let lastRightPosition = 0;\n  return columnWidths\n    .map(width => (typeof width !== 'number' ? freeSpacePortion : width))\n    .map((width) => {\n      lastRightPosition += width;\n      return {\n        left: lastRightPosition - width,\n        right: lastRightPosition,\n      };\n    });\n};\n\nexport const getTableTargetColumnIndex: GetTableTargetColumnIndexFn = (\n  columnGeometries, offset,\n) => {\n  const indexes = columnGeometries.reduce((acc, { left, right }, index) => {\n    if (offset >= left && offset < right) {\n      acc.push(index);\n    }\n    return acc;\n  }, [] as number[]);\n\n  if (columnGeometries.some(({ left, right }) => left <= 0 && right <= 0)) {\n    if (indexes.some(index => columnGeometries[index].isFixed ||\n      columnGeometries[index].left <= 0 && columnGeometries[index].right <= 0)) {\n      return -1;\n    }\n  }\n\n  if (indexes.length === 2) {\n    return indexes.find(index => columnGeometries[index].isFixed)!;\n  }\n  if (indexes.length === 1) {\n    return indexes[0];\n  }\n  return -1;\n};\n\nconst ANIMATION_DURATION = 200;\n\nconst getAnimationProgress = (animation: ColumnAnimation) => (\n  new Date().getTime() - animation.startTime) / ANIMATION_DURATION;\n\nexport const getAnimations: GetColumnAnimationsFn = (\n  prevColumns,\n  nextColumns,\n  tableWidth,\n  prevAnimations,\n) => {\n  const resizing = prevColumns.map(column => column.key).join()\n    === nextColumns.map(column => column.key).join();\n\n  const prevColumnGeometries = new Map<string, ColumnGeometry>(\n    getTableColumnGeometries(prevColumns, tableWidth)\n      .map((geometry, index) => [prevColumns[index].key, geometry] as [string, ColumnGeometry])\n      .map(([key, geometry]) => {\n        const animation = prevAnimations.get(key);\n        if (!animation) return [key, geometry];\n        const progress = easeOutCubic(getAnimationProgress(animation));\n        const { to, from } = animation.left!;\n        const left = ((to - from) * progress) + from;\n        return [key, {\n          left,\n          right: geometry.right - (geometry.left - left),\n        }];\n      // tslint:disable-next-line:array-type\n      }) as [string, ColumnGeometry][],\n    );\n\n  const nextColumnGeometries = new Map(\n    getTableColumnGeometries(nextColumns, tableWidth)\n      // tslint:disable-next-line:array-type\n      .map((geometry, index) => [nextColumns[index].key, geometry]) as [string, ColumnGeometry][],\n  );\n\n  return new Map([...nextColumnGeometries.keys()]\n    .map((key) => {\n      const prev: any = prevColumnGeometries.get(key);\n      const next: any = nextColumnGeometries.get(key);\n\n      const result: ColumnAnimation = { startTime: new Date().getTime(), style: {} };\n      const takePrevColumnIntoAccount = !!prevAnimations.get(key) || (prev && !resizing);\n      if (Math.abs((takePrevColumnIntoAccount ? prev!.left : next!.left) - next!.left) > 1) {\n        result.left = { from: prev.left, to: next.left };\n      }\n      return [key, result] as [string, ColumnAnimation];\n    })\n    .filter((animation: [string, ColumnAnimation]) => animation[1].left));\n};\n\nexport const filterActiveAnimations: FilterActiveAnimationsFn = animations => new Map(\n  [...animations.entries()]\n    .filter(([, animation]) => getAnimationProgress(animation) < 1),\n);\n\nexport const evalAnimations: EvalAnimationsFn = animations => new Map([...animations.entries()]\n  .map(([key, animation]): [string, object] => {\n    const progress = easeOutCubic(getAnimationProgress(animation));\n    const result = { ...animation.style };\n    if (animation.left) {\n      const offset = (animation.left.to - animation.left.from) * (progress - 1);\n      (result as any).transform = `translateX(${offset}px)`;\n    }\n    return [key, result];\n  }));\n","import { getTargetColumnGeometries } from './column-geometries';\nimport { TargetColumnGeometry, GetGroupCellTargetIndexFn } from '../types';\nimport { PureComputed } from '@devexpress/dx-core';\n\nconst isOnTheSameLine: PureComputed<[TargetColumnGeometry, number], boolean> = (geometry, y) => (\n  y >= geometry.top && y <= geometry.bottom\n);\n\nconst rectToObject = ({\n  top, right, bottom, left,\n}: TargetColumnGeometry) => ({\n  top, right, bottom, left,\n});\n\nconst collapseGapsBetweenItems: PureComputed<[TargetColumnGeometry[]]> = geometries => (\n  geometries.map((geometry, index) => {\n    if (index !== geometries.length - 1 && geometry.top === geometries[index + 1].top) {\n      return {\n        ...geometry,\n        right: geometries[index + 1].left,\n      };\n    }\n    return geometry;\n  }));\n\nexport const getGroupCellTargetIndex: GetGroupCellTargetIndexFn = (\n  geometries, sourceIndex, { x, y },\n) => {\n  if (geometries.length === 0) return 0;\n\n  const targetGeometries = sourceIndex !== -1\n    ? getTargetColumnGeometries(geometries, sourceIndex)\n    : geometries.map(rectToObject);\n\n  const targetIndex = collapseGapsBetweenItems(targetGeometries)\n    .findIndex((geometry, index) => {\n      const inVerticalBounds = isOnTheSameLine(geometry, y);\n      const inHorizontalBounds = x >= geometry.left && x <= geometry.right;\n      const shouldGoFirst = index === 0 && x < geometry.left;\n      const shouldGoOnLineBreak = !inVerticalBounds\n        && !!geometries[index - 1]\n        && isOnTheSameLine(geometries[index - 1], y);\n\n      return (inVerticalBounds && inHorizontalBounds)\n        || shouldGoFirst\n        || shouldGoOnLineBreak;\n    });\n\n  return targetIndex === -1 ? geometries.length : targetIndex;\n};\n","import { PureComputed } from '@devexpress/dx-core';\n\ntype CompareFn = (...args: [any, any]) => boolean;\n/** @internal */\nexport const arraysEqual: PureComputed<[any[], any[], CompareFn?], boolean> = (\n  arrA, arrB, comparator = (a, b) => a === b,\n) => {\n  if (arrA.length !== arrB.length) {\n    return false;\n  }\n  for (let i = 0; i < arrA.length; i += 1) {\n    if (!comparator(arrA[i], arrB[i])) {\n      return false;\n    }\n  }\n  return true;\n};\n","import { GridViewport } from '../../types';\n\n/** @internal */\nexport const emptyViewport: GridViewport = {\n  columns: [[0, 0]],\n  rows: [0, 0],\n  headerRows: [0, 0],\n  footerRows: [0, 0],\n  top: 0,\n  left: 0,\n  width: 800,\n  height: 600,\n};\n\nexport const TOP_POSITION = Symbol('top');\nexport const BOTTOM_POSITION = Symbol('bottom');\nexport const LEFT_POSITION = Symbol('left');\nexport const RIGHT_POSITION = Symbol('right');\n","import {\n  getRowsVisibleBoundary, getColumnBoundaries,\n} from '../../utils/virtual-table';\nimport {\n  GetViewportFn,\n  CheckTableColumnWidths,\n  TableColumn,\n  GetScrollHeightByIndex,\n  GetScrollPosition,\n  GetTopRowId,\n  GetScrollLeft,\n  IsColumnsWidthDifferent,\n} from '../../types';\nimport { arraysEqual } from './utils';\nimport { TOP_POSITION, BOTTOM_POSITION, LEFT_POSITION } from './constants';\n\nconst VALID_UNITS = ['px', ''];\n/* tslint:disable max-line-length */\nconst VIRTUAL_TABLE_ERROR = 'The columnExtension property of the VirtualTable plugin is given an invalid value.';\n\nexport const getViewport: GetViewportFn = (\n  state, getters, getRowHeight, getColumnWidth,\n) => {\n  const {\n    viewportTop, skipItems, viewportLeft, containerWidth, containerHeight,\n  } = state;\n  const {\n    loadedRowsStart,\n    bodyRows: tableBodyRows,\n    columns: tableColumns,\n    headerRows: tableHeaderRows = [],\n    footerRows: tableFooterRows = [],\n    isDataRemote,\n    viewport,\n  } = getters;\n\n  const rows = getRowsVisibleBoundary(\n    tableBodyRows, viewportTop, containerHeight,\n    getRowHeight, skipItems, loadedRowsStart, isDataRemote,\n  );\n  const headerRows = [0, tableHeaderRows.length ? tableHeaderRows.length - 1 : 0];\n  const footerRows = [0, tableFooterRows.length ? tableFooterRows.length - 1 : 0];\n  const columns = getColumnBoundaries(\n    tableColumns, viewportLeft, containerWidth, getColumnWidth,\n  );\n\n  // NOTE: prevent unnecessary updates\n  // e.g. when rows changed but bounds remain the same.\n  let result = viewport;\n  if (viewportTop !== viewport.top) {\n    result = { ...result, top: viewportTop };\n  }\n  if (viewportLeft !== viewport.left) {\n    result = { ...result, left: viewportLeft };\n  }\n  if (containerWidth !== viewport.width) {\n    result = { ...result, width: containerWidth };\n  }\n  if (containerHeight !== viewport.height) {\n    result = { ...result, height: containerHeight };\n  }\n  if (!arraysEqual(rows, viewport.rows)) {\n    result = { ...result, rows };\n  }\n  if (!arraysEqual(headerRows, viewport.headerRows)) {\n    result = { ...result, headerRows };\n  }\n  if (!arraysEqual(footerRows, viewport.footerRows)) {\n    result = { ...result, footerRows };\n  }\n  if (!arraysEqual(columns, viewport.columns, arraysEqual)) {\n    result = { ...result, columns };\n  }\n\n  return result;\n};\n\nexport const checkColumnWidths: CheckTableColumnWidths = (tableColumns) => {\n  return tableColumns.reduce((acc, tableColumn) => {\n    const { width } = tableColumn;\n    if (typeof width === 'string') {\n      const numb = parseInt(width, 10);\n      const unit = numb ? width.substr(numb.toString().length) : width;\n      const isValidUnit = VALID_UNITS.some(validUnit => validUnit === unit);\n      if (!isValidUnit) {\n        throw new Error(VIRTUAL_TABLE_ERROR);\n      }\n      acc.push({ ...tableColumn, width: numb });\n    } else {\n      acc.push(tableColumn);\n    }\n    return acc;\n  }, []  as TableColumn[]);\n};\n\nexport const calculateScrollHeight: GetScrollHeightByIndex = (rowHeight, index) =>\n  index > -1 ? rowHeight * index : undefined;\n\nexport const getScrollTop: GetScrollPosition = (rows, rowsCount, rowId, rowHeight, isDataRemote) => {\n  if (rowId === TOP_POSITION) {\n    return 0;\n  }\n  if (rowId === BOTTOM_POSITION) {\n    return rowsCount * rowHeight;\n  }\n\n  const searchIndexRequired = !isDataRemote && rowId !== undefined;\n  const indexById = searchIndexRequired\n    ? rows.findIndex(row => row.rowId === rowId)\n    : undefined;\n\n  return calculateScrollHeight(\n    rowHeight,\n    indexById!,\n  );\n};\n\nexport const getScrollLeft: GetScrollLeft = (columnCount, columnWidth, columnId) => {\n  if (!columnId) {\n    return;\n  }\n  if (columnId === LEFT_POSITION) {\n    return 0;\n  }\n  return columnCount * columnWidth;\n};\n\nexport const getTopRowId: GetTopRowId = (viewport, tableBodyRows, isDataRemote) => {\n  const hasViewportRows = viewport && viewport.rows;\n  const hasBodyRows = tableBodyRows && tableBodyRows.length;\n  if (hasViewportRows && hasBodyRows && !isDataRemote) {\n    const index = viewport.rows[0];\n\n    return index < tableBodyRows.length ? tableBodyRows[index].rowId : undefined;\n  }\n\n  return undefined;\n};\n\nexport const isColumnsWidthDifferent: IsColumnsWidthDifferent = (prevColumns, columns) => {\n  return prevColumns.some((column) => {\n    const currentColumn = columns.find(c => c.key === column.key);\n    return currentColumn ? currentColumn.width !== column.width : true;\n  });\n};\n","import { mergeRows } from './helpers';\nimport { intervalUtil } from './utils';\nimport { VirtualRowsWithCacheFn, PlainRowsFn, LoadedRowsStartFn } from '../../types';\n\nexport const virtualRowsWithCache: VirtualRowsWithCacheFn = (skip, rows, cache) => {\n  const rowsInterval = intervalUtil.getRowsInterval({ skip, rows });\n  const cacheInterval = intervalUtil.getRowsInterval(cache);\n\n  return mergeRows(rowsInterval, cacheInterval, rows, cache.rows, skip, cache.skip);\n};\n\nexport const plainRows: PlainRowsFn = (virtualRows, availableRowCount) => {\n  return virtualRows.rows.length > availableRowCount\n    ? virtualRows.rows.slice(0, availableRowCount)\n    : virtualRows.rows;\n};\n\nexport const loadedRowsStart: LoadedRowsStartFn = virtualRows => virtualRows.skip;\n","export const ROOT_GROUP = '__root__';\nexport const DEFAULT_COLUMN_WIDTH = 150;\n","// tslint:disable-next-line: no-submodule-imports\nimport * as Excel from 'exceljs';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  TableColumn, FindRangesFn, ExportRowsFn,\n  CloseSheetFn,\n  ExportSummaryItemsFn,\n  RemoveEmptyGroupsFn,\n} from '../../types';\nimport { ROOT_GROUP, DEFAULT_COLUMN_WIDTH } from './constants';\n\nexport const exportHeader = (worksheet: Excel.Worksheet, columns: TableColumn[]) => {\n  const cols = columns\n    .map(({ column, width }) => ({\n      width: (width as number || DEFAULT_COLUMN_WIDTH) / 8,\n      key: column?.name,\n    }));\n  worksheet.columns = cols;\n\n  const headerRow = columns.reduce((acc, { column: { name, title } = {} }) => ({\n    ...acc,\n    [name!]: title,\n  }), {});\n  worksheet.addRow(headerRow);\n\n  worksheet.views.push({\n    state: 'frozen', ySplit: worksheet.lastRow!.number,\n  });\n};\n\nexport const findRanges: FindRangesFn = (groupTree, compoundKey, level, maxLevel, result = []) => {\n  if (level !== maxLevel) {\n    const ranges = (groupTree[compoundKey] as string[]).reduce((acc, groupKey) => (\n      [...acc, ...findRanges(groupTree, groupKey, level + 1, maxLevel, result)]\n    ), [] as Array<number[]>);\n    return [...result, ...ranges];\n  }\n  return [...result, groupTree[compoundKey] as number[]];\n};\n\nexport const exportRows: ExportRowsFn = (\n  worksheet, allRows, dataColumns, columns, isGroupRow, outlineLevels,\n  rowsOffset, getCellValue, getCloseGroup, customizeCell,\n) => {\n  let currentLevel = 0;\n  let openGroups: any[] = [];\n  const closeGroup = getCloseGroup(rowsOffset);\n\n  allRows.forEach((row) => {\n    let excelRow;\n\n    if (isGroupRow && isGroupRow(row)) {\n      currentLevel = outlineLevels[row.groupedBy];\n\n      // close nested groups first\n      openGroups.slice(currentLevel).reverse().forEach(closeGroup);\n\n      openGroups = openGroups.slice(0, currentLevel);\n      openGroups[currentLevel] = { groupedBy: row.groupedBy, compoundKey: row.compoundKey };\n\n      // add group row\n      const title = dataColumns.find(({ name }) => name === row.groupedBy)?.title;\n      excelRow = { [columns[0].column!.name]: `${title}: ${row.value}` };\n\n      worksheet.addRow(excelRow);\n      const lastIndex = worksheet.lastRow!.number;\n\n      // merge into single cell\n      worksheet.mergeCells(lastIndex, 1, lastIndex, columns.length);\n      worksheet.lastRow!.getCell(1).font = { bold: true };\n\n      if (currentLevel > 0) {\n        worksheet.lastRow!.outlineLevel = currentLevel;\n      }\n      currentLevel += 1;\n    } else {\n      excelRow = columns.reduce((acc, { column }) => ({\n        ...acc,\n        ...(column ? { [column.name]: getCellValue(row, column.name) } : null),\n      }), {});\n      worksheet.addRow(excelRow);\n      worksheet.lastRow!.outlineLevel = currentLevel;\n    }\n\n    worksheet.lastRow!.eachCell((cell, colNumber) => {\n      customizeCell(cell, row, columns[colNumber - 1].column!);\n    });\n  });\n\n  openGroups.reverse().forEach(closeGroup);\n};\n\nexport const closeSheet: CloseSheetFn = (\n  worksheet, groupTree, maxGroupLevel, rowsOffset, totalSummaryItems, exportSummary,\n) => {\n  exportSummaryItems(\n    worksheet, groupTree, totalSummaryItems, ROOT_GROUP, -1,\n    rowsOffset, maxGroupLevel, exportSummary,\n  );\n};\n\nexport const normalizeRanges: PureComputed<[number[][], number]> = (ranges, offset) => (\n  ranges.map(range => range.map(index => + index + offset))\n);\n\nexport const exportSummaryItems: ExportSummaryItemsFn = (\n  worksheet, groupTree, summaryItems, groupKey, groupLevel,\n  rowsOffset, maxGroupLevel, exportSummary,\n) => {\n  if (!summaryItems) return;\n\n  worksheet.addRow({});\n\n  const ranges = normalizeRanges(\n    findRanges(groupTree, groupKey, groupLevel, maxGroupLevel),\n    rowsOffset,\n  );\n\n  summaryItems.forEach((s) => {\n    exportSummary(s, ranges);\n  });\n};\n\nexport const removeEmptyGroups: RemoveEmptyGroupsFn = (rows, grouping, isGroupRow) => {\n  if (!grouping) return rows;\n\n  const groupingColumns = grouping.map(({ columnName }) => columnName);\n  const result: any[] = [];\n  let groupChain: any[] = [];\n\n  rows.forEach((row) => {\n    if (isGroupRow(row)) {\n      const level = groupingColumns.indexOf(row.groupedBy);\n      if (level === groupChain.length) {\n        groupChain.push(row);\n      } else {\n        groupChain = [...groupChain.slice(0, level), row];\n      }\n    } else {\n      if (groupChain.length > 0) {\n        result.push(...groupChain);\n        groupChain = Array.from({ length: groupChain.length });\n      }\n      result.push(row);\n    }\n  });\n\n  return result.filter(row => !!row);\n};\n","import {\n  OutlineLevelsFn, FilterSelectedRowsFn, GetRowsToExportFn, Row, BuildGroupTreeFn,\n  GetExportSummaryFn, GetCloseGroupFn, Grouping, RowId,\n} from '../../types';\nimport { PureComputed } from '@devexpress/dx-core';\nimport { ROOT_GROUP } from './constants';\nimport { exportSummaryItems, removeEmptyGroups } from './helpers';\nimport { TABLE_DATA_TYPE } from '../table/constants';\n\nexport const groupOutlineLevels: OutlineLevelsFn = grouping => (\n  grouping?.reduce((acc, { columnName }, index) => ({\n    ...acc,\n    [columnName]: index,\n  }), {}) || {}\n);\n\nconst filterSelectedRows: FilterSelectedRowsFn = (rows, selection, getRowId, isGroupRow) => {\n  const selectionSet = new Set<RowId>(selection);\n  return rows.filter(row => (\n    isGroupRow && isGroupRow(row)) || selectionSet.has(getRowId(row)),\n  );\n};\n\nexport const rowsToExport: GetRowsToExportFn = (\n  rows, selection, grouping, getCollapsedRows, getRowId, isGroupRow,\n) => {\n  const expandRows: PureComputed<[Row[]]> = collapsedRows => (\n    collapsedRows.reduce((acc, row) => (\n      [...acc, row, ...(expandRows(getCollapsedRows!(row) || []))]\n    ), [])\n  );\n\n  const expandedRows = getCollapsedRows ? expandRows(rows) : rows;\n\n  if (!selection) {\n    return expandedRows;\n  }\n\n  const filteredRows = filterSelectedRows(expandedRows, selection, getRowId, isGroupRow);\n  return removeEmptyGroups(filteredRows, grouping, isGroupRow);\n};\n\nexport const buildGroupTree: BuildGroupTreeFn = (\n  rows, outlineLevels, grouping, isGroupRow, groupSummaryItems,\n) => {\n  const groupTree = { [ROOT_GROUP]: [] as any[] };\n\n  if (!grouping?.length) {\n    groupTree[ROOT_GROUP] = [0, rows.length - 1];\n    return groupTree;\n  }\n\n  const maxLevel = Object.keys(outlineLevels).length - 1;\n  const groupSummaryExists = !!groupSummaryItems;\n  const parentChain = { '-1': ROOT_GROUP };\n  let lastDataIndex = 0;\n  let openGroup = '';\n  let index = 0;\n  let level = 0;\n  let prevLevel = 0;\n\n  rows.forEach((row) => {\n    const { groupedBy, compoundKey } = row;\n    if (isGroupRow(row)) {\n      level = outlineLevels[groupedBy];\n      groupTree[compoundKey] = [];\n      parentChain[level] = compoundKey;\n      if (level <= maxLevel) {\n        groupTree[parentChain[level - 1]].push(compoundKey);\n      }\n      if (level === maxLevel) {\n        if (openGroup) {\n          // close previous group\n          groupTree[openGroup].push(lastDataIndex);\n        }\n        openGroup = compoundKey;\n        if (groupSummaryExists && lastDataIndex > 0) {\n          index += 1;\n        }\n        groupTree[compoundKey].push(index + 1); // first row index\n      } else if (groupSummaryExists && level < prevLevel) {\n        // jump over summary rows\n        index += maxLevel - level;\n      }\n      prevLevel = level;\n    } else {\n      lastDataIndex = index;\n    }\n    index += 1;\n  });\n\n  if (openGroup) {\n    groupTree[openGroup].push(lastDataIndex);\n  }\n\n  return groupTree;\n};\n\nconst operations = {\n  count: 'COUNTA',\n};\nexport const exportSummaryGetter: GetExportSummaryFn = (\n  worksheet, tableColumns, customizeSummaryCell, defaultSummaryMessages,\n) => (\n  { columnName, type }, ranges,\n) => {\n  const { column } = tableColumns.find(({ column: dataColumn, type: columnType }) => (\n    columnType === TABLE_DATA_TYPE && dataColumn && dataColumn.name === columnName\n  )) || {};\n  // NOTE: column is hidden or the grid grouped by this column\n  if (!column) {\n    return;\n  }\n\n  const row = worksheet.lastRow!;\n  const letter = worksheet.getColumn(columnName).letter;\n  const operation = operations[type] || type.toUpperCase();\n  const rangesStr = ranges.map(range => (\n    range\n      .map(r => `${letter}${r}`)\n      .filter((val, index, arr) => arr.indexOf(val) === index)\n      .join(':')\n  )).join(',');\n\n  const cell = row.getCell(columnName);\n  cell.value = {\n    formula: `${operation}(${rangesStr})`,\n    date1904: false,\n  };\n  cell.numFmt = `\"${defaultSummaryMessages[type]}:\" 0`;\n\n  const summary = {\n    type,\n    ranges,\n  };\n  customizeSummaryCell(cell, column!, summary);\n};\n\nexport const closeGroupGetter: GetCloseGroupFn = (\n  worksheet, groupTree, outlineLevels, maxGroupLevel, groupSummaryItems, exportSummary,\n) => rowsOffset => (group) => {\n  const { groupedBy, compoundKey } = group;\n\n  exportSummaryItems(\n    worksheet, groupTree, groupSummaryItems, compoundKey, outlineLevels[groupedBy],\n    rowsOffset, maxGroupLevel, exportSummary,\n  );\n};\n\nexport const maximumGroupLevel: PureComputed<[Grouping[]], number> = grouping => (\n  (grouping || []).length - 1\n);\n"]},"metadata":{},"sourceType":"module"}